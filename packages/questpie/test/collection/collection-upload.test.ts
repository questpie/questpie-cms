import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import { collection, questpie } from "../../src/server/index.js";
import { buildMockApp } from "../utils/mocks/mock-app-builder";
import { createTestContext } from "../utils/test-context";
import { runTestDbMigrations } from "../utils/test-db";

// ==============================================================================
// TEST COLLECTIONS SETUP
// ==============================================================================

// Assets collection with .upload() for URL generation testing
const assets = collection("assets")
	.options({ timestamps: true })
	.fields((f) => ({
		alt: f.text({ maxLength: 500 }),
		caption: f.textarea(),
	}))
	.upload({
		visibility: "public",
	});

// Services collection that references assets (using f.relation())
const services = collection("services").fields((f) => ({
	name: f.text({ required: true, maxLength: 255 }),
	image: f.relation({
		to: "assets",
		relationName: "image",
	}),
}));

const testModule = questpie({ name: "upload-test" }).collections({
	assets,
	services,
});

// ==============================================================================
// TESTS
// ==============================================================================

describe("collection upload URL generation", () => {
	let setup: Awaited<ReturnType<typeof buildMockApp<typeof testModule>>>;
	let cms: typeof testModule.$inferCms;

	beforeEach(async () => {
		setup = await buildMockApp(testModule);
		cms = setup.cms;
		await runTestDbMigrations(cms);
	});

	afterEach(async () => {
		await setup.cleanup();
	});

	describe("afterRead hook URL generation", () => {
		it("generates URL for assets when fetching directly", async () => {
			const ctx = createTestContext();
			const assetsCrud = cms.api.collections.assets;

			// Create an asset with a key (simulating an uploaded file)
			const asset = await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/test-image.png",
					filename: "test-image.png",
					mimeType: "image/png",
					size: 12345,
					visibility: "public",
					alt: "Test image",
				},
				ctx,
			);

			// Fetch the asset - URL should be generated by afterRead hook
			const fetchedAsset = await assetsCrud.findOne(
				{ where: { id: asset.id } },
				ctx,
			);

			expect(fetchedAsset).not.toBeNull();
			expect(fetchedAsset?.key).toBe("uploads/test-image.png");
			expect(fetchedAsset?.filename).toBe("test-image.png");
			// URL should be generated by the afterRead hook
			expect((fetchedAsset as any)?.url).toBeDefined();
			expect(typeof (fetchedAsset as any)?.url).toBe("string");
		});

		it("generates URL for assets in find (multiple records)", async () => {
			const ctx = createTestContext();
			const assetsCrud = cms.api.collections.assets;

			// Create multiple assets
			await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/image1.png",
					filename: "image1.png",
					mimeType: "image/png",
					size: 1000,
					visibility: "public",
				},
				ctx,
			);

			await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/image2.jpg",
					filename: "image2.jpg",
					mimeType: "image/jpeg",
					size: 2000,
					visibility: "public",
				},
				ctx,
			);

			// Fetch all assets
			const { docs } = await assetsCrud.find({}, ctx);

			expect(docs).toHaveLength(2);
			// All assets should have URLs
			for (const asset of docs) {
				expect((asset as any).url).toBeDefined();
				expect(typeof (asset as any).url).toBe("string");
			}
		});

		it("generates URL for assets when expanding relations", async () => {
			const ctx = createTestContext();
			const assetsCrud = cms.api.collections.assets;
			const servicesCrud = cms.api.collections.services;

			// Create an asset
			const asset = await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/service-image.png",
					filename: "service-image.png",
					mimeType: "image/png",
					size: 5000,
					visibility: "public",
				},
				ctx,
			);

			// Create a service referencing the asset (using field name with unified API)
			const service = await servicesCrud.create(
				{
					id: crypto.randomUUID(),
					name: "Haircut",
					image: asset.id, // FK column key is field name with unified API
				} as any,
				ctx,
			);

			// Fetch service with expanded image relation
			const serviceWithImage = (await servicesCrud.findOne(
				{ where: { id: service.id }, with: { image: true } },
				ctx,
			)) as any;

			expect(serviceWithImage).not.toBeNull();
			expect(serviceWithImage?.image).not.toBeNull();
			expect(serviceWithImage?.image?.id).toBe(asset.id);
			expect(serviceWithImage?.image?.filename).toBe("service-image.png");
			// URL should be generated for the expanded relation
			expect(serviceWithImage?.image?.url).toBeDefined();
			expect(typeof serviceWithImage?.image?.url).toBe("string");
		});

		it("URL generation handles both public and private visibility", async () => {
			const ctx = createTestContext();
			const assetsCrud = cms.api.collections.assets;

			// Create a public asset
			const publicAsset = await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/public-image.png",
					filename: "public-image.png",
					mimeType: "image/png",
					size: 1000,
					visibility: "public",
				},
				ctx,
			);

			// Create a private asset
			const privateAsset = await assetsCrud.create(
				{
					id: crypto.randomUUID(),
					key: "uploads/private-image.png",
					filename: "private-image.png",
					mimeType: "image/png",
					size: 1000,
					visibility: "private",
				},
				ctx,
			);

			// Fetch both assets
			const fetchedPublic = await assetsCrud.findOne(
				{ where: { id: publicAsset.id } },
				ctx,
			);
			const fetchedPrivate = await assetsCrud.findOne(
				{ where: { id: privateAsset.id } },
				ctx,
			);

			// Both should have URLs generated
			expect((fetchedPublic as any)?.url).toBeDefined();
			expect((fetchedPrivate as any)?.url).toBeDefined();
			// Both should be strings (signed URLs for private, regular URLs for public)
			expect(typeof (fetchedPublic as any)?.url).toBe("string");
			expect(typeof (fetchedPrivate as any)?.url).toBe("string");
		});
	});
});
