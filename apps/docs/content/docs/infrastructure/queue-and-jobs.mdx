---
title: Queue & Jobs
description: Background jobs, scheduled tasks, and workflows with pg-boss
---

# Queue & Jobs

QUESTPIE includes a job queue for running background tasks — email notifications, data processing, scheduled reports, and multi-step workflows. The default adapter uses [pg-boss](https://github.com/timgit/pg-boss), which runs on your existing PostgreSQL database.

## Why This Exists

Some operations are too slow or unreliable for synchronous API responses: sending emails, processing uploads, generating reports, or calling external APIs. Jobs let you push work to a background queue and process it asynchronously.

## Setup

```ts
import { pgBossAdapter } from "questpie";

.build({
  // ...
  queue: {
    adapter: pgBossAdapter({
      connectionString: process.env.DATABASE_URL,
    }),
  },
})
```

## Defining Jobs

Jobs are defined with `job()` and registered in the builder:

```ts
import { job } from "questpie";
import { z } from "zod";
import type { AppCMS } from "../cms";

export const sendAppointmentConfirmation = job<AppCMS>()({
  name: "sendAppointmentConfirmation",
  schema: z.object({
    appointmentId: z.string(),
    customerEmail: z.string(),
  }),
  handler: async ({ payload, app }) => {
    const appointment = await app.api.collections.appointments.findOne({
      where: { id: payload.appointmentId },
      with: { barber: true, service: true },
    });
    if (!appointment) throw new Error("Appointment not found");

    await app.email.sendTemplate({
      template: "appointmentConfirmation",
      to: payload.customerEmail,
      context: {
        customerName: appointment.customer?.name ?? "Customer",
        date: appointment.scheduledAt,
        barberName: appointment.barber?.name,
        serviceName: appointment.service?.name,
      },
    });
  },
  options: {
    retryLimit: 3,
    retryDelay: 5000,
    retryBackoff: true,
  },
});
```

Register jobs in the builder:

```ts
.jobs({
  sendAppointmentConfirmation,
  sendAppointmentCancellation,
  sendAppointmentReminder,
})
```

## Publishing Jobs

Publish jobs from hooks, RPC handlers, or anywhere you have access to `app`:

```ts
// In a hook
.hooks({
  afterChange: async ({ data, operation, app }) => {
    if (operation === "create") {
      await app.queue.sendAppointmentConfirmation.publish({
        appointmentId: data.id,
        customerEmail: data.customerEmail,
      });
    }
  },
})

// In an RPC handler
handler: async ({ input, app }) => {
  await app.queue.sendAppointmentReminder.publish({
    appointmentId: input.id,
  });
}
```

## Job Options

| Option | Type | Default | Description |
|---|---|---|---|
| `retryLimit` | `number` | `0` | Max retry attempts |
| `retryDelay` | `number` | `0` | Delay between retries (ms) |
| `retryBackoff` | `boolean` | `false` | Exponential backoff |
| `expireInSeconds` | `number` | — | Job TTL |
| `priority` | `number` | `0` | Higher = processed first |
| `startAfter` | `number \| Date` | — | Delay before first execution |
| `cron` | `string` | — | Cron schedule for recurring jobs |

## Scheduled Jobs

For recurring tasks, use cron scheduling:

```ts
// Register a cron schedule
await app.queue.sendDailyReport.schedule({}, "0 9 * * *");
// Runs at 9 AM every day

// Unschedule
await app.queue.sendDailyReport.unschedule();
```

## Workflows

Chain multiple jobs together with the workflow builder:

```ts
import { workflow } from "questpie";
import { z } from "zod";
import type { AppCMS } from "../cms";

const bookingWorkflow = workflow<AppCMS>()<{
  barberId: string;
  serviceId: string;
  date: string;
}>("processBooking")
  .step("validate", async ({ payload }) => payload)
  .step("createAppointment", async ({ payload, app }) => {
    const appointment = await app.api.collections.appointments.create(payload);
    return { appointment };
  })
  .step("sendConfirmation", async ({ payload, app }) => {
    await app.queue.sendAppointmentConfirmation.publish({
      appointmentId: payload.appointment.id,
      customerEmail: "user@example.com",
    });
    return payload;
  })
  .build(z.object({ barberId: z.string(), serviceId: z.string(), date: z.string() }));
```

Each step receives the output of the previous step as input.

## Running the Worker

Jobs need a worker process to consume them:

```ts
// worker.ts
import { cms } from "./cms";

// Long-running worker (recommended for servers)
await cms.queue.listen();

// Single-tick mode (for serverless)
await cms.queue.runOnce();
```

## Adapters

### pg-boss (Default)

Runs on PostgreSQL — no additional infrastructure needed:

```ts
pgBossAdapter({ connectionString: process.env.DATABASE_URL })
```

Supports: long-running workers, cron scheduling, singleton jobs, retries.

### Cloudflare Queues

For Cloudflare Workers deployments (push-based consumer model).

## Common Mistakes

- **Not running a worker** — Jobs are published to the queue but won't run without a worker process. Start one with `cms.queue.listen()`.
- **Synchronous email in hooks** — Move email sending to jobs so API responses stay fast.
- **No retry configuration** — External service calls (email, APIs) should have `retryLimit` and `retryBackoff` for resilience.
- **Using legacy `queue.publish(name, payload)`** — Use typed job methods: `app.queue.jobName.publish(payload)`.

## Type Safety Notes

- `job<AppCMS>()({...})` gives typed `app` in job handlers.
- `workflow<AppCMS>()(...)` gives typed `app` in each workflow step.
- In untyped contexts, use `getApp<AppCMS>(app)` or `getContext<AppCMS>(ctx)`.

## Related Pages

- [Email](/docs/infrastructure/email) — Send emails from jobs
- [Hooks & Lifecycle](/docs/server/hooks-and-lifecycle) — Publish jobs from hooks
- [Infrastructure API Reference](/docs/reference/infrastructure-api) — Queue method signatures
- [Type-Safe Contexts](/docs/server/type-safe-contexts) — Typed job/workflow handler patterns
