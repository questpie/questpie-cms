---
title: Queue System
description: Background job processing with typesafe jobs powered by pg-boss and PostgreSQL.
icon: Zap
---

# Queue System

QUESTPIE CMS includes a batteries-included, typesafe job queue system powered by **pg-boss**. Process background jobs reliably using your existing PostgreSQL database—no Redis or additional infrastructure required.

## Features

- **100% Typesafe** - Jobs are validated with Zod schemas at runtime and typed at compile-time
- **Zero Infrastructure** - Uses your existing PostgreSQL database
- **Auto-completion** - Full IDE support with `context.queue.jobName.publish()`
- **Workflows** - Chain multiple steps together for complex operations
- **Scheduling** - Support for delayed jobs and cron-based recurring jobs
- **Retries** - Built-in retry logic with exponential backoff
- **Worker Support** - Simple worker setup with `cms._listenToJobs()`

## Quick Start

### 1. Define Jobs

Create your jobs using `defineJob()` and `defineJobs()`:

```typescript
// jobs/email.ts
import { defineJob } from '@questpie/cms/server'
import { z } from 'zod'

export const sendEmailJob = defineJob({
  name: 'send-email',
  schema: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  handler: async (payload, context) => {
    await context.email.send({
      to: payload.to,
      subject: payload.subject,
      html: payload.body,
    })

    context.logger.info(`Email sent to ${payload.to}`)
  },
  options: {
    retryLimit: 3,
    retryDelay: 60, // seconds
    retryBackoff: true,
  },
})
```

### 2. Create Job Registry

Combine all your jobs into a registry:

```typescript
// jobs/index.ts
import { defineJobs } from '@questpie/cms/server'
import { sendEmailJob } from './email'
import { processImageJob } from './images'
import { generateReportJob } from './reports'

export const jobs = defineJobs({
  sendEmail: sendEmailJob,
  processImage: processImageJob,
  generateReport: generateReportJob,
})
```

### 3. Configure CMS

Add the queue configuration to your CMS instance:

```typescript
import { QCMS } from '@questpie/cms/server'
import { jobs } from './jobs'

const cms = new QCMS({
  db: {
    connection: {
      hostname: 'localhost',
      port: 5432,
      database: 'myapp',
      user: 'postgres',
      password: 'password',
    },
  },
  queue: {
    jobs,
    options: {
      schema: 'pgboss', // PostgreSQL schema for queue tables
      teamSize: 10, // Max concurrent jobs per worker
    },
  },
  // ... other config
})
```

### 4. Publish Jobs

In your application code (hooks, API routes, etc.), publish jobs to the queue:

```typescript
// In a collection hook
export const users = defineCollection('users')
  .fields({
    email: fields.text('email'),
    name: fields.text('name'),
  })
  .hooks({
    afterCreate: async ({ data, context }) => {
      // Send welcome email in background
      await context.queue.sendEmail.publish({
        to: data.email,
        subject: 'Welcome to QUESTPIE!',
        body: `<h1>Hello ${data.name}!</h1>`,
      })
    },
  })
```

### 5. Start Workers

Create a separate worker file to process jobs:

```typescript
// worker.ts
import { QCMS } from '@questpie/cms/server'
import { jobs } from './jobs'

const cms = new QCMS({
  // Same configuration as your main app
  queue: { jobs },
})

// Start listening to all jobs
await cms._listenToJobs()

console.log('Worker started!')
```

Run the worker:

```bash
bun run worker.ts
```

## Job Publishing Options

You can customize job execution with publish options:

```typescript
// Delayed job - start after 5 minutes
await context.queue.sendEmail.publish(
  { to: 'user@example.com', subject: 'Reminder', body: '...' },
  { startAfter: 300 } // seconds
)

// High priority job
await context.queue.processImage.publish(
  { imageUrl: 'https://...', sizes: [100, 200] },
  { priority: 10 } // higher = more important
)

// Singleton job - only one with this key can be queued
await context.queue.generateReport.publish(
  { userId: '123' },
  { singletonKey: 'report-123' }
)

// Custom retry configuration
await context.queue.sendEmail.publish(
  { to: 'user@example.com', subject: 'Critical', body: '...' },
  {
    retryLimit: 5,
    retryDelay: 120,
    retryBackoff: true,
  }
)
```

## Scheduling Recurring Jobs

Schedule jobs to run on a cron schedule:

```typescript
// Send daily report every day at 9 AM
await context.queue.generateReport.schedule(
  { type: 'daily' },
  '0 9 * * *' // cron expression
)

// Send weekly digest every Monday at 10 AM
await context.queue.sendEmail.schedule(
  { to: 'team@company.com', subject: 'Weekly Digest', body: '...' },
  '0 10 * * 1'
)

// Unschedule a recurring job
await context.queue.generateReport.unschedule()
```

## Worker Configuration

Customize how workers process jobs:

```typescript
// Listen to all jobs with custom team size
await cms._listenToJobs({ teamSize: 20 })

// Listen to specific jobs only
await cms._listenToJobs(['sendEmail', 'processImage'])

// Listen to specific jobs with custom options
await cms._listenToJobs(['sendEmail'], { teamSize: 50 })
```

## Architecture

### Database Schema

pg-boss creates its own tables in your PostgreSQL database (default schema: `pgboss`):
- `job` - Active and completed jobs
- `archive` - Archived job history
- `schedule` - Recurring job schedules
- `version` - Schema version tracking

### Job Lifecycle

1. **Published** - Job is sent to the queue
2. **Active** - Worker picks up the job
3. **Completed** - Job finishes successfully
4. **Failed** - Job fails (retries if configured)
5. **Archived** - Job is moved to archive table

### Worker Pattern

- Workers poll the database for new jobs
- Multiple workers can run simultaneously
- Jobs are distributed across workers
- Failed jobs are retried automatically
- Context is recreated for each job execution

## Best Practices

### 1. Keep Jobs Small

Break large operations into smaller jobs:

```typescript
// ❌ Bad - one giant job
const processOrderJob = defineJob({
  name: 'process-order',
  handler: async (payload, context) => {
    await validateOrder(payload)
    await chargePayment(payload)
    await updateInventory(payload)
    await sendConfirmation(payload)
    await notifyWarehouse(payload)
  },
})

// ✅ Good - separate jobs for each step
const validateOrderJob = defineJob({ ... })
const chargePaymentJob = defineJob({ ... })
const updateInventoryJob = defineJob({ ... })
// Chain them with workflows (see workflows guide)
```

### 2. Use Idempotent Handlers

Ensure jobs can be safely retried:

```typescript
const sendEmailJob = defineJob({
  name: 'send-email',
  handler: async (payload, context) => {
    // Check if already sent
    const sent = await context.db
      .select()
      .from(emailLog)
      .where(eq(emailLog.id, payload.emailId))

    if (sent.length > 0) {
      context.logger.info('Email already sent, skipping')
      return
    }

    // Send email
    await context.email.send(payload)

    // Log it
    await context.db.insert(emailLog).values({
      id: payload.emailId,
      sentAt: new Date(),
    })
  },
})
```

### 3. Handle Errors Gracefully

```typescript
const processImageJob = defineJob({
  name: 'process-image',
  handler: async (payload, context) => {
    try {
      const image = await downloadImage(payload.url)
      const processed = await processImage(image)
      await context.storage.disk().put(payload.path, processed)
    } catch (error) {
      context.logger.error('Image processing failed', {
        error,
        url: payload.url
      })

      // Re-throw to trigger retry
      throw error
    }
  },
  options: {
    retryLimit: 3,
    retryDelay: 60,
    retryBackoff: true,
  },
})
```

### 4. Use Appropriate Team Sizes

```typescript
const cms = new QCMS({
  queue: {
    jobs,
    options: {
      // Adjust based on your workload
      teamSize: 10, // Good for mixed workloads
    },
  },
})

// Or per worker
await cms._listenToJobs({
  teamSize: 50 // High concurrency for light jobs
})
```

## Next Steps

- [Job Definitions](/docs/features/queue/jobs) - Learn about job schemas and handlers
- [Workflows](/docs/features/queue/workflows) - Build multi-step job pipelines
- [Worker Setup](/docs/features/queue/workers) - Deploy and scale workers
- [API Reference](/docs/features/queue/api) - Complete API documentation
