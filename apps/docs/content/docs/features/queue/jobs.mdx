---
title: Job Definitions
description: Define typesafe background jobs with Zod schemas and handlers.
icon: FileCode
---

# Job Definitions

Jobs are the core building blocks of the queue system. Each job defines a schema for its payload, a handler function to execute, and optional configuration for retries and execution.

## Defining a Job

Use `defineJob()` to create a typesafe job definition:

```typescript
import { defineJob } from '@questpie/core/server'
import { z } from 'zod'

export const sendEmailJob = defineJob({
  name: 'send-email',
  schema: z.object({
    to: z.string().email(),
    subject: z.string(),
    body: z.string(),
  }),
  handler: async (payload, context) => {
    await context.email.send({
      to: payload.to,
      subject: payload.subject,
      html: payload.body,
    })
  },
})
```

## Job Structure

A job definition consists of three required parts and optional configuration:

### 1. Name

A unique identifier for the job:

```typescript
{
  name: 'send-email', // Must be unique across all jobs
}
```

The name is used internally by pg-boss to track jobs and should not change once jobs are in production.

### 2. Schema

A Zod schema that defines and validates the job payload:

```typescript
import { z } from 'zod'

{
  schema: z.object({
    to: z.string().email(),
    subject: z.string().min(1),
    body: z.string(),
    attachments: z.array(z.object({
      filename: z.string(),
      url: z.string().url(),
    })).optional(),
  }),
}
```

The schema provides:
- **Runtime validation** - Payloads are validated when jobs are published
- **Type inference** - TypeScript infers the payload type automatically
- **Documentation** - Schema serves as documentation for the job

### 3. Handler

The async function that executes when the job runs:

```typescript
{
  handler: async (payload, context) => {
    // payload is fully typed based on your schema
    // context provides access to all CMS services

    await context.email.send({
      to: payload.to,
      subject: payload.subject,
      html: payload.body,
    })

    context.logger.info(`Email sent to ${payload.to}`)
  },
}
```

The handler receives two parameters:
- **payload** - Validated job data (typed from your schema)
- **context** - Full CMS context with db, auth, storage, email, etc.

### 4. Options (Optional)

Configure retry behavior and job execution:

```typescript
{
  options: {
    retryLimit: 3,           // Number of retry attempts
    retryDelay: 60,          // Delay between retries (seconds)
    retryBackoff: true,      // Use exponential backoff
    expireInSeconds: 3600,   // Job expires if not completed in 1 hour
    priority: 5,             // Default priority (higher = more important)
  },
}
```

## Complete Example

```typescript
import { defineJob } from '@questpie/core/server'
import { z } from 'zod'

export const processImageJob = defineJob({
  name: 'process-image',

  schema: z.object({
    imageId: z.string().uuid(),
    url: z.string().url(),
    sizes: z.array(z.number()),
    quality: z.number().min(1).max(100).default(80),
  }),

  handler: async (payload, context) => {
    const { imageId, url, sizes, quality } = payload

    context.logger.info(`Processing image ${imageId}`)

    // Download image
    const response = await fetch(url)
    const imageBuffer = await response.arrayBuffer()

    // Process each size
    for (const size of sizes) {
      const resized = await resizeImage(imageBuffer, size, quality)

      // Upload to storage
      const path = `images/${imageId}/${size}.jpg`
      await context.storage.disk().put(path, resized)

      context.logger.info(`Created ${size}px version`)
    }

    // Update database
    await context.db
      .update(images)
      .set({ processed: true })
      .where(eq(images.id, imageId))

    context.logger.info(`Image ${imageId} processed successfully`)
  },

  options: {
    retryLimit: 3,
    retryDelay: 60,
    retryBackoff: true,
    expireInSeconds: 600, // 10 minutes max
  },
})
```

## Registering Jobs

Pass jobs as an array directly to the CMS config:

```typescript
import { QCMS } from '@questpie/core/server'
import { sendEmailJob } from './email'
import { processImageJob } from './images'
import { generateReportJob } from './reports'

const cms = new QCMS({
  // ... other config
  queue: {
    jobs: [sendEmailJob, processImageJob, generateReportJob]
  }
})
```

Jobs are then accessible by their name:
- **Name-based access** - `context.queue['send-email'].publish()`
- **Type safety** - Full autocomplete and type checking based on job name
- **Simple structure** - Just an array, like collections

## Job Organization

For larger applications, organize jobs by domain:

```
jobs/
├── index.ts           # Export all jobs
├── email/
│   ├── send.ts
│   ├── bulk.ts
│   └── digest.ts
├── images/
│   ├── process.ts
│   ├── optimize.ts
│   └── watermark.ts
└── reports/
    ├── generate.ts
    └── export.ts
```

```typescript
// jobs/index.ts
import * as emailJobs from './email'
import * as imageJobs from './images'
import * as reportJobs from './reports'

export const allJobs = [
  // Email jobs
  emailJobs.sendEmailJob,
  emailJobs.bulkEmailJob,
  emailJobs.digestEmailJob,

  // Image jobs
  imageJobs.processImageJob,
  imageJobs.optimizeImageJob,
  imageJobs.watermarkImageJob,

  // Report jobs
  reportJobs.generateReportJob,
  reportJobs.exportReportJob,
]

// Use in CMS config
const cms = new QCMS({
  queue: { jobs: allJobs }
})
```

## Advanced Schemas

### Nested Objects

```typescript
schema: z.object({
  user: z.object({
    id: z.string(),
    email: z.string().email(),
    name: z.string(),
  }),
  order: z.object({
    id: z.string(),
    items: z.array(z.object({
      productId: z.string(),
      quantity: z.number(),
    })),
    total: z.number(),
  }),
})
```

### Discriminated Unions

```typescript
schema: z.discriminatedUnion('type', [
  z.object({
    type: z.literal('email'),
    to: z.string().email(),
    subject: z.string(),
  }),
  z.object({
    type: z.literal('sms'),
    phone: z.string(),
    message: z.string(),
  }),
])
```

### Transformations

```typescript
schema: z.object({
  date: z.string().transform((str) => new Date(str)),
  amount: z.string().transform((str) => parseFloat(str)),
})
```

## Error Handling

Handle errors appropriately in your job handlers:

```typescript
handler: async (payload, context) => {
  try {
    // Your job logic
    await doSomething(payload)
  } catch (error) {
    // Log the error
    context.logger.error('Job failed', {
      error,
      payload,
      jobName: 'my-job',
    })

    // Decide: retry or fail permanently
    if (error instanceof TemporaryError) {
      // Re-throw to trigger retry
      throw error
    } else {
      // Log and don't retry
      context.logger.error('Permanent failure, not retrying')
      // Don't throw - job completes with logged error
    }
  }
}
```

## Best Practices

### 1. Use Descriptive Names

```typescript
// ❌ Bad
defineJob({ name: 'job1', ... })

// ✅ Good
defineJob({ name: 'send-welcome-email', ... })
```

### 2. Validate Thoroughly

```typescript
// ✅ Good - strict validation
schema: z.object({
  email: z.string().email(),
  age: z.number().int().min(0).max(120),
  url: z.string().url(),
  userId: z.string().uuid(),
})
```

### 3. Keep Handlers Focused

```typescript
// ❌ Bad - doing too much
handler: async (payload, context) => {
  await sendEmail(payload)
  await updateDatabase(payload)
  await callExternalAPI(payload)
  await generateReport(payload)
}

// ✅ Good - focused on one task
handler: async (payload, context) => {
  await sendEmail(payload)

  // Queue other jobs
  await context.queue['update-database'].publish(payload)
  await context.queue['call-external-api'].publish(payload)
}
```

### 4. Use Appropriate Retry Settings

```typescript
// For critical operations
options: {
  retryLimit: 5,
  retryDelay: 120,
  retryBackoff: true,
}

// For nice-to-have operations
options: {
  retryLimit: 1,
  retryDelay: 30,
}

// For idempotent operations
options: {
  retryLimit: 10,
  retryBackoff: true,
}
```

## Next Steps

- [Workflows](/docs/features/queue/workflows) - Chain multiple jobs together
- [Workers](/docs/features/queue/workers) - Deploy and configure job workers
- [API Reference](/docs/features/queue/api) - Complete API documentation
