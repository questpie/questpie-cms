---
title: Workflows
description: Chain multiple job steps together for complex multi-stage operations.
icon: GitBranch
---

# Workflows

Workflows allow you to chain multiple steps together into a single job, creating complex multi-stage operations with built-in error handling and type safety.

## Basic Workflow

Create a workflow using the `workflow()` builder:

```typescript
import { workflow } from '@questpie/core/server'
import { z } from 'zod'

const processOrderWorkflow = workflow('process-order')
  .step('validate', async (order, context) => {
    // Validate order
    const valid = await validateOrder(order)
    if (!valid) {
      throw new Error('Order validation failed')
    }
    return { ...order, validated: true }
  })
  .step('charge', async (order, context) => {
    // Charge payment
    const payment = await chargeCustomer(order)
    return { ...order, payment }
  })
  .step('fulfill', async (order, context) => {
    // Send to warehouse
    await sendToWarehouse(order)
    return { ...order, fulfilled: true }
  })
  .build(z.object({
    orderId: z.string(),
    customerId: z.string(),
    items: z.array(z.object({
      productId: z.string(),
      quantity: z.number(),
    })),
  }))
```

Register it in your job registry:

```typescript
export const jobs = defineJobs({
  processOrder: processOrderWorkflow,
  // ... other jobs
})
```

## Workflow Steps

Each step in a workflow:

1. **Receives output from previous step** (or initial payload for first step)
2. **Executes its logic**
3. **Returns output for next step**
4. **Has access to full CMS context**

### Step Signature

```typescript
.step('stepName', async (input, context) => {
  // input: Output from previous step (typed!)
  // context: Full CMS context

  // Do work...
  const result = await doSomething(input)

  // Return output for next step
  return { ...input, result }
})
```

### Type Inference

TypeScript automatically infers types through the workflow:

```typescript
const workflow = workflow('example')
  .step('first', async (input: { value: number }, ctx) => {
    return { value: input.value * 2, doubled: true }
  })
  .step('second', async (input, ctx) => {
    // input is typed as { value: number, doubled: boolean }
    return { ...input, tripled: input.value * 3 }
  })
  .step('third', async (input, ctx) => {
    // input is typed as { value: number, doubled: boolean, tripled: number }
    return input
  })
```

## Complete Example

Here's a comprehensive workflow for processing uploaded images:

```typescript
import { workflow } from '@questpie/core/server'
import { z } from 'zod'

const processUploadedImageWorkflow = workflow('process-uploaded-image')
  // Step 1: Validate image
  .step('validate', async (input, context) => {
    context.logger.info('Validating image', { url: input.url })

    const response = await fetch(input.url)
    if (!response.ok) {
      throw new Error('Failed to fetch image')
    }

    const buffer = await response.arrayBuffer()
    const metadata = await getImageMetadata(buffer)

    if (metadata.width > 10000 || metadata.height > 10000) {
      throw new Error('Image too large')
    }

    return {
      ...input,
      buffer,
      metadata,
      validated: true,
    }
  })

  // Step 2: Resize to multiple sizes
  .step('resize', async (input, context) => {
    context.logger.info('Resizing image', { sizes: input.sizes })

    const resized: Record<number, Buffer> = {}

    for (const size of input.sizes) {
      resized[size] = await resizeImage(input.buffer, size)
    }

    return {
      ...input,
      resized,
    }
  })

  // Step 3: Optimize images
  .step('optimize', async (input, context) => {
    context.logger.info('Optimizing images')

    const optimized: Record<number, Buffer> = {}

    for (const [size, buffer] of Object.entries(input.resized)) {
      optimized[size] = await optimizeImage(buffer)
    }

    return {
      ...input,
      optimized,
    }
  })

  // Step 4: Upload to storage
  .step('upload', async (input, context) => {
    context.logger.info('Uploading to storage')

    const disk = context.storage.disk()
    const urls: Record<number, string> = {}

    for (const [size, buffer] of Object.entries(input.optimized)) {
      const path = `images/${input.imageId}/${size}.jpg`
      await disk.put(path, buffer)
      urls[size] = await disk.getUrl(path)
    }

    return {
      ...input,
      urls,
    }
  })

  // Step 5: Update database
  .step('save', async (input, context) => {
    context.logger.info('Saving to database')

    await context.db
      .update(images)
      .set({
        processed: true,
        urls: input.urls,
      })
      .where(eq(images.id, input.imageId))

    return input
  })

  // Build with schema
  .build(z.object({
    imageId: z.string().uuid(),
    url: z.string().url(),
    sizes: z.array(z.number()),
  }))

// Register the workflow
export const jobs = defineJobs({
  processUploadedImage: processUploadedImageWorkflow,
})
```

Usage:

```typescript
await context.queue.processUploadedImage.publish({
  imageId: '123e4567-e89b-12d3-a456-426614174000',
  url: 'https://example.com/upload.jpg',
  sizes: [100, 200, 400, 800],
})
```

## Error Handling

If any step fails, the entire workflow fails:

```typescript
const workflow = workflow('example')
  .step('step1', async (input, context) => {
    // This succeeds
    return { ...input, step1Done: true }
  })
  .step('step2', async (input, context) => {
    // This fails
    throw new Error('Step 2 failed!')
  })
  .step('step3', async (input, context) => {
    // This never executes
    return input
  })
```

The workflow will retry according to its job options:

```typescript
const jobs = defineJobs({
  myWorkflow: workflow('my-workflow')
    .step('step1', ...)
    .step('step2', ...)
    .build(schema),
})

// Configure retry behavior when publishing
await context.queue.myWorkflow.publish(payload, {
  retryLimit: 3,
  retryDelay: 60,
  retryBackoff: true,
})
```

### Step-Level Error Handling

Handle errors within individual steps:

```typescript
.step('risky-operation', async (input, context) => {
  try {
    const result = await riskyOperation(input)
    return { ...input, result }
  } catch (error) {
    context.logger.error('Risky operation failed', { error })

    // Option 1: Re-throw to fail the workflow
    throw error

    // Option 2: Continue with fallback
    return { ...input, result: null, fallback: true }
  }
})
```

## Parallel Execution

For independent operations, use the `parallel()` helper:

```typescript
import { parallel, workflow } from '@questpie/core/server'

const workflow = workflow('process-order')
  .step('validate', async (order, context) => {
    // Validate order
    return { ...order, validated: true }
  })
  .step('parallel-operations', async (order, context) => {
    // Run multiple operations in parallel
    const [
      inventoryUpdate,
      customerNotification,
      analyticsEvent,
    ] = await parallel([
      updateInventory(order),
      notifyCustomer(order),
      trackAnalytics(order),
    ])

    return {
      ...order,
      inventoryUpdate,
      customerNotification,
      analyticsEvent,
    }
  })
  .step('finalize', async (order, context) => {
    // Finalize order
    return order
  })
  .build(orderSchema)
```

## Sequential Job Triggering

For operations that should be separate jobs, trigger them sequentially:

```typescript
import { sequential, workflow } from '@questpie/core/server'

const workflow = workflow('onboard-user')
  .step('create-account', async (input, context) => {
    const user = await createUser(input)
    return { ...input, userId: user.id }
  })
  .step('trigger-jobs', async (input, context) => {
    // Trigger multiple jobs in sequence
    await sequential([
      () => context.queue.sendWelcomeEmail.publish({ userId: input.userId }),
      () => context.queue.setupUserProfile.publish({ userId: input.userId }),
      () => context.queue.sendToAnalytics.publish({ userId: input.userId }),
    ])

    return input
  })
  .build(userSchema)
```

## Conditional Steps

Use conditional logic within steps:

```typescript
const workflow = workflow('process-payment')
  .step('validate', async (payment, context) => {
    return { ...payment, validated: true }
  })
  .step('charge', async (payment, context) => {
    if (payment.amount === 0) {
      // Skip charging for free orders
      return { ...payment, charged: true, free: true }
    }

    const result = await chargeCard(payment)
    return { ...payment, ...result, charged: true }
  })
  .step('notify', async (payment, context) => {
    const template = payment.free
      ? 'free-order-confirmation'
      : 'paid-order-confirmation'

    await context.queue.sendEmail.publish({
      to: payment.customerEmail,
      template,
      data: payment,
    })

    return payment
  })
  .build(paymentSchema)
```

## Best Practices

### 1. Keep Steps Focused

```typescript
// ❌ Bad - step doing too much
.step('process', async (input, context) => {
  await validate(input)
  await transform(input)
  await upload(input)
  await notify(input)
  return input
})

// ✅ Good - focused steps
.step('validate', async (input, context) => { ... })
.step('transform', async (input, context) => { ... })
.step('upload', async (input, context) => { ... })
.step('notify', async (input, context) => { ... })
```

### 2. Log Progress

```typescript
.step('stepName', async (input, context) => {
  context.logger.info('Starting step: stepName', { inputId: input.id })

  const result = await doWork(input)

  context.logger.info('Completed step: stepName', {
    inputId: input.id,
    result,
  })

  return { ...input, result }
})
```

### 3. Use Type-Safe Accumulation

```typescript
interface OrderState {
  orderId: string
  validated?: boolean
  charged?: boolean
  payment?: Payment
  fulfilled?: boolean
}

const workflow = workflow<OrderState>('process-order')
  .step('validate', async (order, ctx) => {
    return { ...order, validated: true }
  })
  .step('charge', async (order, ctx) => {
    const payment = await charge(order)
    return { ...order, charged: true, payment }
  })
  .step('fulfill', async (order, ctx) => {
    return { ...order, fulfilled: true }
  })
```

### 4. Consider Idempotency

```typescript
.step('charge-payment', async (order, context) => {
  // Check if already charged
  if (order.payment?.charged) {
    context.logger.info('Payment already charged, skipping')
    return order
  }

  const payment = await chargeCustomer(order)
  return { ...order, payment: { ...payment, charged: true } }
})
```

## When to Use Workflows

Use workflows when:
- ✅ Steps must execute in order
- ✅ Steps share intermediate state
- ✅ Entire operation should succeed or fail together
- ✅ You want simple error handling (all-or-nothing)

Use separate jobs when:
- ✅ Operations are independent
- ✅ Different retry strategies needed
- ✅ Some failures are acceptable
- ✅ Operations happen at different times

## Next Steps

- [Workers](/docs/features/queue/workers) - Deploy and configure job workers
- [API Reference](/docs/features/queue/api) - Complete API documentation
- [Job Definitions](/docs/features/queue/jobs) - Learn about job schemas
