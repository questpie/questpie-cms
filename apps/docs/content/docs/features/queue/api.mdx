---
title: API Reference
description: Complete API reference for the QUESTPIE queue system.
icon: BookOpen
---

# Queue API Reference

Complete reference for all queue-related APIs, types, and functions.

## Job Definition

### `defineJob()`

Define a typesafe job with schema, handler, and options.

```typescript
function defineJob<TPayload, TResult = void>(
  definition: JobDefinition<TPayload, TResult>
): JobDefinition<TPayload, TResult>
```

**Parameters:**
- `definition.name` - Unique job name (string)
- `definition.schema` - Zod schema for payload validation
- `definition.handler` - Async function to execute the job
- `definition.options` - Optional execution configuration

**Returns:** JobDefinition instance

**Example:**
```typescript
const sendEmailJob = defineJob({
  name: 'send-email',
  schema: z.object({
    to: z.string().email(),
    subject: z.string(),
  }),
  handler: async (payload, context) => {
    await context.email.send(payload)
  },
  options: {
    retryLimit: 3,
    retryDelay: 60,
  },
})
```

### `defineJobs()`

Create a job registry from multiple job definitions.

```typescript
function defineJobs<TJobs extends Record<string, JobDefinition>>(
  jobs: TJobs
): TJobs
```

**Parameters:**
- `jobs` - Object mapping job keys to JobDefinition instances

**Returns:** Job registry object

**Example:**
```typescript
const jobs = defineJobs({
  sendEmail: sendEmailJob,
  processImage: processImageJob,
})
```

## Workflow

### `workflow()`

Create a workflow builder for multi-step jobs.

```typescript
function workflow<TInput>(name: string): WorkflowBuilder<TInput, TInput>
```

**Parameters:**
- `name` - Unique workflow name

**Returns:** WorkflowBuilder instance

**Example:**
```typescript
const processOrderWorkflow = workflow('process-order')
  .step('validate', async (order, ctx) => ({ ...order, valid: true }))
  .step('charge', async (order, ctx) => ({ ...order, charged: true }))
  .build(orderSchema)
```

### WorkflowBuilder Methods

#### `.step()`

Add a step to the workflow.

```typescript
step<TStepOutput>(
  name: string,
  execute: (input: TCurrentOutput, context: CmsContext) => Promise<TStepOutput>
): WorkflowBuilder<TInput, TStepOutput>
```

**Parameters:**
- `name` - Step name for logging
- `execute` - Async function for this step

**Returns:** New WorkflowBuilder with updated output type

#### `.build()`

Build the workflow into a JobDefinition.

```typescript
build(schema: z.ZodSchema<TInput>): JobDefinition<TInput, TCurrentOutput>
```

**Parameters:**
- `schema` - Zod schema for initial workflow input

**Returns:** JobDefinition that can be registered

## Queue Client

The queue client is automatically typed based on your job registry and available via `context.queue`.

### Job Methods

Each job in your registry exposes these methods:

#### `.publish()`

Publish a job to the queue.

```typescript
publish(
  payload: TPayload,
  options?: PublishOptions
): Promise<string | null>
```

**Parameters:**
- `payload` - Job payload (validated against schema)
- `options` - Optional publish configuration

**Returns:** Job ID or null

**Example:**
```typescript
const jobId = await context.queue.sendEmail.publish({
  to: 'user@example.com',
  subject: 'Welcome',
  body: 'Hello!',
})
```

#### `.schedule()`

Schedule a recurring job with cron.

```typescript
schedule(
  payload: TPayload,
  cron: string,
  options?: Omit<PublishOptions, 'startAfter'>
): Promise<void>
```

**Parameters:**
- `payload` - Job payload
- `cron` - Cron expression
- `options` - Optional configuration

**Example:**
```typescript
await context.queue.sendEmail.schedule(
  { to: 'admin@example.com', subject: 'Daily Report', body: '...' },
  '0 9 * * *' // Every day at 9 AM
)
```

#### `.unschedule()`

Cancel scheduled recurring jobs.

```typescript
unschedule(): Promise<void>
```

**Example:**
```typescript
await context.queue.sendEmail.unschedule()
```

## Publish Options

### `PublishOptions`

Configuration for job publishing.

```typescript
interface PublishOptions {
  priority?: number
  startAfter?: number | string | Date
  singletonKey?: string
  retryLimit?: number
  retryDelay?: number
  retryBackoff?: boolean
  expireInSeconds?: number
}
```

**Properties:**

- **`priority`** - Job priority (higher = more important)
  ```typescript
  { priority: 10 }
  ```

- **`startAfter`** - Delay before execution
  ```typescript
  { startAfter: 300 } // 300 seconds
  { startAfter: new Date('2024-12-25T00:00:00Z') }
  ```

- **`singletonKey`** - Unique key for singleton jobs
  ```typescript
  { singletonKey: `user-${userId}` }
  ```

- **`retryLimit`** - Number of retry attempts
  ```typescript
  { retryLimit: 5 }
  ```

- **`retryDelay`** - Delay between retries (seconds)
  ```typescript
  { retryDelay: 120 }
  ```

- **`retryBackoff`** - Use exponential backoff
  ```typescript
  { retryBackoff: true }
  ```

- **`expireInSeconds`** - Job expiration time
  ```typescript
  { expireInSeconds: 3600 } // 1 hour
  ```

## Job Options

### `JobDefinition.options`

Default options for a job definition.

```typescript
interface JobOptions {
  priority?: number
  retryLimit?: number
  retryDelay?: number
  retryBackoff?: boolean
  expireInSeconds?: number
  startAfter?: number | string | Date
  cron?: string
}
```

Same as PublishOptions, but applied at the job definition level.

## Worker API

### `cms._listenToJobs()`

Start processing jobs in worker mode.

```typescript
_listenToJobs(
  jobNamesOrOptions?: string[] | WorkerOptions,
  options?: WorkerOptions
): Promise<void>
```

**Parameters:**
- `jobNamesOrOptions` - Array of job names to listen to, or WorkerOptions
- `options` - WorkerOptions if first param is job names array

**Example:**
```typescript
// Listen to all jobs
await cms._listenToJobs()

// Listen to all with options
await cms._listenToJobs({ teamSize: 20 })

// Listen to specific jobs
await cms._listenToJobs(['sendEmail', 'processImage'])

// Listen to specific with options
await cms._listenToJobs(['sendEmail'], { teamSize: 50 })
```

### `WorkerOptions`

Configuration for job workers.

```typescript
interface WorkerOptions {
  teamSize?: number
  batchSize?: number
  includeMetadata?: boolean
}
```

**Properties:**

- **`teamSize`** - Max concurrent jobs per worker
  ```typescript
  { teamSize: 20 }
  ```

- **`batchSize`** - Number of jobs to fetch at once
  ```typescript
  { batchSize: 10 }
  ```

- **`includeMetadata`** - Include job metadata in handler
  ```typescript
  { includeMetadata: true }
  ```

## Queue Configuration

### `QueueConfig`

Queue configuration for QCMS.

```typescript
interface QueueConfig<TJobs extends JobRegistry> {
  jobs: TJobs
  options?: {
    schema?: string
    archiveCompletedAfterSeconds?: number
    maintenanceIntervalSeconds?: number
    teamSize?: number
    newJobCheckInterval?: number
    newJobCheckIntervalSeconds?: number
  }
}
```

**Properties:**

- **`jobs`** - Job registry from defineJobs()
  ```typescript
  { jobs: defineJobs({ ... }) }
  ```

- **`options.schema`** - PostgreSQL schema for queue tables (default: 'pgboss')
  ```typescript
  { options: { schema: 'myqueue' } }
  ```

- **`options.archiveCompletedAfterSeconds`** - Archive completed jobs
  ```typescript
  { options: { archiveCompletedAfterSeconds: 86400 } } // 24 hours
  ```

- **`options.maintenanceIntervalSeconds`** - Maintenance interval
  ```typescript
  { options: { maintenanceIntervalSeconds: 120 } } // 2 minutes
  ```

- **`options.teamSize`** - Default team size for workers
  ```typescript
  { options: { teamSize: 10 } }
  ```

## Helper Functions

### `parallel()`

Execute multiple promises in parallel.

```typescript
function parallel<T>(jobs: Promise<T>[]): Promise<Awaited<T>[]>
```

**Example:**
```typescript
import { parallel } from '@questpie/core/server'

const results = await parallel([
  doTask1(),
  doTask2(),
  doTask3(),
])
```

### `sequential()`

Execute promises sequentially.

```typescript
function sequential<T>(jobs: (() => Promise<T>)[]): Promise<Awaited<T>[]>
```

**Example:**
```typescript
import { sequential } from '@questpie/core/server'

const results = await sequential([
  () => doTask1(),
  () => doTask2(),
  () => doTask3(),
])
```

## Context

Jobs and workflows receive a `CmsContext` object:

```typescript
interface CmsContext {
  db: DrizzleClient
  qcms: QCMS
  queue: QueueClient<TJobs>
  storage: StorageManager
  email: MailerService
  auth: AuthService
  kv: KVService
  logger: LoggerService
  user?: User
  session?: Session
  locale: string
  defaultLocale: string
}
```

**Properties:**
- `db` - Drizzle database client
- `qcms` - QCMS instance
- `queue` - Typesafe queue client
- `storage` - File storage manager
- `email` - Email service
- `auth` - Authentication service
- `kv` - Key-value store
- `logger` - Structured logger
- `user` - Current user (if authenticated)
- `session` - Current session
- `locale` - Current locale
- `defaultLocale` - Default locale

## PgBoss API

Access the underlying pg-boss instance:

```typescript
const boss = context.queue._boss

// Get queue size
const size = await boss.getQueueSize('job-name')

// Fetch failed jobs
const failed = await boss.fetchFailed('job-name', 10)

// Clear completed jobs
await boss.clearStorage()

// Monitor states
boss.on('monitor-states', (states) => {
  console.log(states)
})
```

For complete pg-boss API, see [pg-boss documentation](https://github.com/timgit/pg-boss).

## Type Utilities

### `InferJobPayload<T>`

Extract payload type from a job definition.

```typescript
type InferJobPayload<T> = T extends JobDefinition<infer P, any> ? P : never
```

**Example:**
```typescript
type EmailPayload = InferJobPayload<typeof sendEmailJob>
// { to: string; subject: string; body: string }
```

### `InferJobResult<T>`

Extract result type from a job definition.

```typescript
type InferJobResult<T> = T extends JobDefinition<any, infer R> ? R : never
```

**Example:**
```typescript
type ProcessResult = InferJobResult<typeof processImageJob>
```

## Next Steps

- [Queue Overview](/docs/features/queue) - Introduction to the queue system
- [Job Definitions](/docs/features/queue/jobs) - Define typesafe jobs
- [Workflows](/docs/features/queue/workflows) - Build multi-step pipelines
- [Workers](/docs/features/queue/workers) - Deploy and configure workers
