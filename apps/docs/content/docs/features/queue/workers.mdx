---
title: Workers
description: Deploy and configure job workers to process background jobs.
icon: Server
---

# Workers

Workers are processes that listen for jobs in the queue and execute them. QUESTPIE makes it easy to set up and deploy workers with the `_listenToJobs()` method.

## Basic Worker Setup

Create a separate worker file (e.g., `worker.ts`):

```typescript
import { QCMS } from '@questpie/core/server'
import { jobs } from './jobs'

const cms = new QCMS({
  db: {
    connection: {
      hostname: process.env.DB_HOST,
      port: parseInt(process.env.DB_PORT || '5432'),
      database: process.env.DB_NAME,
      user: process.env.DB_USER,
      password: process.env.DB_PASSWORD,
    },
  },
  queue: {
    jobs,
  },
  // ... other config (should match your main app)
})

// Start listening to all jobs
await cms._listenToJobs()

console.log('✅ Worker started and listening for jobs')
```

Run the worker:

```bash
bun run worker.ts
```

## Worker Configuration

### Team Size

Control how many jobs run concurrently:

```typescript
// Process up to 20 jobs at the same time
await cms._listenToJobs({ teamSize: 20 })
```

Higher team sizes = more concurrency, but also more resource usage.

**Guidelines:**
- Light jobs (sending emails): 20-50
- Medium jobs (image processing): 10-20
- Heavy jobs (video encoding): 1-5

### Listening to Specific Jobs

Run different workers for different job types:

```typescript
// Email worker - high concurrency
await cms._listenToJobs(['sendEmail', 'sendBulkEmail'], {
  teamSize: 50,
})

// Image worker - medium concurrency
await cms._listenToJobs(['processImage', 'optimizeImage'], {
  teamSize: 10,
})

// Video worker - low concurrency
await cms._listenToJobs(['encodeVideo'], {
  teamSize: 2,
})
```

## Production Deployment

### Environment Variables

```bash
# .env.worker
DB_HOST=localhost
DB_PORT=5432
DB_NAME=myapp
DB_USER=postgres
DB_PASSWORD=secret

# Queue configuration
QUEUE_SCHEMA=pgboss
QUEUE_TEAM_SIZE=10

# Logging
LOG_LEVEL=info
NODE_ENV=production
```

```typescript
// worker.ts
import { QCMS } from '@questpie/core/server'
import { jobs } from './jobs'

const cms = new QCMS({
  db: {
    connection: {
      hostname: process.env.DB_HOST!,
      port: parseInt(process.env.DB_PORT || '5432'),
      database: process.env.DB_NAME!,
      user: process.env.DB_USER!,
      password: process.env.DB_PASSWORD!,
    },
  },
  queue: {
    jobs,
    options: {
      schema: process.env.QUEUE_SCHEMA || 'pgboss',
    },
  },
})

const teamSize = parseInt(process.env.QUEUE_TEAM_SIZE || '10')
await cms._listenToJobs({ teamSize })

console.log(`Worker started with team size: ${teamSize}`)
```

### Process Manager

Use a process manager to keep workers running:

#### PM2

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'worker-all',
      script: 'worker.ts',
      interpreter: 'bun',
      instances: 2,
      env: {
        NODE_ENV: 'production',
        QUEUE_TEAM_SIZE: 10,
      },
    },
    {
      name: 'worker-email',
      script: 'worker-email.ts',
      interpreter: 'bun',
      instances: 1,
      env: {
        NODE_ENV: 'production',
        QUEUE_TEAM_SIZE: 50,
      },
    },
  ],
}
```

```bash
pm2 start ecosystem.config.js
pm2 save
pm2 startup
```

#### Systemd

```ini
# /etc/systemd/system/questpie-worker.service
[Unit]
Description=QUESTPIE Worker
After=network.target postgresql.service

[Service]
Type=simple
User=app
WorkingDirectory=/app
ExecStart=/usr/bin/bun run worker.ts
Restart=always
RestartSec=10
Environment=NODE_ENV=production
EnvironmentFile=/app/.env.worker

[Install]
WantedBy=multi-user.target
```

```bash
sudo systemctl enable questpie-worker
sudo systemctl start questpie-worker
sudo systemctl status questpie-worker
```

### Docker

```dockerfile
# Dockerfile.worker
FROM oven/bun:1

WORKDIR /app

COPY package.json bun.lock ./
RUN bun install --frozen-lockfile --production

COPY . .

CMD ["bun", "run", "worker.ts"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: myapp
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: secret
    volumes:
      - postgres-data:/var/lib/postgresql/data

  app:
    build: .
    ports:
      - "3000:3000"
    depends_on:
      - db
    environment:
      DB_HOST: db
      DB_NAME: myapp
      DB_USER: postgres
      DB_PASSWORD: secret

  worker:
    build:
      context: .
      dockerfile: Dockerfile.worker
    depends_on:
      - db
    environment:
      DB_HOST: db
      DB_NAME: myapp
      DB_USER: postgres
      DB_PASSWORD: secret
      QUEUE_TEAM_SIZE: 10
    deploy:
      replicas: 2

volumes:
  postgres-data:
```

```bash
docker-compose up -d
docker-compose logs -f worker
```

## Scaling Workers

### Horizontal Scaling

Run multiple worker instances to handle more load:

```bash
# Run 3 worker instances
pm2 start worker.ts -i 3

# Or with docker-compose
docker-compose up -d --scale worker=3
```

pg-boss automatically distributes jobs across workers.

### Vertical Scaling

Increase team size for more concurrency per worker:

```typescript
// Before: 1 worker with teamSize 10 = 10 concurrent jobs
await cms._listenToJobs({ teamSize: 10 })

// After: 1 worker with teamSize 50 = 50 concurrent jobs
await cms._listenToJobs({ teamSize: 50 })
```

### Specialized Workers

Run different workers for different job types:

```typescript
// worker-email.ts - High concurrency for emails
const cms = new QCMS({ /* config */ })
await cms._listenToJobs(['sendEmail', 'sendBulkEmail'], {
  teamSize: 50,
})

// worker-images.ts - Medium concurrency for images
const cms = new QCMS({ /* config */ })
await cms._listenToJobs(['processImage', 'optimizeImage'], {
  teamSize: 15,
})

// worker-heavy.ts - Low concurrency for heavy jobs
const cms = new QCMS({ /* config */ })
await cms._listenToJobs(['encodeVideo', 'generateReport'], {
  teamSize: 3,
})
```

## Monitoring

### Worker Logs

```typescript
import { QCMS } from '@questpie/core/server'
import { jobs } from './jobs'

const cms = new QCMS({
  // ... config
})

// Listen for pg-boss events
cms.queue._boss.on('error', (error) => {
  console.error('Queue error:', error)
})

cms.queue._boss.on('monitor-states', (states) => {
  console.log('Queue states:', {
    active: states.active,
    created: states.created,
    completed: states.completed,
    failed: states.failed,
  })
})

await cms._listenToJobs()

console.log('Worker started')
```

### Health Checks

```typescript
// health-check.ts
import { QCMS } from '@questpie/core/server'

const cms = new QCMS({ /* config */ })

// Check if queue is healthy
try {
  await cms.queue._start()
  const health = await cms.queue._boss.getQueueSize('send-email')
  console.log('Queue size:', health)
  process.exit(0)
} catch (error) {
  console.error('Health check failed:', error)
  process.exit(1)
}
```

Add to docker-compose:

```yaml
worker:
  # ...
  healthcheck:
    test: ["CMD", "bun", "run", "health-check.ts"]
    interval: 30s
    timeout: 10s
    retries: 3
```

### Metrics

Track worker performance:

```typescript
let jobsProcessed = 0
let jobsFailed = 0

cms.queue._boss.on('job-complete', () => {
  jobsProcessed++
})

cms.queue._boss.on('job-failed', () => {
  jobsFailed++
})

// Report metrics every minute
setInterval(() => {
  console.log('Metrics:', {
    processed: jobsProcessed,
    failed: jobsFailed,
    successRate: (jobsProcessed / (jobsProcessed + jobsFailed)) * 100,
  })

  // Send to your metrics service
  // reportMetrics({ processed: jobsProcessed, failed: jobsFailed })

  // Reset counters
  jobsProcessed = 0
  jobsFailed = 0
}, 60000)
```

## Graceful Shutdown

Handle shutdown signals properly:

```typescript
import { QCMS } from '@questpie/core/server'
import { jobs } from './jobs'

const cms = new QCMS({ /* config */ })

await cms._listenToJobs()

console.log('Worker started')

// Graceful shutdown
const shutdown = async (signal: string) => {
  console.log(`Received ${signal}, shutting down gracefully...`)

  try {
    // Stop accepting new jobs
    await cms.queue._stop()
    console.log('Queue stopped')

    // Give running jobs time to complete
    await new Promise(resolve => setTimeout(resolve, 5000))

    console.log('Shutdown complete')
    process.exit(0)
  } catch (error) {
    console.error('Error during shutdown:', error)
    process.exit(1)
  }
}

process.on('SIGTERM', () => shutdown('SIGTERM'))
process.on('SIGINT', () => shutdown('SIGINT'))
```

## Best Practices

### 1. Separate Workers from Web Server

```
project/
├── src/
│   ├── index.ts          # Web server
│   ├── worker.ts         # Job worker
│   └── jobs/             # Job definitions
└── package.json
```

Run separately:
```bash
# Terminal 1: Web server
bun run src/index.ts

# Terminal 2: Worker
bun run src/worker.ts
```

### 2. Configure Based on Job Type

```typescript
// Fast, light jobs
await cms._listenToJobs(['sendEmail'], { teamSize: 50 })

// Slow, heavy jobs
await cms._listenToJobs(['encodeVideo'], { teamSize: 2 })
```

### 3. Monitor Queue Depth

```typescript
setInterval(async () => {
  const size = await cms.queue._boss.getQueueSize()
  if (size > 1000) {
    console.warn('Queue backlog detected:', size)
    // Alert team or scale workers
  }
}, 60000)
```

### 4. Use Environment-Specific Configuration

```typescript
const teamSize =
  process.env.NODE_ENV === 'production'
    ? parseInt(process.env.QUEUE_TEAM_SIZE || '20')
    : 5 // Lower for development

await cms._listenToJobs({ teamSize })
```

## Troubleshooting

### Worker Not Processing Jobs

1. Check database connection
2. Verify job names match
3. Ensure pg-boss schema is created
4. Check worker logs for errors

### Jobs Stuck in Queue

```typescript
// Check queue size
const size = await cms.queue._boss.getQueueSize('job-name')
console.log('Pending jobs:', size)

// Check failed jobs
const failed = await cms.queue._boss.fetchFailed('job-name')
console.log('Failed jobs:', failed)
```

### High Memory Usage

- Reduce team size
- Check for memory leaks in handlers
- Use job batching for large datasets

## Next Steps

- [Job Definitions](/docs/features/queue/jobs) - Define typesafe jobs
- [Workflows](/docs/features/queue/workflows) - Chain multiple steps
- [API Reference](/docs/features/queue/api) - Complete API documentation
