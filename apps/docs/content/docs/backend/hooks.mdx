---
title: Hooks
description: Lifecycle hooks for adding custom business logic to your collections.
---

Hooks are functions that run at specific points in your collection's lifecycle. They allow you to add custom business logic, validation, side effects, and integrations without modifying the core CRUD operations.

## What are Hooks?

Hooks in QUESTPIE are:

- **Lifecycle callbacks** that execute before or after CRUD operations
- **Type-safe** with full access to record data
- **Async-capable** for external API calls, database queries, or queue jobs
- **CMS-aware** with direct access to all services (queue, email, storage, etc.)
- **Chainable** - multiple hooks can be defined for the same event

Think of hooks as middleware for your data operations - they intercept the flow and allow you to:

- Validate or transform data before saving
- Trigger side effects after changes (emails, notifications, webhooks)
- Sync data to external systems
- Generate derived data
- Enforce business rules

## Available Hooks

All hooks are fully type-safe with specific data types and field availability based on the operation.

### Lifecycle Hooks

**`beforeOperation`**

- **When**: Before any operation (create, update, delete, read)
- **Data type**: Depends on operation (TInsert, TUpdate, or TSelect)
- **`original` available**: No
- **Use for**: Logging, rate limiting, early validation

**`beforeValidate`**

- **When**: Before validation on create/update operations
- **Data type**: TInsert (create) or TUpdate (update) - mutable input data
- **`original` available**: No
- **Use for**: Transforming input, setting defaults, normalizing data

**`beforeChange`**

- **When**: Before create/update operations (after validation)
- **Data type**: TInsert (create) or TUpdate (update) - validated input data
- **`original` available**: No
- **Use for**: Business logic, slug generation, complex validation

**`afterChange`**

- **When**: After create/update operations
- **Data type**: TSelect - complete record with all fields
- **`original` available**: Yes (only on update operations)
- **Use for**: Notifications, webhooks, syncing to external services

**`beforeRead`**

- **When**: Before read operations
- **Data type**: Query context/options
- **`original` available**: No
- **Use for**: Modifying query options, adding filters

**`afterRead`**

- **When**: After any operation that returns data
- **Data type**: TSelect - complete record
- **`original` available**: Yes (only on update operations)
- **Use for**: Transforming output, adding computed fields, formatting

**`beforeDelete`**

- **When**: Before delete operations
- **Data type**: TSelect - record to be deleted
- **`original` available**: No
- **Use for**: Preventing deletion, cascading deletes, backups

**`afterDelete`**

- **When**: After delete operations
- **Data type**: TSelect - deleted record
- **`original` available**: No
- **Use for**: Cleanup, logging, notifying users

### Hook Execution Order

**Create**: `beforeOperation` → `beforeValidate` → `beforeChange` → [DB INSERT] → `afterChange` → `afterRead`

**Update**: `beforeOperation` → `beforeValidate` → `beforeChange` → [DB UPDATE] → `afterChange` → `afterRead`

**Delete**: `beforeOperation` → `beforeDelete` → [DB DELETE] → `afterDelete` → `afterRead`

**Read**: `beforeOperation` → `beforeRead` → [DB SELECT] → `afterRead`

## Hook Context

Every hook receives a context object with:

```typescript
interface HookContext<TData, TOriginal, TOperation, TCMS> {
  // The record data (type depends on hook)
  // - beforeValidate/beforeChange: TInsert | TUpdate (mutable)
  // - afterChange/afterRead/beforeDelete/afterDelete: TSelect (complete record)
  data: TData;

  // Original record (ONLY available in specific hooks)
  // - Type is 'never' in: beforeValidate, beforeChange, beforeDelete, afterDelete, beforeOperation
  // - Type is 'TSelect | undefined' in: afterChange (on update), afterRead (on update)
  original: TOriginal extends never ? never : TOriginal | undefined;

  // Current authenticated user
  user?: User;

  // Current locale
  locale?: string;

  // Access mode (system or user)
  accessMode?: "user" | "system";

  // Operation type (specific to hook)
  operation: TOperation;

  // Full CMS instance - type-safe access to all services
  cms: TCMS;

  // Database client (for transactions)
  db?: any;
}
```

**Key properties:**

- `data` - The record being processed. Type changes based on the hook:
  - `beforeValidate`/`beforeChange`: Insert or update data (TInsert | TUpdate)
  - `afterChange`/`afterRead`/`beforeDelete`/`afterDelete`: Complete record (TSelect)
- `original` - Previous state of the record. Only available in `afterChange` (on update) and `afterRead` (on update). In other hooks, this field has type `never` and cannot be accessed.
- `cms` - Full access to queue, email, storage, logger, and other collections
- `user` - Current authenticated user (if any)
- `operation` - The operation type: "create", "update", "delete", or "read"

When you need the CMS instance inside hooks without importing a global singleton:

```typescript
import { getAppFromContext } from "questpie";

const app = getAppFromContext();
```

## Basic Examples

### Generate Slug from Title

```typescript
import { q } from "questpie";
import { varchar, text } from "drizzle-orm/pg-core";
import slugify from "slugify";

export const posts = q.collection("posts")
  .fields({
    title: varchar("title", { length: 255 }).notNull(),
    slug: varchar("slug", { length: 255 }).notNull().unique(),
    content: text("content"),
  })
  .hooks({
    beforeChange: async ({ data, operation }) => {
      // Runs on both create and update
      if (operation === "create") {
        // Auto-generate slug on create if not provided
        if (!data.slug && data.title) {
          data.slug = slugify(data.title, { lower: true, strict: true });
        }
      } else if (operation === "update") {
        // Regenerate slug if title changed and slug wasn't manually set
        if (data.title && !data.slug) {
          data.slug = slugify(data.title, { lower: true, strict: true });
        }
      }
    },
  });
```

### Send Notification on Create

```typescript
export const posts = q.collection("posts")
  .fields({
    /* ... */
  })
  .hooks({
    afterChange: async ({ data, operation }) => {
      if (operation !== "create") return;

      const app = getAppFromContext();
      // Queue a job to send email notifications
      await app.queue.postCreatedNotification.publish({
        postId: data.id,
        title: data.title,
        authorId: data.authorId,
      });

      // Log the event
      app.logger.info("New post created", {
        postId: data.id,
        title: data.title,
      });
    },
  });
```

### Validate Data Before Save

```typescript
export const products = q.collection("products")
  .fields({
    name: varchar("name", { length: 255 }),
    price: integer("price"),
    discountPrice: integer("discount_price"),
  })
  .hooks({
    beforeChange: async ({ data }) => {
      // Runs on both create and update

      // Ensure discount price is less than regular price
      if (data.discountPrice && data.price) {
        if (data.discountPrice >= data.price) {
          throw new Error("Discount price must be less than regular price");
        }
      }

      // Ensure price is positive
      if (data.price !== undefined && data.price < 0) {
        throw new Error("Price cannot be negative");
      }
    },
  });
```

### Track Changes with Audit Log

```typescript
export const posts = q.collection("posts")
  .fields({
    /* ... */
  })
  .hooks({
    afterChange: async ({ data, original, operation, user }) => {
      if (operation !== "update" || !original) return;

      const app = getAppFromContext();
      // Detect what changed
      const changes: Record<string, { from: any; to: any }> = {};

      for (const key in data) {
        if (data[key] !== original[key]) {
          changes[key] = {
            from: original[key],
            to: data[key],
          };
        }
      }

      // Log to audit collection
      await app.api.collections.auditLog.create({
        collectionName: "posts",
        recordId: data.id,
        operation: "update",
        changes: JSON.stringify(changes),
        userId: user?.id,
        timestamp: new Date(),
      });
    },
  });
```

## Advanced Patterns

### Cascading Operations

When a record is deleted, clean up related data:

```typescript
export const users = q.collection("users")
  .fields({
    /* ... */
  })
  .hooks({
    beforeDelete: async ({ data }) => {
      const app = getAppFromContext();
      // Delete all posts by this user
      await app.api.collections.posts.delete({
        where: { authorId: data.id },
      });

      // Delete user's profile picture from storage
      if (data.avatarPath) {
        await app.storage.delete(data.avatarPath);
      }

      // Notify admin
      await app.queue.userDeleted.publish({
        userId: data.id,
        email: data.email,
      });
    },
  });
```

### Conditional Side Effects

Trigger actions only when specific fields change:

```typescript
export const posts = q.collection("posts")
  .fields({
    title: varchar("title", { length: 255 }),
    isPublished: boolean("is_published"),
    publishedAt: timestamp("published_at", { mode: "date" }),
  })
  .hooks({
    afterChange: async ({ data, original, operation }) => {
      const app = getAppFromContext();

      // Only handle update operations with original data
      if (operation !== "update" || !original) return;

      // Detect if post was just published
      const wasJustPublished = data.isPublished && !original.isPublished;

      if (wasJustPublished) {
        // Set publish timestamp
        if (!data.publishedAt) {
          await app.api.collections.posts.updateById({
            id: data.id,
            data: { publishedAt: new Date() },
          });
        }

        // Notify subscribers
        await app.queue.postPublished.publish({
          postId: data.id,
          title: data.title,
        });

        // Send to social media
        await app.queue.shareToSocialMedia.publish({
          postId: data.id,
        });
      }

      // Detect if post was unpublished
      const wasUnpublished = !data.isPublished && original.isPublished;

      if (wasUnpublished) {
        // Clear publish date
        await app.api.collections.posts.updateById({
          id: data.id,
          data: { publishedAt: null },
        });
      }
    },
  });
```

### External API Integration

Sync data to external services:

```typescript
export const products = q.collection("products")
  .fields({
    /* ... */
  })
  .hooks({
    afterChange: async ({ data, operation }) => {
      const app = getAppFromContext();

      if (operation === "create") {
        // Sync to external inventory system on create
        try {
          await fetch("https://api.inventory-system.com/products", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${process.env.INVENTORY_API_KEY}`,
            },
            body: JSON.stringify({
              externalId: data.id,
              name: data.name,
              sku: data.sku,
              quantity: data.stock,
            }),
          });

          app.logger.info("Product synced to inventory system", {
            productId: data.id,
          });
        } catch (error) {
          // Don't fail the operation, queue retry instead
          app.logger.error("Failed to sync product to inventory", {
            productId: data.id,
            error,
          });

          await app.queue.retryInventorySync.publish({
            productId: data.id,
          });
        }
      } else if (operation === "update") {
        // Sync updates to external system
        await app.queue.syncProductToInventory.publish({
          productId: data.id,
        });
      }
    },
  });
```

## Multiple Hooks

You can define multiple hook functions for the same event - they run in order:

```typescript
export const posts = q.collection("posts")
  .fields({
    /* ... */
  })
  .hooks({
    // Array of hook functions
    afterChange: [
      // Hook 1: Send notification (only on create)
      async ({ data, operation }) => {
        if (operation !== "create") return;
        const app = getAppFromContext();
        await app.queue.postCreated.publish({ postId: data.id });
      },

      // Hook 2: Update statistics
      async ({ data }) => {
        const app = getAppFromContext();
        await app.api.collections.stats.updateById({
          id: "global-stats",
          data: {
            totalPosts: { increment: 1 },
          },
        });
      },

      // Hook 3: Log event
      async ({ data }) => {
        const app = getAppFromContext();
        app.logger.info("Post created", { postId: data.id });
      },
    ],
  });
```

## Hook Execution Order

For a **create** operation:

1. `beforeOperation` (if defined)
2. `beforeValidate` (if defined)
3. `beforeChange` (if defined)
4. **Database INSERT**
5. `afterChange` (if defined)
6. `afterRead` (if defined)

For an **update** operation:

1. `beforeOperation` (if defined)
2. `beforeValidate` (if defined)
3. `beforeChange` (if defined)
4. **Database UPDATE**
5. `afterChange` (if defined, with `original` available)
6. `afterRead` (if defined, with `original` available)

For a **delete** operation:

1. `beforeOperation` (if defined)
2. `beforeDelete` (if defined)
3. **Database DELETE** (or soft delete)
4. `afterDelete` (if defined)
5. `afterRead` (if defined)

For a **read** operation:

1. `beforeOperation` (if defined)
2. `beforeRead` (if defined)
3. **Database SELECT**
4. `afterRead` (if defined)

**Important:** If any `before*` hook throws an error, the operation is aborted and the database is not modified.

## Best Practices

### 1. Keep Hooks Fast

Hooks run synchronously in the request flow. For slow operations, use queue jobs:

```typescript
// ❌ Bad - Slow operation blocks the request
afterChange: async ({ data, operation }) => {
  if (operation !== "create") return;
  await processLargeImage(data.imageUrl); // Might take 10 seconds
};

// ✅ Good - Queue the work
afterChange: async ({ data, operation }) => {
  if (operation !== "create") return;
  const app = getAppFromContext();
  await app.queue.processImage.publish({ imageId: data.imageId });
};
```

### 2. Avoid Infinite Loops

Be careful when updating the same collection inside hooks:

```typescript
// ❌ Bad - Infinite loop!
afterChange: async ({ data, operation }) => {
  if (operation !== "update") return;
  const app = getAppFromContext();
  await app.api.collections.posts.updateById({
    id: data.id,
    data: { updatedCount: data.updatedCount + 1 },
  }); // This triggers afterChange again!
};

// ✅ Good - Use a flag or condition
afterChange: async ({ data, original, operation }) => {
  if (operation !== "update" || !original) return;
  const app = getAppFromContext();
  // Only update when status changes
  if (data.isPublished && !original.isPublished) {
    await app.api.collections.posts.updateById({
      id: data.id,
      data: { publishedAt: new Date() },
    });
  }
};
```

### 3. Use beforeChange for Shared Logic

`beforeChange` runs on both create and update - perfect for shared logic:

```typescript
// ✅ Good - Single hook for both operations
beforeChange: async ({ data, operation }) => {
  if (data.title) {
    data.slug = slugify(data.title);
  }

  // You can still differentiate if needed
  if (operation === "create") {
    data.createdBy = "system";
  }
},
```

### 4. Don't Throw Errors in After Hooks

After hooks run after the database operation - throwing an error won't roll back:

```typescript
// ❌ Bad - Record already created, error is confusing
afterChange: async ({ data, operation }) => {
  if (operation === "create" && !data.email) {
    throw new Error("Email required"); // Too late!
  }
};

// ✅ Good - Validate in before hooks
beforeChange: async ({ data, operation }) => {
  if (operation === "create" && !data.email) {
    throw new Error("Email required"); // Prevents creation
  }
};
```

### 5. Use CMS Services, Not Global State

Always access services through the CMS context (use `getAppFromContext` inside hooks):

```typescript
// ❌ Bad - Using global/imported instance
import { cms } from "./app";

afterChange: async ({ data, operation }) => {
  if (operation !== "create") return;
  await app.queue.jobName.publish(...); // Don't do this
}

// ✅ Good - Use the CMS from context
afterChange: async ({ data, operation }) => {
  if (operation !== "create") return;
  const app = getAppFromContext();
  await app.queue.jobName.publish(...); // Type-safe and context-aware
}
```

## Type Safety

Hooks are fully typed with precise data types and field availability:

```typescript
export const posts = q.collection("posts")
  .fields({
    title: varchar("title", { length: 255 }),
    viewCount: integer("view_count").default(0),
  })
  .hooks({
    beforeChange: async ({ data, operation, original }) => {
      const app = getAppFromContext();

      // ✅ TypeScript knows the shape of data based on operation
      if (operation === "create") {
        // data is TInsert type
        data.title.toUpperCase(); // ✅ OK
        data.viewCount = 0; // ✅ OK
      } else {
        // data is TUpdate type (all fields optional)
        data.title?.toUpperCase(); // ✅ OK
      }

      // original has type 'never' - cannot access in beforeChange
      // const x = original; // ❌ TypeScript error

      // ✅ TypeScript knows app.queue exists
      await app.queue.jobName.publish({
        /* typed payload */
      });
    },

    afterChange: async ({ data, original, operation }) => {
      // data is always TSelect (complete record)
      data.id; // ✅ Always available
      data.title; // ✅ Always available
      data.viewCount; // ✅ Always available
      data.createdAt; // ✅ Always available
      data._title; // ✅ Generated title field available

      // original is available but might be undefined
      if (operation === "update" && original) {
        // TypeScript knows both are TSelect
        const titleChanged = data.title !== original.title; // ✅ Type-safe

        original.id; // ✅ OK
        original.title; // ✅ OK
      }
    },
  });
```

**Hover over any hook parameter** to see exactly what fields are available and their types!

## Next Steps

- Learn about [Access Control](/docs/core-concepts/access-control) for securing operations
- Explore [Queue Jobs](/docs/guides/queue-jobs) for background processing
- See [Email Templates](/docs/guides/email-templates) for practical hook implementations

## Reference

- **Source Code**: `packages/cms/src/server/collection/builder/types.ts:200-217`
- **Hook Context**: `packages/cms/src/server/collection/builder/types.ts:124-177`
- **Examples**: `examples/portfolio-hono/src/cms.ts:107-124`
