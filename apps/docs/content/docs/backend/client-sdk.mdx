---
title: Client SDK
description: Type-safe API client for browser and server
---

# Client SDK

The QUESTPIE client SDK provides type-safe API access from both browser and server environments via HTTP.

## Server API vs Client SDK

QUESTPIE provides two ways to access your CMS data:

### Server API (`cms.api`)

Direct database access from server-side code. Use this in:
- API routes
- Server components
- Background jobs
- Server-side rendering

```typescript
// Server-side only - direct database access
import { cms } from "@/questpie/server/cms";

const { docs } = await cms.api.collections.posts.find({
  where: { published: true },
});
```

**Characteristics:**
- Direct database queries (Drizzle ORM)
- Full CRUD interface with `updateById`, `deleteById`, `restoreById`
- Batch operations with `update(where)`, `delete(where)`
- Versioning with `findVersions`, `revertToVersion`
- Access to request context for hooks and access control
- No network overhead

### Client SDK (`createClient`)

HTTP client for browser and external services. Use this in:
- React components (browser)
- Mobile apps
- External services
- Any HTTP client

```typescript
// Browser or any HTTP client
import { createClient } from "questpie/client";
import type { AppCMS } from "@/questpie/server/cms";

const client = createClient<AppCMS>({
  baseURL: "http://localhost:3000",
});

const { docs } = await client.collections.posts.find({
  where: { published: true },
});
```

**Characteristics:**
- HTTP requests to your CMS API endpoints
- Simplified API: `update(id, data)` instead of `updateById({ id, data })`
- Progress tracking for file uploads
- Works in browser with cookies/auth
- SuperJSON serialization for Date, Map, Set support

### API Differences

| Operation | Server API (`cms.api`) | Client SDK |
|-----------|----------------------|------------|
| Update single | `updateById({ id, data })` | `update(id, data)` |
| Update many | `update({ where, data })` | Not available |
| Delete single | `deleteById({ id })` | `delete(id)` |
| Delete many | `delete({ where })` | Not available |
| Restore | `restoreById({ id })` | `restore(id)` |
| Versions | `findVersions({ id })` | Not available |
| Revert | `revertToVersion({ id, version })` | Not available |

The client SDK exposes a simpler interface designed for common use cases, while the server API provides the full power of the CRUD system.

## Setup

### Create Client

```typescript
// lib/cms-client.ts
import { createClient } from "questpie/client";
import type { AppCMS } from "@/questpie/server/cms";

export const cmsClient = createClient<AppCMS>({
  baseURL: "http://localhost:3000",
  basePath: "/api/cms",  // Default: "/cms"
});
```

### Configuration Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `baseURL` | `string` | Required | Base URL of your API |
| `basePath` | `string` | `"/cms"` | Path prefix for CMS routes |
| `fetch` | `typeof fetch` | `globalThis.fetch` | Custom fetch implementation |
| `headers` | `Record<string, string>` | `{}` | Default headers for all requests |
| `useSuperJSON` | `boolean` | `true` | Enable SuperJSON serialization |

### Custom Fetch

For server-side usage or custom authentication:

```typescript
const cmsClient = createClient<AppCMS>({
  baseURL: process.env.API_URL,
  basePath: "/api/cms",
  fetch: async (url, init) => {
    // Add authentication header
    const headers = new Headers(init?.headers);
    headers.set("Authorization", `Bearer ${getToken()}`);

    return fetch(url, { ...init, headers });
  },
});
```

### With Cookies

For session-based auth in the browser:

```typescript
const cmsClient = createClient<AppCMS>({
  baseURL: "",  // Same origin
  basePath: "/api/cms",
  fetch: (url, init) => fetch(url, {
    ...init,
    credentials: "include",  // Send cookies
  }),
});
```

## Collection API

The client mirrors the server CRUD API with full type safety.

### `find(options?)`

Query multiple records.

```typescript
const { docs, totalDocs } = await cmsClient.collections.posts.find({
  where: { published: true },
  orderBy: { publishedAt: "desc" },
  limit: 10,
  with: { author: true },
});

// docs is typed as Post[]
docs.forEach(post => {
  console.log(post.title, post.author?.name);
});
```

### `findOne(options?)`

Query a single record.

```typescript
const post = await cmsClient.collections.posts.findOne({
  where: { slug: "hello-world" },
  with: { author: true, tags: true },
});

if (post) {
  console.log(post.title);
}
```

### `count(options?)`

Count matching records.

```typescript
const total = await cmsClient.collections.posts.count({
  where: { published: true },
});
```

### `create(data, options?)`

Create a new record.

```typescript
const post = await cmsClient.collections.posts.create({
  title: "My New Post",
  content: "Hello world!",
  published: false,
});

console.log(post.id);
```

With locale:

```typescript
const post = await cmsClient.collections.posts.create({
  title: "Môj nový príspevok",
  content: "Ahoj svet!",
}, { locale: "sk" });
```

### `update(id, data, options?)`

Update an existing record.

```typescript
const updated = await cmsClient.collections.posts.update("post-123", {
  title: "Updated Title",
  published: true,
});
```

### `delete(id, options?)`

Delete a record.

```typescript
await cmsClient.collections.posts.delete("post-123");
```

### `restore(id, options?)`

Restore a soft-deleted record.

```typescript
await cmsClient.collections.posts.restore("post-123");
```

### `meta()`

Get collection schema metadata.

```typescript
const meta = await cmsClient.collections.posts.meta();

console.log(meta.fields);      // Field definitions
console.log(meta.relations);   // Relation definitions
console.log(meta.options);     // Collection options
```

## File Uploads

### `upload(file, options?)`

Upload a single file with progress tracking.

```typescript
const asset = await cmsClient.collections.assets.upload(file, {
  onProgress: (progress) => {
    console.log(`${progress.percent}% uploaded`);
  },
});

console.log(asset.url);
```

### `uploadMany(files, options?)`

Upload multiple files.

```typescript
const assets = await cmsClient.collections.assets.uploadMany(files, {
  onProgress: (progress) => {
    // Called for each file
    console.log(`File ${progress.index}: ${progress.percent}%`);
  },
});
```

### Progress Options

| Option | Type | Description |
|--------|------|-------------|
| `onProgress` | `(progress) => void` | Progress callback |

Progress object:

| Field | Type | Description |
|-------|------|-------------|
| `loaded` | `number` | Bytes uploaded |
| `total` | `number` | Total bytes |
| `percent` | `number` | Percentage (0-100) |
| `index` | `number` | File index (for uploadMany) |

### Upload Example

```tsx
function FileUploader() {
  const [progress, setProgress] = useState(0);
  const [asset, setAsset] = useState(null);

  const handleUpload = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (!file) return;

    const uploaded = await cmsClient.collections.assets.upload(file, {
      onProgress: ({ percent }) => setProgress(percent),
    });

    setAsset(uploaded);
  };

  return (
    <div>
      <input type="file" onChange={handleUpload} />
      {progress > 0 && progress < 100 && (
        <progress value={progress} max={100} />
      )}
      {asset && <img src={asset.url} alt="" />}
    </div>
  );
}
```

## Global API

### `get(options?)`

Get global singleton data.

```typescript
const settings = await cmsClient.globals.settings.get();

console.log(settings.siteName);
console.log(settings.logo);
```

With locale:

```typescript
const settings = await cmsClient.globals.settings.get({
  locale: "sk",
});
```

### `update(data, options?)`

Update global data.

```typescript
const updated = await cmsClient.globals.settings.update({
  siteName: "My New Site Name",
});
```

## Functions API

Call RPC functions defined on the backend.

```typescript
// Backend definition
const cms = q({ name: "my-cms" })
  .functions({
    sendNewsletter: async ({ input }) => {
      const { subject, content, recipients } = input;
      // Send newsletter
      return { sent: recipients.length };
    },
  });

// Client call
const result = await cmsClient.functions.sendNewsletter({
  subject: "Monthly Update",
  content: "Here's what's new...",
  recipients: ["user@example.com"],
});

console.log(result.sent);  // Number of emails sent
```

## Search API

Full-text search across collections.

### `search(options)`

```typescript
const results = await cmsClient.search.search({
  query: "typescript cms",
  collections: ["posts", "pages"],
  limit: 20,
});

results.docs.forEach(doc => {
  console.log(doc.collection, doc.title, doc.score);
});
```

Search options:

| Option | Type | Description |
|--------|------|-------------|
| `query` | `string` | Search query |
| `collections` | `string[]` | Collections to search |
| `locale` | `string` | Filter by locale |
| `limit` | `number` | Max results |
| `offset` | `number` | Pagination offset |
| `mode` | `"lexical" \| "semantic" \| "hybrid"` | Search mode |

### `reindex(collection)`

Trigger reindexing of a collection.

```typescript
await cmsClient.search.reindex("posts");
```

## Locale Management

### Set Client Locale

```typescript
// Set default locale for all requests
cmsClient.setLocale("sk");

// Clear locale (use default)
cmsClient.setLocale(undefined);
```

### Get Current Locale

```typescript
const locale = cmsClient.getLocale();
```

### Per-Request Locale

```typescript
// Override locale for specific request
const posts = await cmsClient.collections.posts.find({
  locale: "de",
  where: { published: true },
});
```

## Error Handling

The client throws `QuestpieClientError` for API errors.

```typescript
import { QuestpieClientError } from "questpie/client";

try {
  await cmsClient.collections.posts.create({
    title: "",  // Invalid: empty title
  });
} catch (error) {
  if (error instanceof QuestpieClientError) {
    console.log("Error code:", error.code);
    console.log("Message:", error.message);

    // Field-specific errors
    if (error.fieldErrors) {
      Object.entries(error.fieldErrors).forEach(([field, errors]) => {
        console.log(`${field}: ${errors.join(", ")}`);
      });
    }
  }
}
```

### Error Properties

| Property | Type | Description |
|----------|------|-------------|
| `code` | `string` | Error code (e.g., "VALIDATION_ERROR") |
| `message` | `string` | Human-readable message |
| `fieldErrors` | `Record<string, string[]>` | Validation errors by field |
| `context` | `object` | Additional error context |

### Error Methods

```typescript
// Check error code
if (error.isCode("NOT_FOUND")) {
  // Handle not found
}

// Get specific field error
const titleError = error.getFieldError("title");

// Get all field errors as map
const errors = error.getFieldErrorsMap();
```

### Common Error Codes

| Code | Description |
|------|-------------|
| `VALIDATION_ERROR` | Input validation failed |
| `NOT_FOUND` | Resource not found |
| `UNAUTHORIZED` | Authentication required |
| `FORBIDDEN` | Permission denied |
| `CONFLICT` | Duplicate or conflict |
| `INTERNAL_ERROR` | Server error |

## Upload Errors

File uploads have specific error handling.

```typescript
import { UploadError } from "questpie/client";

try {
  await cmsClient.collections.assets.upload(largeFile);
} catch (error) {
  if (error instanceof UploadError) {
    console.log("Upload failed:", error.message);
    console.log("File:", error.fileName);
    console.log("Size:", error.fileSize);
  }
}
```

## React Integration

Use with `@questpie/tanstack-query` for React hooks.

```typescript
// lib/cms-hooks.ts
import { createCmsHooks } from "@questpie/tanstack-query";
import { cmsClient } from "./cms-client";

export const { useCmsQuery, useCmsMutation } = createCmsHooks(cmsClient);
```

```tsx
// components/PostList.tsx
function PostList() {
  const { data, isLoading, error } = useCmsQuery(
    ["posts", "list"],
    () => cmsClient.collections.posts.find({
      where: { published: true },
      limit: 10,
    })
  );

  if (isLoading) return <Loading />;
  if (error) return <Error error={error} />;

  return (
    <ul>
      {data.docs.map(post => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  );
}
```

```tsx
// components/CreatePost.tsx
function CreatePost() {
  const mutation = useCmsMutation(
    (data) => cmsClient.collections.posts.create(data),
    {
      onSuccess: (post) => {
        toast.success("Post created!");
        router.push(`/posts/${post.id}`);
      },
      onError: (error) => {
        if (error instanceof QuestpieClientError) {
          toast.error(error.message);
        }
      },
    }
  );

  return (
    <form onSubmit={(e) => {
      e.preventDefault();
      mutation.mutate({
        title: formData.title,
        content: formData.content,
      });
    }}>
      {/* form fields */}
      <button disabled={mutation.isPending}>
        {mutation.isPending ? "Creating..." : "Create Post"}
      </button>
    </form>
  );
}
```

## Server-Side Usage

The client works on both server and browser.

### Next.js Server Component

```tsx
// app/posts/page.tsx
import { cmsClient } from "@/lib/cms-client";

export default async function PostsPage() {
  const { docs } = await cmsClient.collections.posts.find({
    where: { published: true },
    orderBy: { publishedAt: "desc" },
  });

  return (
    <div>
      {docs.map(post => (
        <article key={post.id}>
          <h2>{post.title}</h2>
        </article>
      ))}
    </div>
  );
}
```

### API Route

```typescript
// app/api/featured/route.ts
import { cmsClient } from "@/lib/cms-client";

export async function GET() {
  const { docs } = await cmsClient.collections.posts.find({
    where: { featured: true },
    limit: 5,
  });

  return Response.json(docs);
}
```

## Type Safety

The client provides full type inference from your CMS definition.

```typescript
// Types are inferred from AppCMS
const post = await cmsClient.collections.posts.findOne({
  where: { id: "123" },
});
// post is typed as Post | null

// Autocomplete for collection names
cmsClient.collections.posts   // ← Autocomplete!
cmsClient.collections.pages   // ← Autocomplete!

// Autocomplete for fields in where clauses
cmsClient.collections.posts.find({
  where: {
    title: { contains: "..." },  // ← Field autocomplete!
  },
});

// Type errors for invalid data
cmsClient.collections.posts.create({
  titl: "typo",  // ← TypeScript error!
});
```

## Next Steps

<Cards>
  <Card href="/docs/backend/crud-operations" title="CRUD Operations" description="Server-side operations" />
  <Card href="/docs/backend/validation" title="Validation" description="Input validation" />
  <Card href="/docs/guides/authentication" title="Authentication" description="Auth integration" />
  <Card href="/docs/admin" title="Admin UI" description="Admin interface" />
</Cards>
