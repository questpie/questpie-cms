---
title: Localization
description: Content localization and i18n support
---

# Localization

QUESTPIE provides built-in content localization (i18n) for collections and globals, plus backend message translation.

## Locale Configuration

Configure available locales in your CMS:

```typescript
import { q } from "questpie";

const cms = q({ name: "my-cms" })
  .locale({
    locales: [
      { code: "en", label: "English", flagCountryCode: "US" },
      { code: "sk", label: "Slovenčina", flagCountryCode: "SK" },
      { code: "de", label: "Deutsch", flagCountryCode: "DE" },
      { code: "es", label: "Español", flagCountryCode: "ES" },
    ],
    defaultLocale: "en",
    fallbacks: {
      "en-GB": "en",
      "en-US": "en",
      "de-AT": "de",
      "de-CH": "de",
    },
  })
  .collections({...})
  .build({...});
```

### Locale Options

| Option | Type | Description |
|--------|------|-------------|
| `locales` | `Locale[]` or `() => Promise<Locale[]>` | Available locales |
| `defaultLocale` | `string` | Fallback locale code |
| `fallbacks` | `Record<string, string>` | Map regional locales to base locales |

### Locale Object

| Field | Type | Description |
|-------|------|-------------|
| `code` | `string` | Locale identifier (e.g., "en", "en-US") |
| `label` | `string` | Display name for UI |
| `flagCountryCode` | `string` | ISO country code for flag icons |
| `fallback` | `boolean` | Whether this is a fallback locale |

### Dynamic Locales

Load locales from database or external source:

```typescript
.locale({
  locales: async () => {
    const locales = await db.select().from(localesTable);
    return locales.map(l => ({
      code: l.code,
      label: l.name,
      flagCountryCode: l.country,
    }));
  },
  defaultLocale: "en",
})
```

## Collection Localization

Mark fields as localized using `.localized()`:

```typescript
const posts = q.collection("posts")
  .fields({
    slug: text("slug").notNull(),        // Not localized
    title: text("title").notNull(),       // Will be localized
    content: text("content"),             // Will be localized
    metadata: jsonb("metadata"),          // Will be localized (whole mode)
    published: boolean("published"),      // Not localized
  })
  .localized(["title", "content", "metadata"]);
```

### Localization Modes

QUESTPIE supports two localization modes for different field types:

#### Flat Mode (Default)

For text fields, entire values are stored per locale:

```typescript
.localized(["title", "description"])
```

Database structure:
```sql
-- Main table
posts (id, slug, published, ...)

-- Localization table
posts_i18n (id, post_id, locale, title, description)
```

#### Nested Mode

For JSONB fields, use `:nested` suffix to localize values within the structure:

```typescript
.localized([
  "title",           // Flat mode
  "blocks:nested",   // Nested mode
])
```

Nested mode wraps localized values in `{ $i18n: value }` objects:

```json
// Stored in main table (structure)
{
  "blocks": [
    { "type": "heading", "text": { "$i18n": true } },
    { "type": "image", "src": "/image.jpg" }
  ]
}

// Stored in i18n table (localized values)
{
  "blocks": [
    { "text": "Hello World" },
    {}
  ]
}
```

This is useful for page builder content where the structure is shared but text varies.

### Whole Mode (Default for JSONB)

For JSONB fields without `:nested`, entire JSON objects are stored per locale:

```typescript
.localized(["settings"])  // Whole mode

// Each locale has a complete copy:
// en: { theme: "light", greeting: "Hello" }
// sk: { theme: "light", greeting: "Ahoj" }
```

## CRUD with Locales

### Query by Locale

```typescript
// Get posts in Slovak
const { docs } = await cms.api.collections.posts.find({
  where: { published: true },
  locale: "sk",
});

// With fallback to default locale
const { docs } = await cms.api.collections.posts.find({
  where: { published: true },
  locale: "sk",
  localeFallback: true,
});
```

### Create Localized Content

```typescript
// Create post with English content
const post = await cms.api.collections.posts.create({
  slug: "hello-world",
  title: "Hello World",
  content: "Welcome to my blog!",
  published: true,
});
```

By default, content is created in the default locale. Specify a different locale:

```typescript
// Create Slovak version
await cms.api.collections.posts.create({
  slug: "hello-world",
  title: "Ahoj svet",
  content: "Vitajte na mojom blogu!",
}, { locale: "sk" });
```

### Update Localized Content

```typescript
// Update English version
await cms.api.collections.posts.update(postId, {
  title: "Updated Title",
});

// Update Slovak version
await cms.api.collections.posts.update(postId, {
  title: "Aktualizovaný názov",
}, { locale: "sk" });
```

### Delete Localized Content

Deleting a post removes all locale versions:

```typescript
await cms.api.collections.posts.delete(postId);
```

## Locale Fallback

When content isn't available in the requested locale, fallback behavior applies:

```typescript
// Configure fallbacks
.locale({
  locales: [...],
  defaultLocale: "en",
  fallbacks: {
    "de-AT": "de",   // Austrian German falls back to German
    "de-CH": "de",   // Swiss German falls back to German
    "pt-BR": "pt",   // Brazilian Portuguese falls back to Portuguese
  },
})
```

### Fallback Chain

1. Requested locale (e.g., "de-AT")
2. Configured fallback (e.g., "de")
3. Default locale (e.g., "en")

### Enable/Disable Fallback

```typescript
// Enable fallback (use default locale if translation missing)
const posts = await cms.api.collections.posts.find({
  locale: "sk",
  localeFallback: true,  // Returns English if Slovak not available
});

// Disable fallback (only return if locale exists)
const posts = await cms.api.collections.posts.find({
  locale: "sk",
  localeFallback: false,  // Returns null if Slovak not available
});
```

## Global Localization

Globals support localization the same way:

```typescript
const settings = q.global("settings")
  .fields({
    siteName: text("siteName"),
    tagline: text("tagline"),
    contactEmail: text("contactEmail"),
  })
  .localized(["siteName", "tagline"]);

// Query
const settings = await cms.api.globals.settings.get({ locale: "sk" });

// Update
await cms.api.globals.settings.update({
  siteName: "Moja stránka",
  tagline: "Vitajte!",
}, { locale: "sk" });
```

## Backend Messages

Translate error messages and system text.

### Define Messages

```typescript
const cms = q({ name: "my-cms" })
  .messages({
    en: {
      "error.notFound": "Resource not found",
      "error.unauthorized": "Please sign in",
      "error.forbidden": "You don't have permission",
      "validation.required": "This field is required",
      "validation.email": "Please enter a valid email",
      "email.welcome.subject": "Welcome to {{ siteName }}",
      "email.welcome.body": "Hi {{ name }}, thanks for joining!",
    },
    sk: {
      "error.notFound": "Zdroj nebol nájdený",
      "error.unauthorized": "Prosím prihláste sa",
      "error.forbidden": "Nemáte oprávnenie",
      "validation.required": "Toto pole je povinné",
      "validation.email": "Zadajte platnú emailovú adresu",
      "email.welcome.subject": "Vitajte na {{ siteName }}",
      "email.welcome.body": "Ahoj {{ name }}, ďakujeme za registráciu!",
    },
  })
  .build({...});
```

### Use Translator

```typescript
// Simple translation
const message = cms.t("error.notFound");
// "Resource not found"

// With interpolation
const greeting = cms.t("email.welcome.subject", { siteName: "My App" });
// "Welcome to My App"

// Specific locale
const localizedMessage = cms.t("error.notFound", {}, "sk");
// "Zdroj nebol nájdený"
```

### Interpolation

Use `{{ variable }}` syntax for dynamic values:

```typescript
"messages.hello": "Hello {{ name }}!"

cms.t("messages.hello", { name: "John" });
// "Hello John!"
```

### Plural Forms

QUESTPIE supports plural forms using `Intl.PluralRules`:

```typescript
.messages({
  en: {
    "items.count_one": "{{ count }} item",
    "items.count_other": "{{ count }} items",
  },
  sk: {
    "items.count_one": "{{ count }} položka",
    "items.count_few": "{{ count }} položky",
    "items.count_many": "{{ count }} položiek",
    "items.count_other": "{{ count }} položiek",
  },
})

// Usage
cms.t("items.count", { count: 1 });   // "1 item"
cms.t("items.count", { count: 5 });   // "5 items"
cms.t("items.count", { count: 1 }, "sk");  // "1 položka"
cms.t("items.count", { count: 3 }, "sk");  // "3 položky"
```

Plural categories vary by language:
- English: `one`, `other`
- Slovak/Czech: `one`, `few`, `many`, `other`
- Arabic: `zero`, `one`, `two`, `few`, `many`, `other`

### Merge with Module Messages

Messages from modules are merged:

```typescript
import { adminModule } from "@questpie/admin/server";

const cms = q({ name: "my-cms" })
  .use(adminModule)  // Has default messages
  .messages({
    en: {
      // Override admin messages
      "error.notFound": "Custom not found message",
      // Add your own
      "custom.greeting": "Hello!",
    },
  });
```

Later messages override earlier ones (last wins).

## Client Locale

### Set Client Locale

```typescript
import { createClient } from "questpie/client";

const client = createClient<AppCMS>({
  baseURL: "http://localhost:3000",
});

// Set default locale for all requests
client.setLocale("sk");

// Clear locale
client.setLocale(undefined);
```

### Per-Request Locale

```typescript
// Query with specific locale
const posts = await client.collections.posts.find({
  locale: "de",
  localeFallback: true,
});

// Create with locale
await client.collections.posts.create({
  title: "Hallo Welt",
}, { locale: "de" });
```

### Get Current Locale

```typescript
const currentLocale = client.getLocale();
```

## Admin UI Locale

The admin UI supports locale switching for content editing:

```typescript
import { qa, adminModule } from "@questpie/admin/client";

const admin = qa<AppCMS>()
  .use(adminModule)
  .collections({
    posts: qa.collection("posts")
      .fields(({ r }) => ({
        title: r.text({ label: "Title", localized: true }),
        content: r.richText({ label: "Content", localized: true }),
        slug: r.text({ label: "Slug" }),  // Not localized in UI
      })),
  });
```

The admin automatically shows a locale switcher when localized fields exist.

## Runtime Locale Access

### Get Available Locales

```typescript
const locales = await cms.getLocales();
// [{ code: "en", label: "English", ... }, ...]
```

### In Request Context

```typescript
const ctx = await cms.createContext({
  session: userSession,
  locale: "sk",
});

// Access locale in hooks
.hooks({
  beforeCreate: async ({ data, ctx }) => {
    console.log(ctx.locale);        // "sk"
    console.log(ctx.defaultLocale); // "en"
    return data;
  },
})
```

## Database Schema

For localized collections, QUESTPIE creates additional tables:

```sql
-- Main table (non-localized fields + structure for nested JSONB)
CREATE TABLE posts (
  id TEXT PRIMARY KEY,
  slug TEXT NOT NULL,
  published BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);

-- Localization table
CREATE TABLE posts_i18n (
  id TEXT PRIMARY KEY,
  post_id TEXT REFERENCES posts(id),
  locale TEXT NOT NULL,
  title TEXT,
  content TEXT,
  _localized JSONB,  -- For nested mode values
  UNIQUE(post_id, locale)
);
```

## Best Practices

### 1. Locale-Agnostic Slugs

Keep slugs non-localized for consistent URLs:

```typescript
.fields({
  slug: text("slug").notNull(),  // Same across locales
  title: text("title").notNull(),
})
.localized(["title"])  // Only localize title
```

### 2. Fallback Strategy

Enable fallback for content, disable for strict requirements:

```typescript
// Public content: fallback enabled
const posts = await cms.api.collections.posts.find({
  locale: userLocale,
  localeFallback: true,  // Show English if translation missing
});

// Legal documents: no fallback
const terms = await cms.api.collections.legal.findOne({
  where: { slug: "terms" },
  locale: userLocale,
  localeFallback: false,  // Must have exact translation
});
```

### 3. Partial Translations

Handle missing translations gracefully:

```typescript
const post = await cms.api.collections.posts.findOne({
  where: { slug },
  locale: userLocale,
  localeFallback: true,
});

// Check if content is in requested locale
if (post._locale !== userLocale) {
  // Show notice: "This content is not available in your language"
}
```

### 4. SEO Considerations

Generate hreflang tags for localized content:

```tsx
const locales = await cms.getLocales();
const currentUrl = `/posts/${post.slug}`;

{locales.map(locale => (
  <link
    key={locale.code}
    rel="alternate"
    hrefLang={locale.code}
    href={`/${locale.code}${currentUrl}`}
  />
))}
```

## Related

- [CRUD Operations](/docs/backend/crud-operations) - Query with locales
- [Versioning](/docs/backend/versioning) - Version history
- [Admin UI](/docs/admin) - Locale switching in admin
