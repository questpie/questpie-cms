---
title: Builder API
description: Complete reference for the q() builder pattern
---

# Builder API

The `q()` builder is the entry point for defining your backend CMS. It uses a fluent API pattern with full TypeScript inference.

## Overview

```typescript
import { q, text, integer, boolean, datetime } from "questpie";

const cms = q({ name: "my-cms" })
  .use(someModule)           // Compose modules
  .collections({...})        // Define collections
  .globals({...})            // Define globals
  .functions({...})          // Define RPC functions
  .jobs({...})               // Define background jobs
  .auth({...})               // Configure authentication
  .locale({...})             // Configure localization
  .emailTemplates({...})     // Define email templates
  .messages({...})           // Add i18n messages
  .migrations([...])         // Register migrations
  .build({...});             // Create runtime instance
```

## Entry Point

### `q(config)`

Creates a new QUESTPIE builder instance.

```typescript
import { q } from "questpie";

const cms = q({ name: "my-cms" });
```

| Option | Type | Description |
|--------|------|-------------|
| `name` | `string` | Unique identifier for the CMS instance |

## Content Definition Methods

### `.collections(map)`

Defines collections as a type-safe map. Collections are the core data models in your CMS.

```typescript
const cms = q({ name: "my-cms" })
  .collections({
    posts: q.collection("posts")
      .fields({
        title: text("title").notNull(),
        content: text("content"),
      }),

    categories: q.collection("categories")
      .fields({
        name: text("name").notNull(),
      }),
  });
```

Collections are accessed after `.build()`:
- `cms.collections.posts.table` - Drizzle table
- `cms.api.collections.posts` - CRUD operations

See [Collections](/docs/backend/collections) for detailed collection builder documentation.

### `.globals(map)`

Defines global singleton records. Globals are single-instance documents like site settings.

```typescript
const cms = q({ name: "my-cms" })
  .globals({
    settings: q.global("settings")
      .fields({
        siteName: text("siteName"),
        description: text("description"),
        logo: text("logo"),
      }),

    navigation: q.global("navigation")
      .fields({
        items: jsonb("items"),
      }),
  });
```

Globals are accessed after `.build()`:
- `cms.globals.settings.table` - Drizzle table
- `cms.api.globals.settings` - Get/update operations

See [Globals](/docs/backend/globals) for detailed global builder documentation.

### `.functions(map)`

Defines root-level RPC functions that can be called via the API.

```typescript
const cms = q({ name: "my-cms" })
  .functions({
    sendNewsletter: async ({ input, ctx }) => {
      const { subject, content } = input;
      // Send newsletter logic
      return { sent: true, count: 150 };
    },

    generateReport: async ({ input, ctx }) => {
      const { startDate, endDate } = input;
      // Generate report
      return { url: "/reports/2024-01.pdf" };
    },
  });
```

Functions can accept typed input and return typed output:

```typescript
import { z } from "zod";

const cms = q({ name: "my-cms" })
  .functions({
    createInvoice: {
      input: z.object({
        customerId: z.string(),
        items: z.array(z.object({
          productId: z.string(),
          quantity: z.number(),
        })),
      }),
      handler: async ({ input, ctx }) => {
        // Type-safe access to input.customerId, input.items
        return { invoiceId: "INV-001" };
      },
    },
  });
```

### `.jobs(map)`

Defines background jobs that can be processed asynchronously via a queue.

```typescript
const cms = q({ name: "my-cms" })
  .jobs({
    sendEmail: async ({ data, ctx }) => {
      const { to, subject, body } = data;
      await ctx.email.send({ to, subject, body });
    },

    processImage: async ({ data, ctx }) => {
      const { assetId, operations } = data;
      // Process image (resize, optimize, etc.)
    },

    syncInventory: async ({ data, ctx }) => {
      // Sync with external inventory system
    },
  });
```

Jobs are published via the queue:

```typescript
// After build
await cms.queue.sendEmail({
  to: "user@example.com",
  subject: "Welcome!",
  body: "Thanks for signing up.",
});
```

Jobs support scheduling and retry options:

```typescript
.jobs({
  dailyReport: {
    handler: async ({ data, ctx }) => {
      // Generate and send daily report
    },
    options: {
      retryLimit: 3,
      retryDelay: 60000, // 1 minute
    },
  },
})
```

## Configuration Methods

### `.auth(options)`

Configures authentication using Better Auth.

```typescript
const cms = q({ name: "my-cms" })
  .auth({
    secret: process.env.AUTH_SECRET,
    emailAndPassword: { enabled: true },

    // OAuth providers
    socialProviders: {
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET,
      },
      github: {
        clientId: process.env.GITHUB_CLIENT_ID,
        clientSecret: process.env.GITHUB_CLIENT_SECRET,
      },
    },

    // Session configuration
    session: {
      expiresIn: 60 * 60 * 24 * 7, // 7 days
      updateAge: 60 * 60 * 24,     // 1 day
    },

    // Email verification
    emailVerification: {
      sendOnSignUp: true,
      sendVerificationEmail: async ({ user, url }) => {
        await cms.email.send({
          to: user.email,
          subject: "Verify your email",
          template: "email-verification",
          data: { url },
        });
      },
    },
  });
```

| Option | Type | Description |
|--------|------|-------------|
| `secret` | `string` | Secret key for signing tokens |
| `emailAndPassword` | `object` | Enable email/password auth |
| `socialProviders` | `object` | OAuth provider configurations |
| `session` | `object` | Session expiration settings |
| `emailVerification` | `object` | Email verification config |
| `plugins` | `array` | Better Auth plugins |

See [Authentication Guide](/docs/guides/authentication) for complete setup.

### `.locale(config)`

Configures localization for content.

```typescript
const cms = q({ name: "my-cms" })
  .locale({
    locales: [
      { code: "en", label: "English", flagCountryCode: "US" },
      { code: "sk", label: "Slovenčina", flagCountryCode: "SK" },
      { code: "de", label: "Deutsch", flagCountryCode: "DE" },
    ],
    defaultLocale: "en",
    fallbacks: {
      "en-GB": "en",
      "en-US": "en",
      "de-AT": "de",
    },
  });
```

| Option | Type | Description |
|--------|------|-------------|
| `locales` | `Locale[]` or `() => Promise<Locale[]>` | Available locales (static or dynamic) |
| `defaultLocale` | `string` | Fallback locale code |
| `fallbacks` | `Record<string, string>` | Map specific locales to fallbacks |

Each locale object:

| Field | Type | Description |
|-------|------|-------------|
| `code` | `string` | Locale code (e.g., "en", "en-US") |
| `label` | `string` | Display name |
| `flagCountryCode` | `string` | ISO country code for flag display |
| `fallback` | `boolean` | Whether this is a fallback locale |

See [Localization](/docs/backend/localization) for content localization.

### `.emailTemplates(map)`

Defines email templates using React Email components.

```typescript
import { WelcomeEmail } from "./emails/welcome";
import { ResetPasswordEmail } from "./emails/reset-password";

const cms = q({ name: "my-cms" })
  .emailTemplates({
    welcome: WelcomeEmail,
    resetPassword: ResetPasswordEmail,
    orderConfirmation: OrderConfirmationEmail,
  });
```

Templates are rendered when sending emails:

```typescript
await cms.email.send({
  to: "user@example.com",
  subject: "Welcome!",
  template: "welcome",
  data: { name: "John", activationLink: "https://..." },
});
```

### `.messages(translations)`

Adds backend i18n messages for error messages and system text.

```typescript
const cms = q({ name: "my-cms" })
  .messages({
    en: {
      "error.notFound": "Resource not found",
      "error.unauthorized": "You are not authorized",
      "error.validation": "Validation failed",
      "email.welcome.subject": "Welcome to {{ siteName }}",
    },
    sk: {
      "error.notFound": "Zdroj nebol nájdený",
      "error.unauthorized": "Nemáte oprávnenie",
      "error.validation": "Validácia zlyhala",
      "email.welcome.subject": "Vitajte na {{ siteName }}",
    },
  });
```

Messages support interpolation with `{{ variable }}` syntax and plural forms.

Access the translator:

```typescript
const message = cms.t("error.notFound");
const greeting = cms.t("email.welcome.subject", { siteName: "My App" });
const localizedMessage = cms.t("error.notFound", {}, "sk");
```

### `.migrations(list)`

Registers custom database migrations.

```typescript
import { sql } from "drizzle-orm";

const cms = q({ name: "my-cms" })
  .migrations([
    {
      name: "add-full-text-search",
      up: async (db) => {
        await db.execute(sql`
          CREATE INDEX posts_search_idx ON posts
          USING GIN (to_tsvector('english', title || ' ' || content))
        `);
      },
      down: async (db) => {
        await db.execute(sql`DROP INDEX posts_search_idx`);
      },
    },
  ]);
```

## Module Composition

### `.use(module)`

Composes another QUESTPIE builder into the current one. Uses "last wins" override strategy.

```typescript
import { adminModule } from "@questpie/admin/server";

const customModule = q({ name: "custom" })
  .collections({
    products: q.collection("products")
      .fields({ name: text("name") }),
  })
  .jobs({
    syncProducts: async () => { /* ... */ },
  });

const cms = q({ name: "my-cms" })
  .use(adminModule)      // Adds users, assets, auth
  .use(customModule)     // Adds products, syncProducts job
  .collections({
    posts: q.collection("posts")
      .fields({ title: text("title") }),
  })
  .build({...});
```

**Override Strategy:**
- Collections with same name: Later definition wins
- Jobs with same name: Later definition wins
- Auth options: Merged (later options override)
- Messages: Merged (later keys override)
- Globals with same name: Later definition wins

This pattern enables modular CMS architecture:

```typescript
// modules/blog.ts
export const blogModule = q({ name: "blog" })
  .collections({
    posts: postsCollection,
    categories: categoriesCollection,
    tags: tagsCollection,
  })
  .jobs({
    publishScheduledPosts: async () => { /* ... */ },
  });

// modules/ecommerce.ts
export const ecommerceModule = q({ name: "ecommerce" })
  .collections({
    products: productsCollection,
    orders: ordersCollection,
  })
  .jobs({
    processOrder: async () => { /* ... */ },
  });

// cms.ts
const cms = q({ name: "my-cms" })
  .use(adminModule)
  .use(blogModule)
  .use(ecommerceModule)
  .build({...});
```

## Runtime Creation

### `.build(config)`

Creates the final `Questpie` runtime instance. This is **required** for the backend builder (unlike the admin builder).

```typescript
const cms = q({ name: "my-cms" })
  .collections({...})
  .build({
    // Required: Database connection
    db: {
      url: process.env.DATABASE_URL,
      // Or use PGlite for local development
      // pglite: true,
    },

    // Optional: File storage
    storage: {
      default: "local",
      disks: {
        local: {
          driver: "fs",
          root: "./uploads",
          urlBuilder: (key) => `/uploads/${key}`,
        },
        s3: {
          driver: "s3",
          bucket: "my-bucket",
          region: "us-east-1",
        },
      },
    },

    // Optional: Email service
    email: {
      adapter: new SmtpAdapter({
        host: "smtp.example.com",
        port: 587,
        auth: { user: "...", pass: "..." },
      }),
      from: "noreply@example.com",
    },

    // Optional: Job queue
    queue: {
      adapter: pgBossAdapter(),
    },

    // Optional: Search engine
    search: {
      adapter: meilisearchAdapter({
        host: "http://localhost:7700",
        apiKey: "...",
      }),
    },

    // Optional: Logging
    logger: {
      level: "info",
    },

    // Optional: Key-value store
    kv: {
      adapter: redisAdapter({
        url: process.env.REDIS_URL,
      }),
    },

    // Optional: Realtime updates
    realtime: {
      enabled: true,
    },
  });
```

| Option | Type | Description |
|--------|------|-------------|
| `db` | `{ url: string }` or `{ pglite: true }` | Database connection |
| `storage` | `StorageConfig` | File storage configuration |
| `email` | `EmailConfig` | Email service configuration |
| `queue` | `QueueConfig` | Background job queue |
| `search` | `SearchConfig` | Full-text search engine |
| `logger` | `LoggerConfig` | Logging configuration |
| `kv` | `KVConfig` | Key-value store |
| `realtime` | `RealtimeConfig` | Real-time updates via PostgreSQL NOTIFY |

## Runtime Instance

After calling `.build()`, you have access to the `Questpie` instance:

### Properties

```typescript
cms.config       // The resolved configuration
cms.db           // Drizzle ORM client
cms.auth         // Better Auth instance
cms.storage      // File storage (Flydrive)
cms.queue        // Job queue (pg-boss)
cms.email        // Email service
cms.kv           // Key-value store
cms.logger       // Logger
cms.search       // Search service
cms.realtime     // Realtime service
```

### Collections & Globals

```typescript
// Access collection metadata
cms.collections.posts.table      // Drizzle table
cms.collections.posts.name       // "posts"
cms.collections.posts.fields     // Field definitions

// Access global metadata
cms.globals.settings.table       // Drizzle table
cms.globals.settings.name        // "settings"
```

### API Operations

```typescript
// Collection CRUD
await cms.api.collections.posts.find({ where: { published: true } });
await cms.api.collections.posts.create({ title: "Hello" });
await cms.api.collections.posts.update(id, { published: true });
await cms.api.collections.posts.delete(id);

// Global operations
await cms.api.globals.settings.get();
await cms.api.globals.settings.update({ siteName: "My Site" });

// RPC functions
await cms.api.functions.sendNewsletter({ subject: "..." });
```

### Methods

```typescript
// Translation
cms.t(key, params?, locale?)

// Context creation (for middleware)
const ctx = await cms.createContext({ session });

// Get schema information
cms.getLocales()
cms.getCollections()
cms.getGlobals()
cms.getFunctions()
cms.getTables()
cms.getSchema()

// Start job worker
cms.listenToJobs({ concurrency: 5 });
```

### Migrations API

```typescript
// Run all pending migrations
await cms.migrations.migrate();

// Get migration status
const status = await cms.migrations.status();

// Rollback last migration
await cms.migrations.rollback();
```

## Type Export

Export the CMS type for use in client code and admin configuration:

```typescript
// cms.ts
export const cms = q({ name: "my-cms" })
  .collections({...})
  .build({...});

export type AppCMS = typeof cms;
```

Use in admin:

```typescript
// admin.ts
import type { AppCMS } from "./cms";

const admin = qa<AppCMS>()
  .collections({
    // Type-safe collection references
    posts: qa.collection("posts")  // ← Autocomplete!
      .fields(({ r }) => ({...})),
  });
```

## Next Steps

<Cards>
  <Card href="/docs/backend/collections" title="Collections" description="Define data models" />
  <Card href="/docs/backend/crud-operations" title="CRUD Operations" description="Query and mutate data" />
  <Card href="/docs/backend/validation" title="Validation" description="Zod schema validation" />
  <Card href="/docs/backend/modules" title="Modules" description="Compose features" />
</Cards>
