---
title: CRUD Operations
description: Type-safe database operations for collections and globals
---

# CRUD Operations

QUESTPIE provides a type-safe CRUD API for all collections and globals. Operations are accessible via `cms.api.collections.<name>` and `cms.api.globals.<name>`.

## Collection Operations

### `find(options?)`

Query multiple records with filtering, sorting, pagination, and relation loading.

```typescript
const { docs, totalDocs } = await cms.api.collections.posts.find({
  where: {
    published: true,
    category: { name: { eq: "Technology" } },
  },
  orderBy: { publishedAt: "desc" },
  limit: 10,
  offset: 0,
  columns: { id: true, title: true, slug: true },
  with: {
    author: true,
    tags: { limit: 5 },
  },
});
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `where` | `Where<TFields, TRelations>` | Filter conditions |
| `orderBy` | `OrderBy<TFields>` | Sort order |
| `limit` | `number` | Max records to return |
| `offset` | `number` | Records to skip (pagination) |
| `columns` | `Columns<TFields>` | Field selection |
| `with` | `With<TRelations>` | Relations to load |
| `locale` | `string` | Content locale |
| `localeFallback` | `boolean` | Fallback to default locale |

**Returns:** `PaginatedResult<T>` with:
- `docs: T[]` - The records
- `totalDocs: number` - Total count matching query
- `limit: number` - Requested limit
- `totalPages: number` - Total pages
- `page: number` - Current page
- `hasPrevPage: boolean` - Has previous page
- `hasNextPage: boolean` - Has next page
- `prevPage: number | null` - Previous page number
- `nextPage: number | null` - Next page number

### `findOne(options?)`

Query a single record.

```typescript
const post = await cms.api.collections.posts.findOne({
  where: { slug: "hello-world" },
  with: { author: true },
});

if (post) {
  console.log(post.title);
}
```

**Returns:** `T | null`

### `count(options?)`

Count matching records.

```typescript
const total = await cms.api.collections.posts.count({
  where: { published: true },
});
```

**Returns:** `number`

### `create(data)`

Create a new record.

```typescript
const post = await cms.api.collections.posts.create({
  title: "Hello World",
  slug: "hello-world",
  content: "Welcome to my blog!",
  published: false,
});
```

Create with relation connections:

```typescript
const post = await cms.api.collections.posts.create({
  title: "My Post",
  // Connect to existing author
  author: { connect: { id: "user-123" } },
  // Create new tags
  tags: {
    create: [
      { name: "TypeScript" },
      { name: "CMS" },
    ],
  },
  // Connect or create category
  category: {
    connectOrCreate: {
      where: { slug: "tech" },
      create: { name: "Technology", slug: "tech" },
    },
  },
});
```

**Options:**

| Option | Type | Description |
|--------|------|-------------|
| `locale` | `string` | Locale for localized fields |

**Returns:** `T` (created record)

### `updateById(params)`

Update a single record by ID.

```typescript
await cms.api.collections.posts.updateById({
  id: "post-123",
  data: {
    title: "Updated Title",
    published: true,
    publishedAt: new Date(),
  },
});
```

Update with relation mutations:

```typescript
await cms.api.collections.posts.updateById({
  id: "post-123",
  data: {
    // Disconnect current author
    author: { disconnect: true },
    // Add new tags
    tags: {
      connect: [{ id: "tag-1" }, { id: "tag-2" }],
      disconnect: [{ id: "tag-old" }],
    },
  },
});
```

**Returns:** `T` (updated record)

### `update(params)`

Update multiple records matching a where clause.

```typescript
const updated = await cms.api.collections.posts.update({
  where: { status: "draft", authorId: "user-123" },
  data: { status: "archived" },
});
```

**Returns:** `T[]` (array of updated records)

### `deleteById(params)`

Delete a single record by ID. Uses soft-delete if enabled on the collection.

```typescript
await cms.api.collections.posts.deleteById({ id: "post-123" });
```

**Returns:** `{ success: boolean }`

### `delete(params)`

Delete multiple records matching a where clause.

```typescript
await cms.api.collections.posts.delete({
  where: { status: "archived", createdAt: { lt: oneYearAgo } },
});
```

**Returns:** `{ success: boolean, count: number }`

### `restoreById(params)`

Restore a soft-deleted record by ID.

```typescript
await cms.api.collections.posts.restoreById({ id: "post-123" });
```

**Returns:** `T` (restored record)

### `upload(file, context?, additionalData?)`

Upload a file to a collection with upload enabled.

```typescript
const asset = await cms.api.collections.assets.upload(file);
console.log(asset.url);
```

With additional data:

```typescript
const asset = await cms.api.collections.assets.upload(file, ctx, {
  alt: "Product image",
  folder: "products",
});
```

### `uploadMany(files, context?, additionalData?)`

Upload multiple files at once.

```typescript
const assets = await cms.api.collections.assets.uploadMany(files);
```

### `findVersions(options)`

Get version history for a record (requires versioning enabled).

```typescript
const versions = await cms.api.collections.posts.findVersions({
  id: "post-123",
  limit: 10,
  offset: 0,
});

// versions contains version metadata
versions.forEach(v => {
  console.log(v.versionNumber, v.versionOperation, v.versionCreatedAt);
});
```

**Returns:** `VersionRecord[]` with:
- `id` - Record ID
- `versionId` - Unique version ID
- `versionNumber` - Sequential version number
- `versionOperation` - Operation type ("create", "update", "revert")
- `versionUserId` - User who made the change (if available)
- `versionCreatedAt` - When the version was created
- Plus all field values at that version

### `revertToVersion(options)`

Revert a record to a specific version.

```typescript
const reverted = await cms.api.collections.posts.revertToVersion({
  id: "post-123",
  version: 2,  // Revert to version number 2
});

// Or by version ID
const reverted = await cms.api.collections.posts.revertToVersion({
  id: "post-123",
  versionId: "version-uuid",
});
```

**Returns:** `T` (the record with restored content)

## Global Operations

### `get(options?)`

Get the global singleton record.

```typescript
const settings = await cms.api.globals.settings.get();
console.log(settings.siteName);
```

With locale:

```typescript
const settings = await cms.api.globals.settings.get({
  locale: "sk",
});
```

**Returns:** `T` (the global record)

### `update(data)`

Update the global record.

```typescript
await cms.api.globals.settings.update({
  siteName: "My New Site",
  description: "A great website",
});
```

**Returns:** `T` (updated record)

## Where Clause

The `where` clause supports various operators for filtering.

### Basic Equality

```typescript
where: {
  status: "published",           // Equals (shorthand)
  status: { eq: "published" },   // Equals (explicit)
}
```

### Comparison Operators

```typescript
where: {
  price: { gt: 100 },            // Greater than
  price: { gte: 100 },           // Greater than or equal
  price: { lt: 500 },            // Less than
  price: { lte: 500 },           // Less than or equal
  price: { ne: 0 },              // Not equal
}
```

### String Operators

```typescript
where: {
  title: { like: "%hello%" },        // SQL LIKE
  title: { ilike: "%hello%" },       // Case-insensitive LIKE
  title: { contains: "hello" },      // Contains substring
  title: { startsWith: "Hello" },    // Starts with
  title: { endsWith: "world" },      // Ends with
}
```

### Array Operators

```typescript
where: {
  status: { in: ["draft", "published"] },    // In array
  status: { notIn: ["archived", "deleted"] }, // Not in array
  tags: { arrayOverlaps: ["featured"] },      // Array contains any
  tags: { arrayContains: ["premium"] },       // Array contains all
}
```

### Null Checks

```typescript
where: {
  deletedAt: { isNull: true },     // IS NULL
  publishedAt: { isNull: false },  // IS NOT NULL
}
```

### Relation Filtering

Filter by related records:

```typescript
where: {
  // Filter posts by author name
  author: {
    name: { contains: "John" },
  },
  // Filter posts that have tags
  tags: {
    some: { name: "featured" },
  },
}
```

### Logical Operators

Combine conditions with AND, OR, NOT:

```typescript
where: {
  AND: [
    { published: true },
    { OR: [
      { featured: true },
      { viewCount: { gt: 1000 } },
    ]},
  ],
}
```

```typescript
where: {
  NOT: { status: "draft" },
}
```

## OrderBy Clause

Sort results by one or more fields.

### Single Field

```typescript
orderBy: { createdAt: "desc" }
```

### Multiple Fields

```typescript
orderBy: [
  { featured: "desc" },
  { publishedAt: "desc" },
  { title: "asc" },
]
```

### Nulls Position

```typescript
orderBy: {
  publishedAt: { sort: "desc", nulls: "last" },
}
```

### Order by Relation

```typescript
orderBy: {
  author: { name: "asc" },
}
```

## Columns Selection

Select specific fields to return.

### Include Mode

Only return specified fields:

```typescript
columns: {
  id: true,
  title: true,
  slug: true,
}
```

### Exclude Mode

Return all fields except specified:

```typescript
columns: {
  content: false,
  internalNotes: false,
}
```

## Loading Relations

Use `with` to eagerly load related records.

### Basic Loading

```typescript
with: {
  author: true,
  category: true,
}
```

### Nested Options

```typescript
with: {
  author: {
    columns: { id: true, name: true, avatar: true },
  },
  tags: {
    limit: 10,
    orderBy: { name: "asc" },
  },
  comments: {
    where: { approved: true },
    limit: 5,
    orderBy: { createdAt: "desc" },
    with: {
      author: true,  // Nested relation loading
    },
  },
}
```

### Aggregations

Get aggregate counts on relations:

```typescript
with: {
  _count: {
    comments: true,
    likes: true,
  },
}
```

The result includes `_count.comments` and `_count.likes`.

### Other Aggregations

```typescript
with: {
  _sum: { lineItems: { columns: { amount: true } } },
  _avg: { reviews: { columns: { rating: true } } },
  _min: { bids: { columns: { amount: true } } },
  _max: { bids: { columns: { amount: true } } },
}
```

## Nested Relation Mutations

When creating or updating records, you can mutate relations in the same operation.

### Connect

Link to existing records:

```typescript
await cms.api.collections.posts.create({
  title: "My Post",
  author: { connect: { id: "user-123" } },
  tags: { connect: [{ id: "tag-1" }, { id: "tag-2" }] },
});
```

### Create

Create new related records:

```typescript
await cms.api.collections.posts.create({
  title: "My Post",
  author: {
    create: {
      name: "John Doe",
      email: "john@example.com",
    },
  },
  tags: {
    create: [
      { name: "TypeScript" },
      { name: "CMS" },
    ],
  },
});
```

### Connect or Create

Connect if exists, otherwise create:

```typescript
await cms.api.collections.posts.create({
  title: "My Post",
  category: {
    connectOrCreate: {
      where: { slug: "technology" },
      create: { name: "Technology", slug: "technology" },
    },
  },
});
```

### Disconnect

Remove relation link:

```typescript
await cms.api.collections.posts.update("post-123", {
  author: { disconnect: true },
});
```

### Set

Replace all relations:

```typescript
await cms.api.collections.posts.update("post-123", {
  tags: {
    set: [{ id: "tag-1" }, { id: "tag-2" }],
  },
});
```

## Context Parameter

All CRUD operations accept an optional context parameter for access control.

```typescript
// Create context from request
const ctx = await cms.createContext({
  session: await getSession(request),
});

// Pass context to operations
const posts = await cms.api.collections.posts.find(
  { where: { published: true } },
  ctx
);

// Context affects access control
// - System mode: Full access
// - User mode: Applies collection access rules
```

### Access Modes

```typescript
// System access (bypasses access control)
const ctx = await cms.createContext({
  accessMode: "system",
});

// User access (applies access control)
const ctx = await cms.createContext({
  session: userSession,
  accessMode: "user",  // default
});
```

## Localized Content

Operations support locale-specific content.

### Query with Locale

```typescript
// Get content in Slovak
const posts = await cms.api.collections.posts.find({
  where: { published: true },
  locale: "sk",
});

// Fallback to default locale if translation missing
const posts = await cms.api.collections.posts.find({
  locale: "sk",
  localeFallback: true,
});
```

### Create with Locale

```typescript
// Create English content
await cms.api.collections.posts.create({
  title: "Hello World",
  content: "English content",
}, { locale: "en" });

// Create Slovak translation
await cms.api.collections.posts.update(postId, {
  title: "Ahoj svet",
  content: "Slovenský obsah",
}, { locale: "sk" });
```

## Error Handling

CRUD operations throw typed errors that can be caught and handled.

```typescript
import { QuestpieError, NotFoundError, ValidationError } from "questpie";

try {
  await cms.api.collections.posts.update("invalid-id", { title: "" });
} catch (error) {
  if (error instanceof NotFoundError) {
    console.log("Post not found");
  } else if (error instanceof ValidationError) {
    console.log("Validation failed:", error.fieldErrors);
  } else if (error instanceof QuestpieError) {
    console.log("CMS error:", error.code, error.message);
  }
}
```

### Common Error Codes

| Code | Description |
|------|-------------|
| `NOT_FOUND` | Record with given ID not found |
| `VALIDATION_ERROR` | Input failed validation |
| `UNAUTHORIZED` | User not authenticated |
| `FORBIDDEN` | User lacks permission |
| `CONFLICT` | Unique constraint violation |

## Type Safety

All operations are fully type-safe based on your collection definitions.

```typescript
// TypeScript knows the shape of posts
const { docs } = await cms.api.collections.posts.find();
//     ^? { id: string, title: string, content: string | null, ... }[]

// Autocomplete for where clauses
await cms.api.collections.posts.find({
  where: {
    title: { contains: "hello" },  // ← Autocomplete!
    author: {
      name: { eq: "John" },        // ← Relation fields!
    },
  },
});

// Type errors for invalid fields
await cms.api.collections.posts.create({
  titl: "Typo",  // ← TypeScript error!
});
```

## Next Steps

<Cards>
  <Card href="/docs/backend/client-sdk" title="Client SDK" description="Type-safe API from the browser" />
  <Card href="/docs/backend/validation" title="Validation" description="Zod schema validation" />
  <Card href="/docs/backend/hooks" title="Hooks" description="Lifecycle hooks" />
  <Card href="/docs/backend/access-control" title="Access Control" description="Permission rules" />
</Cards>
