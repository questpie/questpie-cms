---
title: Context
description: Understanding request context and how to access typed app services.
---

QUESTPIE provides typed context access through the `getContext<TApp>()` helper. This allows you to access the app instance, session, database, and other request information with full TypeScript support.

## Why Context Matters

In a typical request flow, you might need to:

- Access the current user in a hook
- Send an email from a job handler
- Query another collection from within a function
- Access the database client for custom queries

Instead of passing the app instance through every function, QUESTPIE provides `getContext<TApp>()` that gives you fully typed access to everything.

## The `getContext<TApp>()` Helper

The new `getContext<TApp>()` helper provides fully typed access to your app, session, database, and more:

```typescript
import { getContext } from "questpie";
import type { AppCMS } from "./app";

// In hooks, access control, or functions
const { app, session, db, locale, accessMode } = getContext<AppCMS>(ctx);

// Now you have full type-safe access:
await app.api.collections.posts.find();
await app.queue.sendNotification.publish({ userId: "123" });
app.logger.info("Something happened");

// Database is fully typed with Drizzle
const result = await db.query.users.findMany();
```

### What's Available in Context

```typescript
interface ContextReturn<TApp> {
  app: TApp; // Your typed CMS instance
  session: InferSessionFromApp<TApp>; // Better Auth session (or null/undefined)
  db: InferDbFromApp<TApp>; // Drizzle client
  locale: string | undefined; // Current locale
  accessMode: "user" | "system"; // Access mode
}
```

## Usage Patterns

### 1. Explicit Pattern (Recommended)

Pass the context object directly - this is the clearest and most explicit approach:

```typescript
import { getContext } from "questpie";
import type { AppCMS } from "./app";

// In access control
q.collection("posts")
  .access({
    read: (ctx) => {
      const { session, app } = getContext<AppCMS>(ctx);

      // Check user role
      if (session?.user.role === "admin") return true;

      // Check ownership
      return ctx.row.authorId === session?.user.id;
    },
  });

// In hooks
q.collection("posts").hooks({
  afterChange: async (ctx) => {
    const { app, session, db } = getContext<AppCMS>(ctx);

    // Access queue
    await app.queue.notify.publish({ postId: ctx.data.id });

    // Access database
    await db.insert(auditLog).values({ ... });
  },
});
```

### 2. Implicit Pattern (Via AsyncLocalStorage)

For reusable functions, you can call `getContext()` without parameters to retrieve from AsyncLocalStorage:

```typescript
// Reusable helper - no context parameter needed!
async function logActivity(message: string) {
  const { db, session, app } = getContext<AppCMS>();

  await db.insert(activityLog).values({
    message,
    userId: session?.user.id,
    timestamp: new Date(),
  });
}

// Use in hooks - context flows automatically
q.collection("posts").hooks({
  afterChange: async ({ data }) => {
    await logActivity(`Post ${data.id} created`);
  },
});
```

**Important:** The implicit pattern only works when called within a CRUD operation, hook, or `runWithContext()` scope. If called outside, it throws an error.

### 3. `runWithContext()` for Manual Scoping

For advanced use cases, you can manually run code within a request-scoped context:

```typescript
import { runWithContext, getContext } from "questpie";
import type { AppCMS } from "./app";

// Create your own context scope
await runWithContext(
  {
    app: cms,
    session: { user: { id: "123", role: "admin" } },
    db: cms.db,
    locale: "en",
    accessMode: "system",
  },
  async () => {
    // Inside here, getContext<AppCMS>() works without parameters
    const { app, session } = getContext<AppCMS>();

    await app.api.collections.posts.find();
    console.log(session?.user.id);
  },
);
```

## Smart Type Inference

`getContext()` returns only what you pass to it - enabling smart type inference:

```typescript
// If you only pass session:
const { session } = getContext<AppCMS>({ session: ctx.session });
// session is typed, but app and db are `never` (can't access what you didn't provide)

// Full context:
const { app, session, db, locale, accessMode } = getContext<AppCMS>(ctx);
// Everything is typed

// Implicit (from AsyncLocalStorage) - gives you everything:
const { app, session, db, locale, accessMode } = getContext<AppCMS>();
```

## Where Context is Available

Context is automatically set up in these scenarios:

### HTTP Requests

When a request comes through the adapter, context is automatically created:

```typescript
// In Hono
server.use(questpieMiddleware(app));

server.get("/api/custom", async (c) => {
  // Inside handlers, CRUD operations automatically set up context
  const posts = await app.api.collections.posts.find();
  // Hooks called during find() can use getContext()
});
```

### Collection Hooks

All hooks run within `runWithContext` scope:

```typescript
q.collection("posts").hooks({
  afterChange: async (ctx) => {
    const { app, session, db } = getContext<AppCMS>(ctx);

    await app.queue.postCreated.publish({ postId: ctx.data.id });
  },
});
```

### Custom Functions

Functions execute within context:

```typescript
q.fn({
  schema: z.object({ postId: z.string() }),
  handler: async (input, ctx) => {
    const { app, session, db } = getContext<AppCMS>(ctx);

    if (!session) {
      throw new Error("Must be authenticated");
    }

    return { success: true };
  },
});
```

### Job Handlers

Jobs run with a fresh context:

```typescript
q.job({
  name: "send-email",
  schema: z.object({ to: z.string(), subject: z.string() }),
  handler: async (payload, ctx) => {
    const { app } = getContext<AppCMS>(ctx);

    await app.email.send({
      to: payload.to,
      subject: payload.subject,
      html: "<p>Hello</p>",
    });
  },
});
```

## Migration from Old API

If you're using the old `getAppFromContext()` and `getRequestContext()` functions:

**Before (deprecated):**

```typescript
import { getAppFromContext, getRequestContext } from "questpie";

const app = getAppFromContext();
const ctx = getRequestContext();
```

**After (new):**

```typescript
import { getContext } from "questpie";
import type { AppCMS } from "./app";

// Explicit - pass context
const { app, session, db, locale, accessMode } = getContext<AppCMS>(ctx);

// Or implicit - from AsyncLocalStorage
const { app, session, db, locale, accessMode } = getContext<AppCMS>();
```

## Access Modes

The `accessMode` in context controls how access control is applied:

### `"user"` Mode

Access control rules are enforced based on the current user:

```typescript
const { accessMode } = getContext<AppCMS>(ctx);
// accessMode === "user" means access control is enforced
```

### `"system"` Mode

Access control is bypassed - full access to all data:

```typescript
const { accessMode } = getContext<AppCMS>(ctx);
// accessMode === "system" means full access, no restrictions
```

## Best Practices

### 1. Always Pass Context Explicitly in Access Control

```typescript
// Good - explicit, type-safe
.access({
  read: (ctx) => {
    const { session } = getContext<AppCMS>(ctx);
    return session?.user.role === "admin";
  },
});
```

### 2. Use Implicit Pattern Only in Reusable Helpers

```typescript
// Good - helper doesn't need context parameter
async function logActivity(message: string) {
  const { db, session } = getContext<AppCMS>();
  // ...
}

// Bad - requiring context parameter is verbose
async function logActivity(ctx: any, message: string) {
  const { db, session } = getContext<AppCMS>(ctx);
  // ...
}
```

### 3. Handle Missing Session

```typescript
handler: async (input, ctx) => {
  const { session } = getContext<AppCMS>(ctx);

  if (!session) {
    throw new Error("Authentication required");
  }

  // Now TypeScript knows session is defined
  console.log(session.user.id);
};
```

## Related

- [Hooks](/docs/backend/hooks) - Add business logic
- [Access Control](/docs/backend/access-control) - Secure operations
- [Queue Jobs](/docs/guides/queue-jobs) - Background processing
- [Default Access](/docs/backend/access-control#default-access) - Global access defaults
