---
title: Custom Modules
description: Create reusable CMS modules
---

# Custom Modules

Create your own modules to organize features, share functionality across projects, and build a modular CMS architecture.

## Creating a Module

A module is a QUESTPIE builder that can be composed with `.use()`:

```typescript
// modules/blog/index.ts
import { q, text, boolean, datetime, integer } from "questpie";

export const blogModule = q({ name: "blog" })
  .collections({
    posts: q.collection("posts")
      .fields({
        title: text("title").notNull(),
        slug: text("slug").notNull().unique(),
        content: text("content"),
        excerpt: text("excerpt"),
        published: boolean("published").default(false),
        publishedAt: datetime("publishedAt"),
        viewCount: integer("viewCount").default(0),
      })
      .options({ timestamps: true, softDelete: true })
      .title(({ f }) => f.title),

    categories: q.collection("categories")
      .fields({
        name: text("name").notNull(),
        slug: text("slug").notNull().unique(),
        description: text("description"),
      })
      .title(({ f }) => f.name),

    tags: q.collection("tags")
      .fields({
        name: text("name").notNull(),
        slug: text("slug").notNull().unique(),
      })
      .title(({ f }) => f.name),
  })
  .jobs({
    publishScheduledPosts: async ({ ctx }) => {
      const now = new Date();
      const { docs } = await ctx.cms.api.collections.posts.find({
        where: {
          published: false,
          publishedAt: { lte: now },
        },
      });

      for (const post of docs) {
        await ctx.cms.api.collections.posts.updateById({
          id: post.id,
          data: { published: true },
        });
      }

      return { published: docs.length };
    },
  });
```

## Module Structure

Organize larger modules in directories:

```
modules/
└── blog/
    ├── index.ts          # Module export
    ├── collections/
    │   ├── posts.ts
    │   ├── categories.ts
    │   └── tags.ts
    ├── jobs/
    │   └── scheduler.ts
    └── messages/
        └── en.ts
```

### Module Entry Point

```typescript
// modules/blog/index.ts
import { q } from "questpie";
import { postsCollection } from "./collections/posts";
import { categoriesCollection } from "./collections/categories";
import { tagsCollection } from "./collections/tags";
import { blogJobs } from "./jobs/scheduler";
import { blogMessages } from "./messages/en";

export const blogModule = q({ name: "blog" })
  .collections({
    posts: postsCollection,
    categories: categoriesCollection,
    tags: tagsCollection,
  })
  .jobs(blogJobs)
  .messages(blogMessages);
```

### Collection Files

```typescript
// modules/blog/collections/posts.ts
import { q, text, boolean, datetime, integer, varchar } from "questpie";

export const postsCollection = q.collection("posts")
  .fields({
    title: text("title").notNull(),
    slug: text("slug").notNull().unique(),
    content: text("content"),
    excerpt: text("excerpt"),
    authorId: varchar("authorId", { length: 255 }),
    categoryId: varchar("categoryId", { length: 255 }),
    published: boolean("published").default(false),
    publishedAt: datetime("publishedAt"),
    viewCount: integer("viewCount").default(0),
  })
  .options({ timestamps: true, softDelete: true, versioning: true })
  .localized(["title", "content", "excerpt"])
  .relations(({ one, many }) => ({
    author: one("user", {
      fields: ["authorId"],
      references: ["id"],
    }),
    category: one("categories", {
      fields: ["categoryId"],
      references: ["id"],
    }),
    tags: many("tags"),
  }))
  .searchable({
    content: (record) => `${record.title} ${record.content}`,
    metadata: (record) => ({
      published: record.published,
      category: record.categoryId,
    }),
  })
  .validation({
    exclude: { id: true, createdAt: true, updatedAt: true },
    refine: {
      title: (s) => s.min(1).max(200),
      slug: (s) => s.regex(/^[a-z0-9-]+$/),
    },
  })
  .hooks({
    beforeCreate: async ({ data }) => {
      if (!data.slug && data.title) {
        data.slug = data.title
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/(^-|-$)/g, "");
      }
      return data;
    },
  })
  .title(({ f }) => f.title);
```

## Module with Relations

When modules need to reference collections from other modules:

```typescript
// modules/ecommerce/collections/orders.ts
import { q, varchar, integer, jsonb, datetime } from "questpie";

export const ordersCollection = q.collection("orders")
  .fields({
    orderNumber: varchar("orderNumber", { length: 50 }).notNull().unique(),
    status: varchar("status", { length: 50 }).default("pending"),
    customerId: varchar("customerId", { length: 255 }),
    items: jsonb("items"),
    total: integer("total").default(0),
    placedAt: datetime("placedAt"),
  })
  .options({ timestamps: true })
  .relations(({ one }) => ({
    // Reference 'user' from starter module
    customer: one("user", {
      fields: ["customerId"],
      references: ["id"],
    }),
  }))
  .title(({ f }) => f.orderNumber);
```

The relation will resolve when composed with the starter module:

```typescript
const cms = q({ name: "my-cms" })
  .use(starterModule)      // Provides 'user' collection
  .use(ecommerceModule)    // References 'user' in relations
  .build({...});
```

## Module with Globals

Include singleton configuration:

```typescript
export const blogModule = q({ name: "blog" })
  .collections({...})
  .globals({
    blogSettings: q.global("blogSettings")
      .fields({
        postsPerPage: integer("postsPerPage").default(10),
        allowComments: boolean("allowComments").default(true),
        moderateComments: boolean("moderateComments").default(false),
        featuredCategory: varchar("featuredCategory", { length: 255 }),
      }),
  });
```

## Module with Auth Extensions

Extend auth configuration:

```typescript
export const adminModule = q({ name: "admin" })
  .collections({...})
  .auth({
    // Extends base auth config
    session: {
      expiresIn: 60 * 60 * 24 * 7, // 7 days for admin
    },
    // Add admin-specific plugins
    plugins: [
      adminDashboardPlugin(),
    ],
  });
```

## Module with Messages

Include i18n messages:

```typescript
export const blogModule = q({ name: "blog" })
  .collections({...})
  .messages({
    en: {
      "blog.posts.created": "Post created successfully",
      "blog.posts.published": "Post published",
      "blog.posts.unpublished": "Post unpublished",
      "blog.comments.moderated": "Comment requires moderation",
      "blog.error.slugTaken": "This slug is already in use",
    },
    sk: {
      "blog.posts.created": "Príspevok bol úspešne vytvorený",
      "blog.posts.published": "Príspevok bol publikovaný",
      "blog.posts.unpublished": "Príspevok bol odpublikovaný",
      "blog.comments.moderated": "Komentár vyžaduje moderáciu",
      "blog.error.slugTaken": "Tento slug už je používaný",
    },
  });
```

## Module with Email Templates

Include email templates:

```typescript
import { NewPostNotification } from "./emails/new-post";
import { CommentNotification } from "./emails/comment";

export const blogModule = q({ name: "blog" })
  .collections({...})
  .emailTemplates({
    blogNewPost: NewPostNotification,
    blogComment: CommentNotification,
  });
```

## Publishing Modules

Share modules as npm packages:

```typescript
// @myorg/cms-blog/src/index.ts
export { blogModule } from "./module";
export { postsCollection } from "./collections/posts";
export { categoriesCollection } from "./collections/categories";
```

```json
// @myorg/cms-blog/package.json
{
  "name": "@myorg/cms-blog",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "peerDependencies": {
    "questpie": "^1.0.0"
  }
}
```

Usage:

```typescript
import { blogModule } from "@myorg/cms-blog";

const cms = q({ name: "my-cms" })
  .use(starterModule)
  .use(blogModule)
  .build({...});
```

## Module Configuration

Make modules configurable:

```typescript
// modules/blog/index.ts
export function createBlogModule(options: {
  enableComments?: boolean;
  postsPerPage?: number;
  enableVersioning?: boolean;
} = {}) {
  const {
    enableComments = true,
    postsPerPage = 10,
    enableVersioning = true,
  } = options;

  const postsCollection = q.collection("posts")
    .fields({...})
    .options({
      timestamps: true,
      versioning: enableVersioning,
    });

  return q({ name: "blog" })
    .collections({
      posts: postsCollection,
      ...(enableComments ? { comments: commentsCollection } : {}),
    })
    .globals({
      blogSettings: q.global("blogSettings")
        .fields({
          postsPerPage: integer("postsPerPage").default(postsPerPage),
          allowComments: boolean("allowComments").default(enableComments),
        }),
    });
}
```

Usage:

```typescript
const cms = q({ name: "my-cms" })
  .use(starterModule)
  .use(createBlogModule({
    enableComments: false,
    postsPerPage: 20,
  }))
  .build({...});
```

## Testing Modules

Test modules in isolation:

```typescript
// modules/blog/blog.test.ts
import { describe, test, expect } from "bun:test";
import { q } from "questpie";
import { blogModule } from "./index";

describe("blogModule", () => {
  const testCms = q({ name: "test" })
    .use(blogModule)
    .build({ db: { pglite: true } });

  test("creates posts", async () => {
    const post = await testCms.api.collections.posts.create({
      title: "Test Post",
      slug: "test-post",
    });

    expect(post.id).toBeDefined();
    expect(post.title).toBe("Test Post");
  });

  test("auto-generates slug", async () => {
    const post = await testCms.api.collections.posts.create({
      title: "Hello World",
    });

    expect(post.slug).toBe("hello-world");
  });
});
```

## Best Practices

### 1. Single Responsibility

Each module should handle one domain:

```typescript
// Good: Focused modules
blogModule      // Posts, categories, tags
ecommerceModule // Products, orders, cart
analyticsModule // Page views, events, reports

// Avoid: Kitchen sink modules
everythingModule // Does too much
```

### 2. Explicit Dependencies

Document what collections your module expects:

```typescript
/**
 * E-commerce module
 *
 * Dependencies:
 * - Requires `user` collection from starterModule
 * - Requires `assets` collection for product images
 */
export const ecommerceModule = q({ name: "ecommerce" })
  .collections({...});
```

### 3. Namespaced Messages

Prefix messages to avoid conflicts:

```typescript
.messages({
  en: {
    "blog.posts.created": "...",      // Good: namespaced
    "ecommerce.order.placed": "...",  // Good: namespaced
    "created": "...",                 // Bad: may conflict
  },
})
```

### 4. Configurable Defaults

Provide sensible defaults with override capability:

```typescript
export function createModule(options = {}) {
  const config = {
    enableFeature: true,
    maxItems: 100,
    ...options,  // Allow overrides
  };
  // ...
}
```

## Next Steps

<Cards>
  <Card href="/docs/backend/modules/starter-module" title="Starter Module" description="Built-in auth and assets" />
  <Card href="/docs/backend/builder-api" title="Builder API" description="Full builder reference" />
  <Card href="/docs/backend/collections" title="Collections" description="Collection definitions" />
</Cards>
