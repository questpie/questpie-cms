---
title: Overview
description: Introduction to QUESTPIE CMS - A batteries-included, type-safe headless CMS built for modern TypeScript applications.
---

# QUESTPIE CMS Overview

QUESTPIE CMS is a **batteries-included**, **type-safe** headless CMS designed for developers who want to build content-heavy applications without wrestling with boilerplate, infrastructure, or fragmented ecosystems.

## What is QUESTPIE CMS?

QUESTPIE CMS is a content management system that:

- **Runs in your codebase** - Not a hosted service, not a monolithic platform
- **Integrates seamlessly** - Built for Hono, Elysia, and other modern TypeScript frameworks
- **Provides everything you need** - Auth, storage, queues, email, search - all integrated out of the box
- **Enforces type safety** - From database schema to API responses, fully typed with TypeScript
- **Scales with you** - From prototypes to production, from solo projects to team applications

Think of it as **Payload CMS philosophy** meets **Drizzle ORM simplicity** with **integrated services** for the modern TypeScript ecosystem.

## Philosophy

### Batteries Included, Not Batteries Required

Unlike generic CMS frameworks that leave you to wire together auth, storage, queues, and email yourself, QUESTPIE comes with **opinionated, best-in-class integrations**:

- **Better Auth** for authentication
- **Flydrive** for file storage (S3, R2, local)
- **pg-boss** for background job processing
- **Nodemailer + React Email** for transactional emails
- **Pino** for structured logging

You can still swap these out, but the defaults are production-ready and work together seamlessly.

### Type Safety from Database to API

QUESTPIE leverages **Drizzle ORM** and **advanced TypeScript inference** for schema definition, which means:

- Database schema and TypeScript types are **the same thing**
- No code generation required - **live type inference across the builder chain**
- Plugin methods are **automatically inferred** based on enabled plugins
- Migrations are **deterministic and reversible**
- Query builder is **fully typed** at every step

Combined with the builder pattern for collections, globals, and auth, you get **end-to-end type safety** that catches errors at compile time, not runtime.

```typescript
const cms = defineQCMS({ name: "app" })
  .auth({ plugins: [organization()] })
  .build({
    /* ... */
  });

// TypeScript knows this method exists:
cms.auth.api.createOrganization({ name: "Acme" }); // ✅

// Without the plugin, TypeScript errors:
const cmsWithoutOrg = defineQCMS({ name: "app" }).build({
  /* ... */
});
cmsWithoutOrg.auth.api.createOrganization(); // ❌ Type error!
```

### Designed for Modern Frameworks

QUESTPIE integrates natively with:

- **Hono** - Ultra-fast, edge-compatible framework, via `@questpie/hono` adapter
- **Elysia** - High-performance Bun-native framework, via `@questpie/elysia` adapter
- **TanStack Start** - Full-stack React framework, adapter via `@questpie/tanstack-start` (admin UI coming soon)
- **Next.js** - Via custom API routes or middleware, via `@questpie/next` (admin UI coming soon)
- **Any TypeScript runtime** - Works with Node.js, Bun, Deno, Cloudflare Workers

The CMS core is **framework-agnostic** - adapters handle the HTTP layer while the core focuses on content management.

### Developer Experience First

- **Fluent builder API** - Chain methods like `.collections({...}).auth({...}).build({...})`
- **Autocomplete everywhere** - Your IDE knows your schema, fields, relations, access rules, and auth methods
- **Modular composition** - Create reusable modules with `.use()` for to encapsulate and distribute functionality (eg. `.use(blogModule).use(ecommerceModule)`)
- **Progressive enhancement** - Use callbacks or extensions to build on/override previous configurations in type-safe manner: `.auth((prev) => ({ ...prev, plugins: [...] }))`
- **Clear error messages** - TypeScript catches issues before they reach production
- **Convention over configuration** - Sensible defaults, override when needed
- **Hot module reloading** - Changes to collections reflect instantly in dev mode

## Key Features

### Modular Architecture

QUESTPIE CMS uses a **composable module system** that allows you to:

- **Start simple** - Use `defineQCMS({ name: 'app' })` for full control, that uses minimal defaults regarding auth, storage, etc.
- **Add features as needed** - Chain methods to add collections, globals, auth, storage
- **Compose modules** - Merge modules with `.use()` to add features from other packages or your own code

```typescript
// Create reusable modules with collections, globals, and functions
const blogModule = defineQCMS({ name: "blog" })
  .collections({
    posts: defineCollection("posts")
      .fields({
        title: varchar("title", { length: 255 }).notNull(),
        content: text("content"),
        slug: varchar("slug", { length: 255 }).unique(),
      })
      .access({
        read: true,
        create: ({ user }) => !!user,
      }),
    categories: defineCollection("categories")
      .fields({
        name: varchar("name", { length: 100 }).notNull(),
        description: text("description"),
      }),
  })
  .functions({
    publishPost: defineFunction({
      schema: z.object({
        postId: z.string().uuid(),
      }),
      handler: async (input) => {
        const cms = getCMSFromContext<typeof cms>(); // for easy type-safe access
        await cms.collections.posts.update({
          where: { id: input.postId },
          data: { isPublished: true },
        });
        return { success: true }; // Output is also typed
      },
    }),
  })
  });

const siteModule = defineQCMS({ name: "site" })
  .globals({
    siteConfig: defineGlobal("siteConfig")
      .fields({
        siteName: varchar("site_name", { length: 100 }),
        tagline: varchar("tagline", { length: 255 }),
        maintenanceMode: boolean("maintenance_mode").default(false),
      }),
    homepage: defineGlobal("homepage")
      .fields({
        heroTitle: varchar("hero_title", { length: 255 }),
        heroSubtitle: text("hero_subtitle"),
      })
      .localized(), // Support multiple languages
  })
  .functions({
    toggleMaintenance: defineFunction({
      handler: async () => {
        const cms = getCMSFromContext<typeof cms>();
        const config = await cms.globals.siteConfig.get();
        const newMode = !config.maintenanceMode;
        await cms.globals.siteConfig.update({
          data: { maintenanceMode: newMode },
        });
        return { maintenanceMode: newMode };
      },
    }),
  });

const authModule = defineQCMS({ name: "auth" })
  .auth({
    plugins: [organization(), twoFactor()],
  });

// Compose all modules together
const cms = defineQCMS({ name: "app" })
  .use(blogModule) // ✅ Adds posts & categories collections + publishPost function
  .use(siteModule) // ✅ Adds siteConfig & homepage globals + toggleMaintenance function
  .use(authModule) // ✅ Adds organization & two-factor auth
  .collections({
    // Add more collections directly
    products: defineCollection("products")
      .fields({
        name: varchar("name", { length: 255 }).notNull(),
        price: integer("price").notNull(),
      }),
      // or modify existing ones
      posts: blogModule.collections.posts.merge(
        defineCollection().fields({
          summary: varchar("summary", { length: 500 }),
      }))
  })
  .functions({
    // Add custom functions
    sendNewsletter: defineFunction({
      schema: z.object({
        subject: z.string(),
        content: z.string(),
      }),
      handler: async (input) => {
        const cms = getCMSFromContext<typeof cms>();
        // Send email to all subscribers (pseudo-code)
        const subscribers = await cms.collections.users.findMany({
          where: { isSubscribed: true },
        });
        for (const user of subscribers) {
          await cms.email.send({
            to: user.email,
            subject: input.subject,
            html: input.content,
          });
        }
        return { sentTo: subscribers.length };
      },
    }),
  })
  .build({
    /* ... */
  });

// All collections, globals, functions, and auth methods are typed:
await cms.api.collections.posts.findMany(); // From blogModule
await cms.api.collections.categories.findMany(); // From blogModule
await cms.api.collections.products.findMany(); // Defined directly
await cms.api.globals.siteConfig.get(); // From siteModule
await cms.api.globals.homepage.get(); // From siteModule
await cms.api.functions.publishPost({ postId: "123" }); // From blogModule
await cms.api.functions.toggleMaintenance(); // From siteModule
await cms.api.functions.sendNewsletter({ subject: "News", content: "..." }); // Defined directly
cms.auth.api.createOrganization({ name: "Acme" }); // From authModule
cms.auth.api.sendTwoFactorCode({ userId: "123" }); // From authModule
```

**Why this matters:**

- Share auth configurations across multiple projects
- Create organization-specific modules (e.g., "e-commerce-auth", "multi-tenant-auth")
- Test modules in isolation
- Type safety is preserved through composition

### Collections & Globals

**Collections** are multi-record content types (posts, products, users).
**Globals** are single-instance settings (homepage, site config, SEO defaults).

Both support:

- Drizzle-based schema definition
- Localization (i18n) for multi-language sites
- Virtual fields (computed SQL expressions)
- Relations (one-to-many, many-to-many)
- Versioning (track changes, revert to previous versions)
- Soft deletes (keep deleted records for recovery)

```typescript
export const posts = defineCollection("posts")
  .fields({
    title: varchar("title", { length: 255 }).notNull(),
    content: text("content"),
    authorId: uuid("author_id").notNull(),
  })
  .relations(({ table, one }) => ({
    author: one("users", {
      fields: [table.authorId],
      references: ["id"],
    }),
  }))
  .access({
    read: true,
    create: ({ user }) => !!user,
    update: ({ user, row }) => row.authorId === user.id,
  });
```

### Lifecycle Hooks

Intercept operations at every stage:

```typescript
.hooks({
  beforeChange: async ({ data, operation }) => {
    if (operation === "create") {
      // Generate slug from title
      data.slug = slugify(data.title);
    }
  },

  afterChange: async ({ data, operation }) => {
    if (operation !== "create") return;

    const cms = getCMSFromContext();
    // Queue email notification
    await cms.queue["post-created"].publish({ postId: data.id });

    // Log the event
    cms.logger.info("Post created", { postId: data.id });
  },
})
```

Hooks have access to:

- All integrated services (queue, email, storage, logger)
- Other collections via `cms.api.collections`
- Full type safety on data and context

### Access Control

Database-level access control with type-safe WHERE conditions:

```typescript
.access({
  read: ({ user }) => {
    if (!user) return { isPublished: true }; // Anonymous: published only

    return {
      OR: [
        { isPublished: true },   // Published posts
        { authorId: user.id },   // Own posts
      ],
    };
  },

  update: ({ user }) => ({
    authorId: user.id,       // Can only update own posts
    status: { ne: "archived" }, // Cannot update archived
  }),
})
```

Access rules are **enforced at the database level** - no manual filtering needed.

### Integrated Services

#### Authentication (Better Auth)

- **Type-safe plugin inference** - Add plugins, get typed API methods automatically
- **Composable auth modules** - Reuse auth configurations across projects with `.use()`
- **Progressive field enhancement** - Extend user/session models with callbacks
- Email/password, OAuth (Google, GitHub, etc.)
- Session management
- Role-based access control with plugins (admin, organization, two-factor, etc.)
- Auto-generated user/session/account tables

```typescript
// Add organization plugin → get organization methods
const cms = defineQCMS({ name: "app" })
  .auth({ plugins: [organization()] })
  .build({
    /* ... */
  });

cms.auth.api.createOrganization({ name: "Acme" }); // ✅ Fully typed
```

#### Storage (Flydrive)

- S3, Cloudflare R2, Local disk
- Automatic `assets` collection
- Direct upload endpoints
- CDN-ready URLs

#### Background Jobs (pg-boss)

- Database-backed job queue
- Cron jobs and workflows
- Retry logic and error handling
- No Redis required

#### Email (Nodemailer + React Email)

- Transactional emails
- React components for templates
- SMTP or API providers (SendGrid, Resend, etc.)

#### Search (ParadeDB/pgvector)

- Full-text search with BM25 ranking
- Vector embeddings for semantic search
- Built into Postgres - no separate service

### Migrations

Deterministic, reversible migrations powered by Drizzle Kit:

```bash
bun qcms migrate:generate    # Generate migration from schema changes
bun qcms migrate:up          # Run pending migrations
bun qcms migrate:down        # Rollback last batch
bun qcms migrate:status      # Show migration status
bun qcms migrate:fresh       # Reset and re-run all migrations
```

Migrations are **auto-generated** from your collection definitions - no manual SQL writing.

### RESTful API (Auto-Generated)

When using an adapter (Hono, Elysia), RESTful endpoints are generated automatically:

```
GET    /cms/posts                       # List posts
POST   /cms/posts                       # Create post
GET    /cms/posts/:id                   # Get post by ID
PATCH  /cms/posts/:id                   # Update post
DELETE /cms/posts/:id                   # Delete post

GET    /cms/globals/site-config         # Get global
PATCH  /cms/globals/site-config         # Update global

POST   /cms/storage/upload              # Upload file

POST   /cms/auth/sign-in                # Authentication endpoints
POST   /cms/auth/sign-up
POST   /cms/auth/sign-out
```

All endpoints respect access control and execute hooks automatically.

## Architecture

### Monorepo Structure

QUESTPIE CMS is organized as a Turborepo monorepo:

```
questpie-cms/
├── packages/
│   └── cms/                 # Core CMS package
│       ├── src/
│       │   ├── server/      # Server-side CMS engine
│       │   ├── client/      # Client-side SDK (optional)
│       │   ├── shared/      # Shared utilities
│       │   └── cli/         # Migration CLI
│       └── package.json
│
├── apps/
│   ├── docs/                # Documentation (Fumadocs)
│   └── tanstackstart-admin/ # Admin UI (TanStack Start)
│
└── examples/
    └── hono-barbershop/     # Example: Barbershop booking app
```

### Core Package (`@questpie/cms`)

The CMS is published as a single package with **subpath exports**:

```typescript
import { QCMS, defineCollection } from "@questpie/cms/server"; // Server-only
import { createClient } from "@questpie/cms/client"; // Client-only
import { utils } from "@questpie/cms/shared"; // Shared
```

This ensures:

- No accidental server code in client bundles
- Clear separation of concerns
- Tree-shakeable imports

### Server Architecture

```
CMS Instance (QCMS)
├── Collections (posts, users, products)
├── Globals (siteConfig, homepage)
├── Integrated Services
│   ├── Database (Drizzle ORM)
│   ├── Auth (Better Auth)
│   ├── Storage (Flydrive)
│   ├── Queue (pg-boss)
│   ├── Email (Nodemailer)
│   ├── Logger (Pino)
│   └── Search (ParadeDB)
├── CRUD Engine
│   ├── Query builder
│   ├── Access control enforcer
│   ├── Hook executor
│   └── Transaction manager
└── Adapters
    ├── Hono (@questpie/hono)
    └── Elysia (built-in)
```

### Request Flow

1. **HTTP Request** → Adapter (Hono/Elysia)
2. **Authentication** → Better Auth middleware
3. **Context Creation** → `cms.createContext({ user, locale, accessMode })`
4. **Access Control** → Evaluate access rules, build WHERE clause
5. **Hook Execution** → Run `before*` hooks
6. **Database Query** → Execute via Drizzle ORM
7. **Hook Execution** → Run `after*` hooks
8. **Response** → JSON with type-safe data

### Database Schema

QUESTPIE generates tables based on your collections:

```sql
-- Main collection table
CREATE TABLE posts (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  title VARCHAR(255) NOT NULL,
  content TEXT,
  author_id UUID NOT NULL,
  is_published BOOLEAN DEFAULT false,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Localized fields (if .localized() used)
CREATE TABLE posts_i18n (
  id UUID PRIMARY KEY,
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  locale VARCHAR(10) NOT NULL,
  title VARCHAR(255),  -- Localized field
  content TEXT         -- Localized field
);

-- Versions (if versioning enabled)
CREATE TABLE posts_versions (
  id UUID PRIMARY KEY,
  post_id UUID REFERENCES posts(id) ON DELETE CASCADE,
  version INT NOT NULL,
  data JSONB NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW()
);
```

## When to Use QUESTPIE CMS

### Perfect For:

- **Content-heavy applications** - Blogs, documentation sites, marketing pages
- **Multi-tenant SaaS** - Built-in organization/workspace support via access control
- **E-commerce backends** - Products, categories, orders with complex relations
- **Admin dashboards** - Type-safe CRUD operations with auto-generated APIs
- **Rapid prototyping** - Get a production-ready backend in minutes

### Not Ideal For:

- **Simple static sites** - Use a static site generator instead
- **Non-TypeScript projects** - The value is in TypeScript's type safety
- **Edge-only deployments** - Requires Postgres (though Neon/PlanetScale work on edge)
- **GraphQL-first APIs** - QUESTPIE is REST-first (GraphQL support coming)

## Getting Started

### Installation

```bash
bun add @questpie/cms drizzle-orm
bun add -d drizzle-kit
```

### Quick Start

```typescript
// cms.ts
import { defineQCMS, defineCollection } from "@questpie/cms/server";
import { varchar, text } from "drizzle-orm/pg-core";
import { organization } from "better-auth/plugins";

// Define a custom collection
export const posts = defineCollection("posts")
  .fields({
    title: varchar("title", { length: 255 }).notNull(),
    content: text("content"),
  })
  .access({
    read: true,
    create: ({ user }) => !!user,
  });

// Initialize CMS with custom collections + auth plugins
export const cms = defineQCMS({ name: "app" })
  .collections({ posts })
  .auth({ plugins: [organization()] })
  .build({
    app: { url: process.env.APP_URL },
    db: { url: process.env.DATABASE_URL },
  });

// TypeScript knows all auth methods:
cms.auth.api.signIn.email({ email, password }); // ✅ Default auth
cms.auth.api.createOrganization({ name: "Acme" }); // ✅ Organization plugin
```

### With Hono

```typescript
import { Hono } from "hono";
import { createCMSAdapterRoutes } from "@questpie/cms/server";
import { cms } from "./cms";

const app = new Hono();

// Mount CMS routes
app.route("/api", createCMSAdapterRoutes(cms));

export default {
  port: 3000,
  fetch: app.fetch,
};
```

Now you have a fully functional CMS with:

- RESTful API at `/api/cms/*` for collections
- Authentication endpoints at `/api/auth/*`
- Type-safe CRUD operations
- Access control enforced
- Auto-generated migrations
- Composable, reusable auth modules

## Next Steps

- **[Getting Started](/docs/introduction/getting-started)** - Step-by-step setup guide
- **[Core Concepts](/docs/core-concepts/collections)** - Learn about Collections, Hooks, Access Control
- **[Guides](/docs/guides/authentication)** - Practical tutorials and real-world examples
- **[API Reference](/docs/reference/cms-config)** - Complete API documentation

## Community & Support

- **GitHub**: [questpie/questpie-cms](https://github.com/questpie/questpie-cms)
- **Issues**: Report bugs or request features on GitHub
- **Discussions**: Ask questions in GitHub Discussions

## License

QUESTPIE CMS is open-source software licensed under the **MIT License**.
