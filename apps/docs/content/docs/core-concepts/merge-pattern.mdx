---
title: Composing Collections
description: Combine and extend collections using the merge pattern for modular architecture.
icon: GitMerge
---

# Composing Collections

**QUESTPIE CMS** features a powerful composition API that allows you to combine multiple collection definitions into a single entity. This pattern is central to **QUESTPIE**'s modular architecture, enabling you to distribute fields, hooks, and logic across different files or packages.

## The Merge API

The `.merge()` method combines the state of two collection builders. It is useful for splitting large schemas, creating reusable plugins, or extending core collections from feature modules.

```typescript
import { defineCollection } from '@questpie/cms'
import { text } from 'drizzle-orm/pg-core'

// 1. Define a base collection
const baseUsers = defineCollection('users')
  .fields({
    email: text('email').notNull(),
  })

// 2. Define an extension
const profileExtension = defineCollection('users')
  .fields({
    avatar: text('avatar'),
    bio: text('bio'),
  })

// 3. Merge them
const users = baseUsers.merge(profileExtension)

// Resulting collection contains: email, avatar, bio
```

## Merge Logic

When merging Collection B into Collection A (`A.merge(B)`), the system applies the following rules:

- **Fields**: Properties are merged shallowly. If a field exists in both, B overrides A.
- **Localized Fields**: Arrays are concatenated.
- **Hooks**: Lifecycle hooks are accumulated. If both A and B define `beforeCreate`, both will run (A first, then B).
- **Access Control**: B's rules override A's rules.
- **Options**: Shallow merge, with B overriding A.

## Common Use Cases

### Feature Modules

Modules defined with `defineModule` expose their extensions in a structured way. You merge these extensions into your base collections during configuration.

```typescript title="cms.config.ts"
import { configureModule } from '@questpie/cms'
import { authModule } from './modules/auth'

// 1. Configure module
const auth = configureModule(authModule, {
  jwtSecret: '...',
})

// 2. Merge extension
const users = baseUsers.merge(auth.extensions!.users)
```

### Plugins

Plugins in **QUESTPIE** are simply Modules packaged for distribution. The usage pattern is identical.

```typescript title="cms.config.ts"
import { seoPlugin } from '@questpie/plugin-seo'

// Add SEO fields to Pages collection
const pages = basePages.merge(seoPlugin.extensions!.pages)
```

## Type Safety

The merge operation preserves full type safety. The resulting builder infers a type that represents the intersection of all merged definitions.

```typescript
const users = baseUsers
  .merge(defineCollection('users').fields({
    age: integer('age'),
  }))

// TypeScript knows 'age' exists on the table
users.table.age // PgColumn<{ type: 'integer' }>

// TypeScript knows 'age' is part of the insert type
type UserInsert = typeof users.$infer.insert // includes { age?: number }
```

## Best Practices

### ✅ Do
- **Use for Modularity**: Split large collections into logical groups (e.g., `userProfile`, `userSettings`, `userAuth`).
- **Consistent Naming**: Ensure both collections being merged share the same name (e.g., both named `'users'`).
- **Document Extensions**: clear comments or documentation on what an extension adds to a core collection.

### ❌ Don't
- **Circular Dependencies**: Avoid scenarios where Module A imports Module B and vice-versa for merging.
- **Implicit Overrides**: Be careful when overriding existing fields; explicit is better than implicit.

## Next Steps

<Cards>
  <Card
    title="Modular Architecture"
    description="See the merge pattern in action within a full architecture."
    href="/docs/guides/modules"
  />
  <Card
    title="Type Inference"
    description="Learn how Questpie maintains type safety."
    href="/docs/core-concepts/builder-pattern"
  />
</Cards>