---
title: Defining Collections
description: Learn how to define content structures using QUESTPIE's type-safe builder API.
icon: Layers
---

# Defining Collections

Collections are the fundamental building blocks of QUESTPIE CMS. They define the structure of your data, its relationships, access control rules, and behavioral hooks.

QUESTPIE uses a **fluent builder API** to define collections. This approach allows for progressive type inferenceâ€”as you chain methods to configure your collection, TypeScript automatically updates the inferred type of your data model.

## The Builder API

The `collection()` function initiates a new collection builder. You can then chain various configuration methods to define the collection's properties.

```typescript
import { defineCollection } from '@questpie/cms'
import { text, boolean } from 'drizzle-orm/pg-core'

export const pages = defineCollection('pages')
  .fields({
    slug: text('slug').notNull().unique(),
    isPublished: boolean('is_published').default(false),
  })
  .options({
    timestamps: true,
  })
```

### Immutability & Composition

The builder is **immutable**. Every method call returns a *new* instance of the builder with the updated configuration and type signature. This design pattern enables safe composition and reusability.

```typescript
const baseContent = defineCollection('base_content')
  .fields({
    createdAt: timestamp('created_at').defaultNow(),
  })

// 'articles' starts with 'createdAt' from 'baseContent'
const articles = baseContent
  .fields({
    title: text('title'),
    content: text('content'),
  })
```

## Core Methods

### `.fields(definitions)`

Defines the data structure using standard Drizzle ORM column definitions.

```typescript
.fields({
  username: text('username').notNull(),
  age: integer('age'),
})
```

### `.localized(keys)`

Marks specific fields as localized. QUESTPIE will automatically move these fields to a separate translation table and handle language fallbacks transparently.

```typescript
.fields({
  title: text('title'),
  slug: text('slug'),
})
.localized(['title']) // 'title' is now translatable
```

### `.relations(callback)`

Defines relationships between collections. The callback receives the fully typed table definition, allowing for type-safe references.

```typescript
.relations((table, i18n, { one, many }) => ({
  author: one('users', {
    fields: [table.authorId],
    references: ['id'],
  }),
  comments: many('comments'),
}))
```

### `.access(rules)`

Configures Role-Based Access Control (RBAC) for the collection.

```typescript
.access({
  read: () => true,       // Public read
  create: 'admin',        // Admin only create
  update: 'editor',       // Editor update
  delete: 'admin',
})
```

## Advanced Configuration

### Virtual Fields

You can define computed fields using SQL expressions. These are calculated at the database level.

```typescript
.virtuals((table) => ({
  fullName: sql<string>`${table.firstName} || ' ' || ${table.lastName}`,
}))
```

### Indexes

Performance optimizations can be added via the `.indexes()` method, which provides access to the underlying table columns.

```typescript
.indexes((table) => ({
  slugIdx: index('slug_idx').on(table.slug),
}))
```

## Performance: Lazy Evaluation

Collections are built **lazily**. The expensive operations of generating the Drizzle table schema and relation maps only occur when you first access a property that requires them (like `.table` or `.generateCRUD()`).

This means you can define hundreds of collections in your application without incurring a startup penalty. The builder just accumulates configuration state until the CMS actually needs to interact with the database.

## Next Steps

<Cards>
  <Card
    title="Relations Guide"
    description="Learn how to model complex relationships."
    href="/docs/reference/cms/relations"
  />
</Cards>
