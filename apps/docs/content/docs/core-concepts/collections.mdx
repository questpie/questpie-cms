---
title: Collections
description: Data models in QUESTPIE CMS
---

# Collections

Collections are the core data models in QUESTPIE CMS. They define your database schema, validation rules, and business logic.

## What is a Collection?

A collection represents a type of content in your CMS:

- **Posts** - Blog articles
- **Products** - E-commerce items
- **Users** - User accounts
- **Pages** - Website pages
- **Assets** - Uploaded files

Each collection creates a database table and provides CRUD operations.

## Defining a Collection

### Backend Definition

```typescript
import { q, text, boolean, datetime, integer, varchar } from "questpie";

const posts = q.collection("posts")
  .fields({
    title: text("title").notNull(),
    slug: text("slug").notNull().unique(),
    content: text("content"),
    excerpt: text("excerpt"),
    published: boolean("published").default(false),
    publishedAt: datetime("publishedAt"),
    viewCount: integer("viewCount").default(0),
    authorId: varchar("authorId", { length: 255 }),
  })
  .options({
    timestamps: true,     // Add createdAt, updatedAt
    softDelete: true,     // Add deletedAt, use soft delete
    versioning: true,     // Track version history
  })
  .relations(({ one, many }) => ({
    author: one("user", {
      fields: ["authorId"],
      references: ["id"],
    }),
    tags: many("tags"),
  }))
  .validation({
    exclude: { id: true, createdAt: true, updatedAt: true },
    refine: {
      title: (s) => s.min(1, "Title required").max(200),
      slug: (s) => s.regex(/^[a-z0-9-]+$/),
    },
  })
  .hooks({
    beforeCreate: async ({ data }) => {
      if (!data.slug && data.title) {
        data.slug = slugify(data.title);
      }
      return data;
    },
  })
  .access({
    read: () => true,
    create: ({ ctx }) => ctx.session?.user?.role === "editor",
    update: ({ ctx }) => ctx.session?.user?.role === "editor",
    delete: ({ ctx }) => ctx.session?.user?.role === "admin",
  })
  .localized(["title", "content", "excerpt"])
  .searchable({
    content: (record) => `${record.title} ${record.content}`,
  })
  .title(({ f }) => f.title);
```

### Admin Definition

```typescript
import { qa, adminModule } from "@questpie/admin/client";
import type { AppCMS } from "./server/cms";

const builder = qa<AppCMS>().use(adminModule);

const postsAdmin = builder.collection("posts")
  .meta({
    label: "Posts",
    labelSingular: "Post",
    icon: FileText,
  })
  .fields(({ r }) => ({
    title: r.text({ label: "Title", required: true }),
    slug: r.text({ label: "Slug", description: "URL-friendly identifier" }),
    content: r.richText({ label: "Content" }),
    excerpt: r.textarea({ label: "Excerpt", maxLength: 300 }),
    published: r.switch({ label: "Published" }),
    publishedAt: r.datetime({ label: "Publish Date" }),
    author: r.relation({
      label: "Author",
      targetCollection: "user",
    }),
    tags: r.relation({
      label: "Tags",
      targetCollection: "tags",
      multiple: true,
    }),
  }))
  .list(({ v, f }) => v.table({
    columns: [f.title, f.author, f.published, f.publishedAt],
    defaultSort: { field: "createdAt", direction: "desc" },
  }))
  .form(({ v, f }) => v.form({
    fields: [
      f.title,
      f.slug,
      f.content,
      f.excerpt,
      { type: "row", fields: [f.author, f.tags] },
      { type: "row", fields: [f.published, f.publishedAt] },
    ],
  }));
```

## Collection Options

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `timestamps` | `boolean` | `true` | Add `createdAt`, `updatedAt` fields |
| `softDelete` | `boolean` | `false` | Use soft delete with `deletedAt` |
| `versioning` | `boolean` | `false` | Track version history |

```typescript
.options({
  timestamps: true,
  softDelete: true,
  versioning: true,
})
```

## Collection Methods

### `.fields(fields)`

Define database columns using Drizzle column builders:

```typescript
.fields({
  name: varchar("name", { length: 255 }).notNull(),
  email: varchar("email", { length: 255 }).unique(),
  bio: text("bio"),
  age: integer("age"),
  active: boolean("active").default(true),
  settings: jsonb("settings"),
  createdAt: timestamp("createdAt").defaultNow(),
})
```

### `.relations(fn)`

Define relationships to other collections:

```typescript
.relations(({ one, many }) => ({
  // One-to-one or many-to-one
  author: one("user", {
    fields: ["authorId"],
    references: ["id"],
  }),

  // Many-to-many (via join table)
  tags: many("tags"),

  // Reverse relation
  comments: many("comments"),
}))
```

### `.validation(options)`

Configure Zod validation:

```typescript
.validation({
  exclude: { id: true, createdAt: true },
  refine: {
    email: (s) => s.email("Invalid email"),
    age: (s) => s.min(0).max(150),
  },
})
```

### `.hooks(hooks)`

Add lifecycle hooks:

```typescript
.hooks({
  beforeCreate: async ({ data, ctx }) => {
    // Modify data before insert
    return data;
  },
  afterCreate: async ({ data, ctx }) => {
    // Side effects after insert
  },
  beforeUpdate: async ({ data, existingData, ctx }) => {
    return data;
  },
  afterUpdate: async ({ data, ctx }) => {},
  beforeDelete: async ({ data, ctx }) => {},
  afterDelete: async ({ data, ctx }) => {},
  afterRead: async ({ data, ctx }) => {
    // Transform data before returning
  },
})
```

### `.access(rules)`

Define access control:

```typescript
.access({
  // Return true/false or a where clause
  read: ({ ctx }) => true,
  create: ({ ctx }) => !!ctx.session,
  update: ({ ctx, data }) => data.authorId === ctx.session?.user?.id,
  delete: ({ ctx }) => ctx.session?.user?.role === "admin",

  // Field-level access
  fields: {
    internalNotes: {
      read: ({ ctx }) => ctx.session?.user?.role === "admin",
      write: ({ ctx }) => ctx.session?.user?.role === "admin",
    },
  },
})
```

### `.localized(fields)`

Mark fields for localization:

```typescript
// Flat mode (default) - entire value per locale
.localized(["title", "description"])

// Nested mode - for JSONB with structure
.localized(["title", "blocks:nested"])
```

### `.searchable(config)`

Enable full-text search:

```typescript
.searchable({
  content: (record) => `${record.title} ${record.content}`,
  metadata: (record) => ({
    published: record.published,
    category: record.categoryId,
  }),
})
```

### `.title(fn)`

Set the display title field:

```typescript
.title(({ f }) => f.name)
```

### `.upload(options)`

Enable file uploads:

```typescript
.upload({
  visibility: "public",
  maxSize: 10_000_000,  // 10MB
  allowedTypes: ["image/*", "application/pdf"],
})
```

## Using Collections

### Server-Side

```typescript
// After build
const cms = q({ name: "my-cms" })
  .collections({ posts })
  .build({...});

// Access CRUD API
const { docs } = await cms.api.collections.posts.find({
  where: { published: true },
  orderBy: { publishedAt: "desc" },
  limit: 10,
  with: { author: true },
});

// Access Drizzle table
const table = cms.collections.posts.table;
await cms.db.select().from(table).where(eq(table.published, true));
```

### Client-Side

```typescript
import { createClient } from "questpie/client";

const client = createClient<typeof cms>({
  baseURL: "http://localhost:3000",
});

const { docs } = await client.collections.posts.find({
  where: { published: true },
});
```

## Globals vs Collections

| Feature | Collection | Global |
|---------|-----------|--------|
| Records | Multiple | Single (singleton) |
| Has ID | Yes | No (uses slug) |
| CRUD | Full | Get/Update only |
| Use case | Content items | Site settings |

```typescript
// Collection - many posts
const posts = q.collection("posts");

// Global - one settings record
const settings = q.global("settings")
  .fields({
    siteName: text("siteName"),
    logo: text("logo"),
  });
```

## Related

- [Fields](/docs/core-concepts/fields) - Field types in detail
- [Backend Collections](/docs/backend/collections) - Full collection reference
- [Relations](/docs/backend/relations) - Collection relationships
- [Hooks](/docs/backend/hooks) - Lifecycle hooks
