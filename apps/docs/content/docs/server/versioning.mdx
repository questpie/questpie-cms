---
title: Versioning
description: Automatic version history, rollback, and audit trails for collection records
---

# Versioning

QUESTPIE can automatically create version snapshots every time a record is created, updated, or deleted. This gives you a complete audit trail and the ability to revert records to any previous state.

## Why This Exists

Content management often requires an audit trail — who changed what, when, and the ability to undo mistakes. QUESTPIE's versioning system stores complete record snapshots in a dedicated versions table, letting you browse history and revert with a single API call.

## Enabling Versioning

Add `versioning: true` to the collection's `.options()`:

```ts
export const posts = qb
  .collection("posts")
  .fields((f) => ({
    title: f.text({ required: true }),
    content: f.richText({}),
    status: f.select({ options: ["draft", "published", "archived"] }),
  }))
  .options({
    timestamps: true,
    versioning: true,
  });
```

### Configuration

```ts
.options({
  versioning: {
    enabled: true,
    maxVersions: 100,  // Keep last 100 versions per record (default: 50)
  },
})
```

| Option | Type | Default | Description |
|---|---|---|---|
| `enabled` | `boolean` | `false` | Enable version tracking |
| `maxVersions` | `number` | `50` | Maximum versions to keep per record. Oldest are pruned automatically. |

## Workflow + Versioning

Versioning works best with staged publishing workflows.

```ts
.options({
  versioning: true,
  workflow: {
    initialStage: "draft",
    stages: {
      draft: { transitions: ["review"] },
      review: { transitions: ["draft", "published"] },
      published: {},
    },
  },
})
```

With workflow enabled:

- Reads can target a stage snapshot (`find({ stage: "review" })`, `findOne({ stage: "published" })`)
- Writes can target a stage via context (`{ stage: "review" }`) or HTTP query (`?stage=review`)
- Transition guards enforce allowed next stages from `workflow.stages.*.transitions`
- Version snapshots persist both target stage and previous stage metadata

### Transitioning Stages

Use `transitionStage()` to move a record between workflow stages without mutating its data:

```ts
// Move a post from draft to published
await app.api.collections.posts.transitionStage(
  { id: "post-123", stage: "published" },
  ctx,
);
```

This creates a new version snapshot at the target stage with the record's current data. If transition guards are defined, the transition is validated against the allowed transitions for the current stage.

#### Via HTTP

```
POST /questpie/posts/post-123/transition
Content-Type: application/json

{ "stage": "published" }
```

For globals:

```
POST /questpie/globals/siteSettings/transition
Content-Type: application/json

{ "stage": "published" }
```

#### Scheduled Transitions

Pass `scheduledAt` to defer a transition to a future time. Requires a queue adapter:

```ts
await app.api.collections.posts.transitionStage(
  {
    id: "post-123",
    stage: "published",
    scheduledAt: new Date("2026-03-01T09:00:00Z"),
  },
  ctx,
);
```

If `scheduledAt` is in the past, the transition executes immediately. If in the future, a `scheduled-transition` job is enqueued and the record is returned unchanged.

### Transition Access Control

Add an `access.transition` rule to control who can transition stages. It falls back to `access.update` when not defined:

```ts
.access({
  update: () => true,
  transition: ({ session }) => session?.user?.role === "admin",
})
```

### Transition Hooks

Use `beforeTransition` and `afterTransition` hooks to inject logic around stage changes:

```ts
.hooks({
  beforeTransition: ({ fromStage, toStage, data }) => {
    if (toStage === "published" && !data.title) {
      throw new Error("Cannot publish without a title");
    }
  },
  afterTransition: async ({ fromStage, toStage, data, app }) => {
    if (toStage === "published") {
      await app.queue.notifySubscribers.publish({ postId: data.id });
    }
  },
})

## How It Works

```text
CRUD operation → [normal hooks + DB write] → createVersionRecord() → [prune old versions]
```

When versioning is enabled:

1. Every create, update, and delete operation creates a version record
2. The version record contains a complete snapshot of the record at that point
3. For localized collections, i18n data is also versioned in a separate i18n versions table
4. Old versions are automatically pruned when `maxVersions` is exceeded

## Version Record Structure

Each version contains:

| Field | Type | Description |
|---|---|---|
| `id` | `string` | Original record ID (foreign key) |
| `versionId` | `string` | Unique ID for this version (UUID) |
| `versionNumber` | `number` | Sequential version number (1, 2, 3...) |
| `versionOperation` | `string` | `"create"`, `"update"`, or `"delete"` |
| `versionStage` | `string \| null` | Target workflow stage for this snapshot (when workflow is enabled) |
| `versionFromStage` | `string \| null` | Previous workflow stage before transition (when workflow is enabled) |
| `versionUserId` | `string \| null` | User who made the change (from session) |
| `versionCreatedAt` | `Date` | When this version was created |
| _...all record fields_ | _varies_ | Complete snapshot of all field values |

## Generated Tables

When you enable versioning, QUESTPIE auto-generates:

- **`{collection}_versions`** — Version records with all main table columns plus version metadata
- **`{collection}_i18n_versions`** — Localized field versions (if the collection has localized fields)

## API

### Finding Versions

Retrieve the version history for a record:

```ts
const versions = await app.api.collections.posts.findVersions({
  id: "post-123",
  limit: 10,
  offset: 0,
});

// versions: Array<{
//   versionId: string;
//   versionNumber: number;
//   versionOperation: "create" | "update" | "delete";
//   versionUserId: string | null;
//   versionCreatedAt: Date;
//   title: string;
//   content: any;
//   status: string;
//   ...
// }>
```

### Reverting to a Version

Restore a record to a previous version:

```ts
// Revert by version number
await app.api.collections.posts.revertToVersion({
  id: "post-123",
  versionNumber: 3,
});

// Revert by version ID
await app.api.collections.posts.revertToVersion({
  id: "post-123",
  versionId: "version-uuid-here",
});
```

Reverting:
1. Reads the specified version record
2. Restores all field values to the main table
3. Restores localized fields to the i18n table (if applicable)
4. Creates a new version recording the revert operation
5. Runs `beforeChange` and `afterChange` hooks
6. Enforces update access control

### Localized Versions

For collections with localized fields, `findVersions` supports locale-specific queries:

```ts
const versions = await app.api.collections.posts.findVersions(
  { id: "post-123" },
  { locale: "de" },
);
```

This returns versions with localized field values merged from the i18n versions table, with fallback to the default locale.

## Transaction Behavior

Version creation runs inside the same transaction as the CRUD operation. If the operation fails and rolls back, no version is created. If the version creation fails, the entire operation rolls back.

## Automatic Pruning

When a record exceeds `maxVersions`, the oldest versions are automatically deleted:

```text
Record has 50 versions + new version = 51
→ Delete version #1 (oldest)
→ Now 50 versions remain
```

This happens inside the same transaction as the version creation.

## Common Mistakes

- **Versioning high-frequency collections** — Collections with frequent writes (analytics, logs) can accumulate many version records. Set a low `maxVersions` or skip versioning entirely for these.
- **Large `richText` or `blocks` fields** — Each version stores a complete snapshot. Large content fields multiply storage requirements. Consider `maxVersions` limits.
- **Not checking `versionOperation`** — When browsing versions, filter by `versionOperation` to distinguish creates, updates, and deletes.

## Related Pages

- [Collections](/docs/server/collections) — Collection `.options()` configuration
- [Access Control](/docs/server/access-control) — `access.transition` permission
- [Hooks & Lifecycle](/docs/server/hooks-and-lifecycle) — `beforeTransition` / `afterTransition` hooks
- [Context & Transactions](/docs/server/context-and-transactions) — Transaction behavior
- [CRUD API](/docs/reference/crud-api) — `transitionStage()` method reference
- [Queue & Jobs](/docs/infrastructure/queue-and-jobs) — Scheduled transition job
