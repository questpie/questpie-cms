---
title: Versioning
description: Automatic version history, rollback, and audit trails for collection records
---

# Versioning

QUESTPIE can automatically create version snapshots every time a record is created, updated, or deleted. This gives you a complete audit trail and the ability to revert records to any previous state.

## Why This Exists

Content management often requires an audit trail — who changed what, when, and the ability to undo mistakes. QUESTPIE's versioning system stores complete record snapshots in a dedicated versions table, letting you browse history and revert with a single API call.

## Enabling Versioning

Add `versioning: true` to the collection's `.options()`:

```ts
export const posts = qb
  .collection("posts")
  .fields((f) => ({
    title: f.text({ required: true }),
    content: f.richText({}),
    status: f.select({ options: ["draft", "published", "archived"] }),
  }))
  .options({
    timestamps: true,
    versioning: true,
  });
```

### Configuration

```ts
.options({
  versioning: {
    maxVersions: 100,  // Keep last 100 versions per record (default: 50)
  },
})
```

| Option | Type | Default | Description |
|---|---|---|---|
| `maxVersions` | `number` | `50` | Maximum versions to keep per record. Oldest are pruned automatically. |
| `workflow` | `boolean \| WorkflowOptions` | `undefined` | Enable publishing workflow. See [Workflow](#workflow--versioning). |

## Workflow + Versioning

Workflow adds staged publishing on top of versioning. It lives under the `versioning` option because transitions create version snapshots — the two are fundamentally linked.

```ts
.options({
  versioning: {
    workflow: {
      initialStage: "draft",
      stages: {
        draft: { transitions: ["review"] },
        review: { transitions: ["draft", "published"] },
        published: {},
      },
    },
  },
})
```

The shorthand `versioning: { workflow: true }` gives you default stages `["draft", "published"]` with `initialStage: "draft"`.

With workflow enabled:

- Reads can target a stage snapshot (`find({ stage: "review" })`, `findOne({ stage: "published" })`)
- Writes can target a stage via context (`{ stage: "review" }`) or HTTP query (`?stage=review`)
- Transition guards enforce allowed next stages from `workflow.stages.*.transitions`
- Version snapshots persist both target stage and previous stage metadata

### Transitioning Stages

Use `transitionStage()` to move a record between workflow stages without mutating its data:

```ts
// Move a post from draft to published
await app.api.collections.posts.transitionStage(
  { id: "post-123", stage: "published" },
  ctx,
);
```

This creates a new version snapshot at the target stage with the record's current data. If transition guards are defined, the transition is validated against the allowed transitions for the current stage.

#### Via HTTP

```
POST /questpie/posts/post-123/transition
Content-Type: application/json

{ "stage": "published" }
```

For globals:

```
POST /questpie/globals/siteSettings/transition
Content-Type: application/json

{ "stage": "published" }
```

#### Scheduled Transitions

Pass `scheduledAt` to defer a transition to a future time. Requires a queue adapter:

```ts
await app.api.collections.posts.transitionStage(
  {
    id: "post-123",
    stage: "published",
    scheduledAt: new Date("2026-03-01T09:00:00Z"),
  },
  ctx,
);
```

If `scheduledAt` is in the past, the transition executes immediately. If in the future, a `scheduled-transition` job is enqueued and the record is returned unchanged.

### Transition Access Control

Add an `access.transition` rule to control who can transition stages. It falls back to `access.update` when not defined:

```ts
.access({
  update: () => true,
  transition: ({ session }) => session?.user?.role === "admin",
})
```

### Transition Hooks

Use `beforeTransition` and `afterTransition` hooks to inject logic around stage changes:

```ts
.hooks({
  beforeTransition: ({ fromStage, toStage, data }) => {
    if (toStage === "published" && !data.title) {
      throw ApiError.badRequest("Cannot publish without a title");
    }
  },
  afterTransition: async ({ fromStage, toStage, data, app }) => {
    if (toStage === "published") {
      await app.queue.notifySubscribers.publish({ postId: data.id });
    }
  },
})
```

## How It Works

```text
CRUD operation → [normal hooks + DB write] → createVersionRecord() → [prune old versions]
```

When versioning is enabled:

1. Every create, update, and delete operation creates a version record
2. The version record contains a complete snapshot of the record at that point
3. For localized collections, i18n data is also versioned in a separate i18n versions table
4. Old versions are automatically pruned when `maxVersions` is exceeded

### How Workflow Routes Queries

When workflow is enabled, the **main table always represents the initial stage** (typically "draft"). Non-initial stages (like "published") are read from the versions table.

```text
find()                        → reads main table (= draft / initial stage)
find({ stage: "published" })  → reads versions table (latest "published" snapshot per record)
find({ stage: "draft" })      → reads main table (same as no stage)
```

This means your public-facing site queries `{ stage: "published" }` and always gets the last published snapshot, while the admin panel edits the main table (draft) directly.

Under the hood, a stage query builds a subquery that finds the latest version number per record for the given stage, then INNER JOINs the versions table to that subquery. This is fully automatic — you just pass `stage` and the framework handles the rest.

## Version Record Structure

Each version contains:

| Field | Type | Description |
|---|---|---|
| `id` | `string` | Original record ID (foreign key) |
| `versionId` | `string` | Unique ID for this version (UUID) |
| `versionNumber` | `number` | Sequential version number (1, 2, 3...) |
| `versionOperation` | `string` | `"create"`, `"update"`, or `"delete"` |
| `versionStage` | `string \| null` | Target workflow stage for this snapshot (when workflow is enabled) |
| `versionFromStage` | `string \| null` | Previous workflow stage before transition (when workflow is enabled) |
| `versionUserId` | `string \| null` | User who made the change (from session) |
| `versionCreatedAt` | `Date` | When this version was created |
| _...all record fields_ | _varies_ | Complete snapshot of all field values |

## Generated Tables

When you enable versioning, QUESTPIE auto-generates:

- **`{collection}_versions`** — Version records with all main table columns plus version metadata
- **`{collection}_i18n_versions`** — Localized field versions (if the collection has localized fields)

## API

### Finding Versions

Retrieve the version history for a record:

```ts
const versions = await app.api.collections.posts.findVersions({
  id: "post-123",
  limit: 10,
  offset: 0,
});

// versions: Array<{
//   versionId: string;
//   versionNumber: number;
//   versionOperation: "create" | "update" | "delete";
//   versionUserId: string | null;
//   versionCreatedAt: Date;
//   title: string;
//   content: any;
//   status: string;
//   ...
// }>
```

### Reverting to a Version

Restore a record to a previous version:

```ts
// Revert by version number
await app.api.collections.posts.revertToVersion({
  id: "post-123",
  versionNumber: 3,
});

// Revert by version ID
await app.api.collections.posts.revertToVersion({
  id: "post-123",
  versionId: "version-uuid-here",
});
```

Reverting:
1. Reads the specified version record
2. Restores all field values to the main table
3. Restores localized fields to the i18n table (if applicable)
4. Creates a new version recording the revert operation
5. Runs `beforeChange` and `afterChange` hooks
6. Enforces update access control

### Localized Versions

For collections with localized fields, `findVersions` supports locale-specific queries:

```ts
const versions = await app.api.collections.posts.findVersions(
  { id: "post-123" },
  { locale: "de" },
);
```

This returns versions with localized field values merged from the i18n versions table, with fallback to the default locale.

## Transaction Behavior

Version creation runs inside the same transaction as the CRUD operation. If the operation fails and rolls back, no version is created. If the version creation fails, the entire operation rolls back.

## Automatic Pruning

When a record exceeds `maxVersions`, the oldest versions are automatically deleted:

```text
Record has 50 versions + new version = 51
→ Delete version #1 (oldest)
→ Now 50 versions remain
```

This happens inside the same transaction as the version creation.

## Admin UI

When workflow is enabled, the admin form view automatically shows:

- **Stage badge** — Displays the current workflow stage in the form header
- **Transition button** — Dropdown listing allowed target stages from the current stage
- **Scheduling** — Optional "Schedule for later" date picker in the transition dialog
- **History sidebar** — Transitions appear in the audit timeline (when `auditModule` is enabled) with stage change details

No additional configuration is needed — the admin detects workflow from the schema introspection and renders the UI automatically.

## Practical Examples

### Simple Blog Publishing

The simplest workflow: posts start as drafts, editors publish when ready.

```ts
const posts = qb
  .collection("posts")
  .fields((f) => ({
    title: f.text({ required: true }),
    content: f.richText({}),
    author: f.relation({ to: "users", required: true }),
  }))
  .options({
    versioning: {
      workflow: true, // shorthand: stages ["draft", "published"], initialStage "draft"
    },
  });
```

Your public site always reads from the published stage:

```ts
// Admin sees drafts (default stage = main table)
const drafts = await app.api.collections.posts.find({}, adminCtx);

// Public site reads only published content
const published = await app.api.collections.posts.find(
  { stage: "published" },
  publicCtx,
);

// Publish a post
await app.api.collections.posts.transitionStage(
  { id: post.id, stage: "published" },
  adminCtx,
);
```

### Editorial Review with Email Notifications

A three-stage workflow where authors submit drafts for review, reviewers approve or reject, and only admins can publish. Email notifications fire on each transition.

```ts
import { ApiError } from "questpie/server/errors";

const articles = qb
  .collection("articles")
  .fields((f) => ({
    title: f.text({ required: true }),
    content: f.richText({}),
    author: f.relation({ to: "users", required: true }),
  }))
  .options({
    versioning: {
      workflow: {
        initialStage: "draft",
        stages: {
          draft: { transitions: ["review"] },
          review: { transitions: ["draft", "published"] },
          published: { transitions: ["draft"] },
        },
      },
    },
  })
  .access({
    // Anyone can edit drafts
    update: () => true,
    // Only reviewers and admins can transition stages
    transition: ({ session }) =>
      ["reviewer", "admin"].includes(session?.user?.role),
  })
  .hooks({
    beforeTransition: ({ toStage, data }) => {
      // Require content before publishing — returns 400 with a structured error
      if (toStage === "published" && !data.content) {
        throw ApiError.badRequest("Cannot publish an article without content");
      }
    },
    afterTransition: async ({ fromStage, toStage, data, app, context }) => {
      if (toStage === "review") {
        // Notify reviewers that a new article is waiting
        await app.email.send({
          to: "reviewers@company.com",
          subject: `Review requested: ${data.title}`,
          text: `A new article "${data.title}" is ready for review.`,
        });
      }

      if (toStage === "published") {
        // Notify the author their article was published
        const author = await app.api.collections.users.findOne(
          { where: { id: data.author } },
          context,
        );
        if (author?.email) {
          await app.email.send({
            to: author.email,
            subject: `Your article "${data.title}" is now live!`,
            text: `Congratulations! Your article has been published.`,
          });
        }
      }

      if (fromStage === "review" && toStage === "draft") {
        // Article was sent back — notify the author
        await app.email.send({
          to: "author@company.com",
          subject: `Revisions needed: ${data.title}`,
          text: `Your article "${data.title}" needs revisions.`,
        });
      }
    },
  });
```

The workflow enforced by this configuration:

```text
draft ──→ review ──→ published
             │              │
             └──→ draft ←───┘
```

Authors submit to review, reviewers can send it back to draft or approve to published, and published articles can be unpublished back to draft.

### Scheduled Publishing

Combine workflow transitions with scheduled dates to publish content at a specific time. Requires a [queue adapter](/docs/infrastructure/queue-and-jobs).

```ts
// Schedule an article to go live on Monday morning
await app.api.collections.articles.transitionStage(
  {
    id: article.id,
    stage: "published",
    scheduledAt: new Date("2026-03-03T09:00:00Z"),
  },
  ctx,
);
```

The transition is enqueued as a job. When the scheduled time arrives, the queue worker executes the transition. If `scheduledAt` is in the past, the transition executes immediately.

Via HTTP:

```
POST /questpie/articles/{id}/transition
Content-Type: application/json

{
  "stage": "published",
  "scheduledAt": "2026-03-03T09:00:00Z"
}
```

### Global Settings with Staged Rollout

Workflow works on globals too — useful for site-wide configuration that needs approval before going live.

```ts
const siteConfig = qb
  .global("site_config")
  .fields((f) => ({
    siteName: f.text({ required: true }),
    maintenanceMode: f.boolean({ default: false }),
    announcement: f.textarea(),
  }))
  .options({
    versioning: {
      workflow: {
        initialStage: "draft",
        stages: ["draft", "published"],
      },
    },
  });
```

The marketing team edits the draft config, an admin reviews and transitions to published, and the public site always reads `{ stage: "published" }`:

```ts
// Marketing edits the draft
await app.api.globals.site_config.update(
  { announcement: "Big sale this weekend!" },
  marketingCtx,
);

// Admin publishes when ready
await app.api.globals.site_config.transitionStage(
  { stage: "published" },
  adminCtx,
);

// Public site always reads published config
const config = await app.api.globals.site_config.get(
  { stage: "published" },
  publicCtx,
);
```

## Common Mistakes

- **Versioning high-frequency collections** — Collections with frequent writes (analytics, logs) can accumulate many version records. Set a low `maxVersions` or skip versioning entirely for these.
- **Large `richText` or `blocks` fields** — Each version stores a complete snapshot. Large content fields multiply storage requirements. Consider `maxVersions` limits.
- **Not checking `versionOperation`** — When browsing versions, filter by `versionOperation` to distinguish creates, updates, and deletes.
- **Forgetting `stage` on public queries** — Without `stage: "published"`, `find()` reads the main table (draft). Your public API should always pass the target stage explicitly.
- **Restricting transitions too tightly** — If a stage has no `transitions` array, all stages are reachable. An empty `transitions: []` means nothing can transition out of that stage.

## Related Pages

- [Collections](/docs/server/collections) — Collection `.options()` configuration
- [Access Control](/docs/server/access-control) — `access.transition` permission
- [Hooks & Lifecycle](/docs/server/hooks-and-lifecycle) — `beforeTransition` / `afterTransition` hooks
- [Context & Transactions](/docs/server/context-and-transactions) — Transaction behavior
- [CRUD API](/docs/reference/crud-api) — `transitionStage()` method reference
- [Queue & Jobs](/docs/infrastructure/queue-and-jobs) — Scheduled transition job
