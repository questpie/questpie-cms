---
title: Quick Start
description: Build a production-ready CMS application in minutes.
icon: Zap
---

# Quick Start

This guide demonstrates how to define a content schema, initialize the CMS, and perform type-safe data operations. We will build a simple blog schema to illustrate the core concepts.

## 1. Define Content Schema

Collections are defined using the builder API. Create a new file `collections/posts.ts`:

```typescript title="collections/posts.ts"
import { defineCollection } from '@qcms/core'
import { text, timestamp } from 'drizzle-orm/pg-core'

export const posts = defineCollection('posts')
  .fields({
    title: text('title').notNull(),
    slug: text('slug').notNull().unique(),
    content: text('content'),
    publishedAt: timestamp('published_at'),
  })
  .localized(['title', 'content']) // Enable i18n for these fields
  .access({
    read: () => true,       // Public read access
    create: 'admin',        // Restricted create access
    update: 'admin',
    delete: 'admin',
  })
```

## 2. Initialize the CMS

Create a central configuration file to register your collections and connect to the database.

```typescript title="cms.config.ts"
import { createCMS } from '@qcms/core'
import { drizzle } from 'drizzle-orm/postgres-js'
import { posts } from './collections/posts'

export const cms = createCMS({
  collections: [posts],
  db: drizzle(process.env.DATABASE_URL!),
  locale: {
    locales: ['en', 'sk'],
    defaultLocale: 'en',
  },
})
```

## 3. Database Migrations

QUESTPIE relies on Drizzle Kit for managing database schema changes.

```typescript title="drizzle.config.ts"
import { defineConfig } from 'drizzle-kit'
import { cms } from './cms.config'

export default defineConfig({
  schema: cms.getSchema(), // Automatically export schema from CMS
  out: './drizzle',
  dialect: 'postgresql',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
})
```

Generate and apply the migrations:

```bash
bunx drizzle-kit generate
bunx drizzle-kit migrate
```

## 4. Working with Data

The CMS provides a fully typed CRUD API derived from your collection definitions.

```typescript
// 1. Create a request context (typically in your API handler)
const ctx = await cms.createContext({}, {
  user: { id: '1', role: 'admin' },
  locale: 'en',
})

const postsCrud = cms.crud('posts', ctx)

// 2. Create Content
const newPost = await postsCrud.create({
  data: {
    title: 'Hello World',
    slug: 'hello-world',
    content: 'Welcome to my blog.',
    publishedAt: new Date(),
  }
})

// 3. Query Content
const publishedPosts = await postsCrud.findMany({
  where: { publishedAt: { not: null } },
  orderBy: { publishedAt: 'desc' },
  limit: 10,
})
```

## 5. Direct Database Access

For complex analytical queries or performance-critical operations, you can bypass the CMS layer and use Drizzle ORM directly.

```typescript
import { eq, and, sql } from 'drizzle-orm'

const stats = await ctx.db
  .select({
    count: sql<number>`count(*)`,
    month: sql<string>`to_char(${posts.table.publishedAt}, 'YYYY-MM')`
  })
  .from(posts.table)
  .groupBy(sql`to_char(${posts.table.publishedAt}, 'YYYY-MM')`)
```

## Next Steps

<Cards>
  <Card
    title="Defining Collections"
    description="Learn more about the builder API and available field types."
    href="/docs/core-concepts/builder-pattern"
  />
  <Card
    title="Relations"
    description="Connect your collections with type-safe relationships."
    href="/docs/reference/cms/relations"
  />
</Cards>
