---
title: Project Structure
description: Recommended file layout for QUESTPIE projects
---

# Project Structure

QUESTPIE doesn't enforce a specific file structure, but there's a recommended layout that makes the server-first ownership model clear. This structure scales from a single collection to hundreds.

## Recommended Layout

```text
src/
  questpie/
    server/
      builder.ts              ← shared qb with admin module
      cms.ts                  ← compose everything + build()
      rpc.ts                  ← rpc() root instance
      collections/
        index.ts              ← barrel export
        barbers.ts            ← collection definitions
        services.ts
        appointments.ts
        pages.ts
      globals/
        index.ts
        site-settings.ts      ← global definitions
      functions/
        index.ts
        booking.ts            ← RPC function implementations
      jobs/
        index.ts
        email-notifications.ts ← background job definitions
      blocks/
        index.ts
        hero.ts               ← block type definitions
        cta.ts

    admin/
      admin.ts                ← qa() client builder
      fields/                 ← custom field renderers (if any)
      views/                  ← custom view components (if any)
      components/             ← custom UI components (if any)

  routes/
    api/
      cms.ts                  ← mount CMS fetch handler
    admin.tsx                 ← admin panel route

  migrations/
    index.ts                  ← migration list
    0001-initial.ts           ← Drizzle migration files
```

## Why This Works

The layout enforces the WHAT vs HOW split:

| Directory | Responsibility | Defines |
|---|---|---|
| `questpie/server/` | **WHAT** — contracts and behavior | Schema, access, hooks, RPC, jobs |
| `questpie/admin/` | **HOW** — rendering concerns | Branding, locale, custom renderers |
| `routes/` | **Mounting** — HTTP wiring | Route handlers, no business logic |

## File Responsibilities

### `server/builder.ts`

Creates the shared builder with server modules. Every collection and global imports from here:

```ts
import { adminModule } from "@questpie/admin/server";
import { q } from "questpie";

export const qb = q.use(adminModule);
```

If you have custom modules, compose them here:

```ts
export const qb = q.use(adminModule).use(myCustomModule);
```

### `server/cms.ts`

The composition root. This file:
1. Registers all collections and globals
2. Configures sidebar, dashboard, branding
3. Sets up auth, locale, jobs, messages
4. Calls `.build()` with runtime config
5. Exports `AppCMS` type for the client

```ts
export const cms = q({ name: "my-app" })
  .use(baseInstance)  // or .use(adminModule) + individual configs
  .collections({ ... })
  .globals({ ... })
  .sidebar(...)
  .dashboard(...)
  .build({ db: { url: ... }, app: { url: ... } });

export type AppCMS = typeof cms;
```

### `server/rpc.ts`

Keep the `rpc()` root separate. Functions import it to define typed procedures:

```ts
import { rpc } from "questpie";
export const r = rpc();
```

### `server/functions/`

Each file exports RPC functions. They import `r` from `rpc.ts`:

```ts
import { r } from "../rpc";
import z from "zod";

export const getActiveBarbers = r.fn({
  schema: z.object({}),
  handler: async ({ app }) => {
    return app.api.collections.barbers.find({ where: { isActive: true } });
  },
});
```

### `server/collections/`

One file per collection. Each file exports a single collection builder:

```ts
import { qb } from "../builder";

export const barbers = qb
  .collection("barbers")
  .fields(...)
  .admin(...)
  .list(...)
  .form(...);
```

### `admin/admin.ts`

The client-side builder. It only handles rendering concerns:

```ts
import { adminModule, qa } from "@questpie/admin/client";
import type { AppCMS } from "../server/cms";

export const admin = qa<AppCMS>()
  .use(adminModule)
  .branding({ name: "My App" })
  .locale({ locales: ["en", "sk"], defaultLocale: "en" });
```

### `routes/api/cms.ts`

Thin route handler. No business logic here:

```ts
import { createFetchHandler } from "questpie";
import { cms, appRpc } from "@/questpie/server/cms";

export const handler = createFetchHandler(cms, {
  basePath: "/api/cms",
  rpc: appRpc,
});
```

## Scaling Patterns

### Large Collection Files

If a collection definition gets long (100+ lines), extract helper functions into the same file rather than splitting the definition across files:

```ts
// collections/barbers.ts
function dayScheduleFields(f: FieldBuilder) {
  return {
    isOpen: f.boolean({ ... }),
    start: f.time({ ... }),
    end: f.time({ ... }),
  };
}

export const barbers = qb
  .collection("barbers")
  .fields((f) => ({
    name: f.text({ ... }),
    workingHours: f.object({
      fields: () => ({
        monday: f.object({ fields: dayScheduleFields }),
        tuesday: f.object({ fields: dayScheduleFields }),
        // ...
      }),
    }),
  }));
```

### Shared Field Patterns

For field patterns used across multiple collections (e.g., SEO fields, slug fields), create utility functions:

```ts
// server/utils/fields.ts
export function seoFields(f: FieldBuilder) {
  return {
    metaTitle: f.text({ label: { en: "Meta Title" }, maxLength: 255, localized: true }),
    metaDescription: f.textarea({ label: { en: "Meta Description" }, localized: true }),
  };
}
```

### Module Composition

For reusable feature bundles, use the `.use()` pattern:

```ts
// modules/blog-module.ts
export const blogModule = q({ name: "blog" })
  .collections({ posts, categories, tags })
  .sidebar(...)
  .dashboard(...);
```

Then compose in your main builder:

```ts
export const cms = q({ name: "my-app" })
  .use(adminModule)
  .use(blogModule)
  .build({ ... });
```

## Anti-Patterns

- **Putting schema rules in client code** — Field validation, access control, and hooks belong on the server. The client should only define how things render.
- **Splitting a collection across files** — Keep the entire `.collection().fields().admin().list().form()` chain in one file. It's the single source of truth for that entity.
- **Business logic in route handlers** — Route files should only mount handlers. Business logic goes in RPC functions, hooks, or jobs.
- **Hardcoding view components** — Use the registry pattern for custom views. Hardcoded component references break the introspection contract.

## Related Pages

- [Quickstart](/docs/getting-started/quickstart) — Build your first CMS
- [Collections](/docs/server/collections) — Full collection builder API
- [Modules & Extensions](/docs/server/modules-and-extensions) — Reusable builder composition
- [Mentality](/docs/mentality) — Architecture principles behind this structure
