---
title: First Platform Walkthrough
description: Build a complete server-first backend with multiple collections, relations, sidebar, and dashboard
---

# First Platform Walkthrough

This walkthrough goes beyond the quickstart. You'll build a schema-first backend with multiple collections, relations between them, a custom sidebar, reactive fields, and a typed RPC function — the same patterns used in the Barbershop reference project.

## What You'll Build

- A `services` collection with name, price, and duration
- A `barbers` collection with profile info and a many-to-many relation to services
- A `barberServices` junction collection for the many-to-many link
- Server-defined sidebar, admin config, and form layouts
- A typed RPC function
- Client admin configuration

## Step 1: Server Builder

```ts
// src/questpie/server/builder.ts
import { adminModule } from "@questpie/admin/server";
import { q } from "questpie";

export const qb = q.use(adminModule);
```

## Step 2: Services Collection

Start with a simple collection for the services your business offers:

```ts
// src/questpie/server/collections/services.ts
import { qb } from "../builder";

export const services = qb
  .collection("services")
  .fields((f) => ({
    name: f.text({
      label: { en: "Name" },
      required: true,
      maxLength: 255,
      localized: true,
    }),
    description: f.textarea({
      label: { en: "Description" },
      localized: true,
    }),
    image: f.upload({
      to: "assets",
      label: { en: "Image" },
    }),
    duration: f.number({
      required: true,
      label: { en: "Duration (minutes)" },
    }),
    price: f.number({
      required: true,
      label: { en: "Price (cents)" },
    }),
    isActive: f.boolean({
      label: { en: "Active" },
      default: true,
      required: true,
    }),
  }))
  .title(({ f }) => f.name)
  .admin(({ c }) => ({
    label: { en: "Services" },
    icon: c.icon("ph:scissors"),
  }))
  .list(({ v }) => v.table({}))
  .form(({ v, f }) =>
    v.form({
      sidebar: {
        position: "right",
        fields: [f.isActive, f.image],
      },
      fields: [
        {
          type: "section",
          label: { en: "Service Info" },
          layout: "grid",
          columns: 2,
          fields: [f.name, f.duration, f.price],
        },
        {
          type: "section",
          label: { en: "Description" },
          fields: [f.description],
        },
      ],
    }),
  );
```

Notice the form layout — fields are organized into sections with grid layouts. The sidebar holds quick-access fields like status toggles and image uploads.

## Step 3: Junction Collection

For many-to-many relations, you need a junction collection:

```ts
// src/questpie/server/collections/barber-services.ts
import { qb } from "../builder";

export const barberServices = qb
  .collection("barberServices")
  .fields((f) => ({
    barber: f.relation({
      to: "barbers",
      required: true,
      label: { en: "Barber" },
      onDelete: "cascade",
    }),
    service: f.relation({
      to: "services",
      required: true,
      label: { en: "Service" },
      onDelete: "cascade",
    }),
  }))
  .admin(({ c }) => ({
    label: { en: "Barber Services" },
    icon: c.icon("ph:link"),
  }))
  .list(({ v }) => v.table({}))
  .form(({ v, f }) =>
    v.form({
      fields: [f.barber, f.service],
    }),
  );
```

## Step 4: Barbers Collection with Relations

Now the barbers collection, which uses a many-to-many relation through the junction table:

```ts
// src/questpie/server/collections/barbers.ts
import { uniqueIndex } from "drizzle-orm/pg-core";
import { qb } from "../builder";

export const barbers = qb
  .collection("barbers")
  .fields((f) => ({
    name: f.text({
      label: { en: "Full Name" },
      required: true,
      maxLength: 255,
    }),
    slug: f.text({
      label: { en: "Slug" },
      description: { en: "URL-friendly identifier (auto-generated from name)" },
      required: true,
      maxLength: 255,
      input: "optional",
      meta: {
        admin: {
          compute: {
            handler: ({ data, prev }) => {
              if (
                data.name &&
                (!data.slug || data.slug === slugify(String(prev.data.name ?? "")))
              ) {
                return slugify(String(data.name));
              }
              return data.slug;
            },
            deps: ({ data }) => [data.name, data.slug],
            debounce: 300,
          },
        },
      },
    }),
    email: f.email({
      label: { en: "Email" },
      required: true,
      maxLength: 255,
    }),
    phone: f.text({
      label: { en: "Phone" },
      maxLength: 50,
    }),
    bio: f.richText({
      label: { en: "Biography" },
      localized: true,
    }),
    avatar: f.upload({
      label: { en: "Profile Photo" },
      to: "assets",
      mimeTypes: ["image/*"],
      maxSize: 5_000_000,
    }),
    isActive: f.boolean({
      label: { en: "Active" },
      default: true,
      required: true,
    }),
    // Many-to-many relation through junction table
    services: f.relation({
      to: "services",
      hasMany: true,
      through: "barberServices",
      sourceField: "barber",
      targetField: "service",
      label: { en: "Services Offered" },
    }),
  }))
  .indexes(({ table }) => [
    uniqueIndex("barbers_slug_unique").on(table.slug),
    uniqueIndex("barbers_email_unique").on(table.email),
  ])
  .title(({ f }) => f.name)
  .admin(({ c }) => ({
    label: { en: "Barbers" },
    icon: c.icon("ph:users"),
  }))
  .list(({ v }) => v.table({}))
  .form(({ v, f }) =>
    v.form({
      sidebar: {
        position: "right",
        fields: [f.isActive, f.avatar],
      },
      fields: [
        {
          type: "section",
          label: { en: "Contact Information" },
          layout: "grid",
          columns: 2,
          fields: [f.name, f.slug, f.email, f.phone],
        },
        {
          type: "section",
          label: { en: "Profile" },
          fields: [f.bio],
        },
        {
          type: "section",
          label: { en: "Services" },
          fields: [f.services],
        },
      ],
    }),
  )
  .hooks({
    beforeValidate: async ({ data }) => {
      const d = data as { name?: string; slug?: string };
      if (d.name && !d.slug) {
        d.slug = slugify(d.name);
      }
    },
  });

function slugify(str: string): string {
  return str
    .normalize("NFD")
    .replace(/[\u0300-\u036f]/g, "")
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/(^-|-$)/g, "")
    .slice(0, 255);
}
```

Key patterns here:
- **Reactive `compute`** auto-generates the slug from the name in the admin form
- **`input: "optional"`** means the API accepts slug but doesn't require it
- **`beforeValidate` hook** generates the slug on the server as a fallback
- **`indexes`** enforces unique slugs and emails at the database level
- **Many-to-many relation** uses `through`, `sourceField`, and `targetField`

## Step 5: Compose Everything

```ts
// src/questpie/server/cms.ts
import { q, rpc } from "questpie";
import { adminModule } from "@questpie/admin/server";
import z from "zod";
import { barbers } from "./collections/barbers";
import { barberServices } from "./collections/barber-services";
import { services } from "./collections/services";

const r = rpc();

export const getActiveBarbers = r.fn({
  schema: z.object({}),
  handler: async ({ app }) => {
    const result = await app.api.collections.barbers.find({
      where: { isActive: true },
    });
    return {
      barbers: result.docs,
      total: result.totalDocs,
    };
  },
});

export const appRpc = r.router({ getActiveBarbers });

export const cms = q({ name: "my-first-platform" })
  .use(adminModule)
  .collections({ barbers, services, barberServices })
  .sidebar(({ s, c }) =>
    s.sidebar({
      sections: [
        s.section({
          id: "overview",
          title: { en: "Overview" },
          items: [
            {
              type: "link",
              label: { en: "Dashboard" },
              href: "/admin",
              icon: c.icon("ph:house"),
            },
          ],
        }),
        s.section({
          id: "content",
          title: { en: "Content" },
          items: [
            { type: "collection", collection: "services" },
            { type: "collection", collection: "barbers" },
          ],
        }),
      ],
    }),
  )
  .branding({ name: { en: "My Platform" } })
  .auth({
    emailAndPassword: { enabled: true },
    baseURL: process.env.APP_URL || "http://localhost:3000",
    basePath: "/api/cms/auth",
    secret: process.env.BETTER_AUTH_SECRET || "dev-secret",
  })
  .build({
    db: { url: process.env.DATABASE_URL! },
    app: { url: process.env.APP_URL || "http://localhost:3000" },
  });

export type AppCMS = typeof cms;
export type AppRpc = typeof appRpc;
```

## Step 6: Admin Client

```ts
// src/questpie/admin/admin.ts
import { adminModule, qa } from "@questpie/admin/client";
import type { AppCMS } from "../server/cms";

export const admin = qa<AppCMS>()
  .use(adminModule);
```

## Step 7: Mount API

```ts
// src/routes/api/cms.ts
import { createFetchHandler } from "questpie";
import { cms, appRpc } from "@/questpie/server/cms";

export const handler = createFetchHandler(cms, {
  basePath: "/api/cms",
  rpc: appRpc,
});
```

## What You Now Have

- **3 collections** with typed CRUD APIs
- **Many-to-many relation** between barbers and services
- **Reactive slug field** that auto-generates from the name
- **Custom sidebar** with organized sections
- **Server-side hooks** for data processing
- **Database indexes** for unique constraints
- **Typed RPC** for custom business logic
- **Admin panel** that renders everything automatically from the server blueprint

## Common Mistakes

- **Circular relation references** — Define the junction collection (`barberServices`) before the collections that reference it, or use string references in `through`.
- **Forgetting `onDelete` on junction relations** — Without `onDelete: "cascade"`, deleting a barber leaves orphaned junction rows.
- **Expecting duplicate sidebar items** — Explicitly listed collections/globals are automatically excluded from the auto-generated section.

## Next Steps

- [Collections](/docs/server/collections) — Full builder API with all options
- [Relations](/docs/server/relations) — All relation types: belongsTo, hasMany, manyToMany
- [Reactive Fields](/docs/server/reactive-fields) — compute, hidden, readOnly, disabled
- [Dashboard & Sidebar](/docs/admin/dashboard-sidebar-branding) — Widgets and navigation
- [Infrastructure](/docs/infrastructure) — Add auth, storage, email, and more
