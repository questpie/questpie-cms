---
title: Quickstart
description: Build a working QUESTPIE runtime in 5 minutes
---

# Quickstart

This is the shortest path to a working QUESTPIE runtime: one collection, a REST API, and a typed RPC function. Admin is an optional extension you can add after the baseline works.

If you prefer to start with the admin interface immediately, see [First Platform Walkthrough](/docs/getting-started/first-platform-walkthrough).

## Prerequisites

- Bun 1.3+ (or Node 20+)
- PostgreSQL running locally
- TypeScript project initialized

## Step 1: Install Runtime Baseline

```bash
bun add questpie zod  # zod is used below for RPC schema
bun add @questpie/hono hono  # or @questpie/elysia, @questpie/next
```

## Step 2: Define a Collection

Collections are the core building block. Each collection becomes a database table and CRUD API.

```ts
// src/questpie/server/collections/posts.ts
import { q } from "questpie";

export const posts = q.collection("posts").fields((f) => ({
  title: f.text({ required: true }),
  slug: f.text({ required: true, input: "optional" }),
  content: f.richText(),
  published: f.boolean({ default: false, required: true }),
}));
```

This single definition produces:
- A `posts` PostgreSQL table with `id`, `title`, `slug`, `content`, `published`, `createdAt`, `updatedAt`
- CRUD API endpoints: `GET/POST /collections/posts`, `GET/PATCH/DELETE /collections/posts/:id`

## Step 3: Compose the Runtime

Wire collections together, add RPC functions, and build the runtime instance:

```ts
// src/questpie/server/cms.ts
import { q, rpc } from "questpie";
import z from "zod";
import { posts } from "./collections/posts";

const r = rpc();

export const healthcheck = r.fn({
  schema: z.object({}),
  handler: async () => ({ ok: true, timestamp: new Date().toISOString() }),
});

export const appRpc = r.router({ healthcheck });

export const cms = q({ name: "quickstart" })
  .collections({ posts })
  .build({
    db: { url: process.env.DATABASE_URL! },
    app: { url: process.env.APP_URL || "http://localhost:3000" },
  });

export type AppCMS = typeof cms;
export type AppRpc = typeof appRpc;
```

## Step 4: Mount the API

Create a route handler that serves your runtime API:

```ts
// src/routes/api/cms.ts (Hono example)
import { questpieHono } from "@questpie/hono";
import { cms, appRpc } from "@/questpie/server/cms";

export const cmsApp = questpieHono(cms, {
  basePath: "/api/cms",
  rpc: appRpc,
});
```

Or with the generic fetch handler (works with any Fetch-compatible framework):

```ts
import { createFetchHandler } from "questpie";
import { cms, appRpc } from "@/questpie/server/cms";

export const handler = createFetchHandler(cms, {
  basePath: "/api/cms",
  rpc: appRpc,
});
```

## Step 5: Verify

Start your dev server and test these endpoints:

```bash
# List posts (empty at first)
curl http://localhost:3000/api/cms/collections/posts

# Create a post
curl -X POST http://localhost:3000/api/cms/collections/posts \
  -H "Content-Type: application/json" \
  -d '{"title": "Hello World", "slug": "hello-world", "published": true}'

# Call RPC function
curl -X POST http://localhost:3000/api/cms/rpc/healthcheck \
  -H "Content-Type: application/json" \
  -d '{}'
```

At this point you have a working runtime contract: DB-backed CRUD + typed RPC over HTTP.

## Optional: Add the Admin Interface

When you need an internal UI, add admin as a module:

```bash
bun add @questpie/admin
```

```ts
// src/questpie/server/builder.ts
import { adminModule } from "@questpie/admin/server";
import { q } from "questpie";

export const qb = q.use(adminModule);
```

```ts
// src/questpie/admin/builder.ts
import { adminModule, qa } from "@questpie/admin/client";
import type { AppCMS } from "../server/cms";

export const admin = qa<AppCMS>().use(adminModule);
```

Collections defined with `qb.collection(...)` can now use `.admin()`, `.list()`, and `.form()`. Admin login also requires runtime auth configuration via `.auth({ ... })`.

## What This Proves

1. **Runtime comes first** — field definitions drive database behavior and API contracts.
2. **RPC is typed end-to-end** — Zod validates input and TypeScript infers return types.
3. **Adapters are thin transport layers** — Hono/Elysia/Next only mount the runtime.
4. **Admin is additive** — you can attach it later without redefining schema.

## Common Mistakes

- **Treating admin as baseline** — Start with runtime dependencies and one adapter.
- **Forgetting `input: "optional"` for derived fields** — Use it for values that can be auto-generated (like slugs).
- **Not building** — The `.build()` call is what creates the runtime instance. Without it, you have a builder, not a running backend.

## Next Steps

- [First Platform Walkthrough](/docs/getting-started/first-platform-walkthrough) — Full admin-enabled walkthrough
- [Collections](/docs/server/collections) — Full collection builder API
- [Field Types](/docs/server/field-types) — Complete catalog of built-in field types
- [Mentality](/docs/mentality) — Understand the architecture principles
