---
title: Getting Started
description: Start building with QUESTPIE's server-first architecture
---

# Getting Started

QUESTPIE is a server-first TypeScript CMS framework. You define your data schema, admin UI blueprint, access rules, and business logic on the server — the admin panel renders it automatically.

## The Mental Model

```text
Server (q + admin server module)
  → fields, collections, globals         — your data schema
  → .admin(), .list(), .form()           — admin UI blueprint
  → .sidebar(), .dashboard()             — navigation layout
  → hooks, access, rpc, jobs             — behavior
  → introspection contract               — bridge to admin

Client (qa + admin client module)
  → field / view / component registries  — how things render
  → branding, locale, UI overrides       — look and feel
```

The server defines **WHAT** your CMS is. The client defines **HOW** it looks. If you keep this split clear, the framework stays simple at any scale.

## Fast Path

### 1. Install packages

```bash
bun add questpie @questpie/admin zod
```

### 2. Create a server builder

```ts
// src/questpie/server/builder.ts
import { adminModule } from "@questpie/admin/server";
import { q } from "questpie";

export const qb = q.use(adminModule);
```

### 3. Define a collection

```ts
// src/questpie/server/collections/posts.ts
import { qb } from "../builder";

export const posts = qb
  .collection("posts")
  .fields((f) => ({
    title: f.text({ label: { en: "Title" }, required: true }),
    slug: f.text({ label: { en: "Slug" }, required: true, input: "optional" }),
    content: f.richText({ label: { en: "Content" } }),
    published: f.boolean({ label: { en: "Published" }, default: false, required: true }),
  }))
  .admin(({ c }) => ({
    label: { en: "Posts" },
    icon: c.icon("ph:article"),
  }))
  .list(({ v, f }) => v.table({ columns: [f.title, f.published] }))
  .form(({ v, f }) =>
    v.form({
      fields: [f.title, f.content],
      sidebar: { position: "right", fields: [f.slug, f.published] },
    }),
  );
```

### 4. Build and mount the CMS

```ts
// src/questpie/server/cms.ts
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { posts } from "./collections/posts";

export const cms = q({ name: "my-cms" })
  .use(adminModule)
  .collections({ posts })
  .build({
    db: { url: process.env.DATABASE_URL },
    app: { url: process.env.APP_URL || "http://localhost:3000" },
  });

export type AppCMS = typeof cms;
```

### 5. Configure the admin client

```ts
// src/questpie/admin/admin.ts
import { adminModule, qa } from "@questpie/admin/client";
import type { AppCMS } from "../server/cms";

export const admin = qa<AppCMS>()
  .use(adminModule)
  .branding({ name: "My CMS" });
```

## Common Mistakes

- **Duplicating schema in the client** — The server is the single source of truth. The client admin config should only handle rendering concerns (branding, locale, custom renderers).
- **Forgetting the server module** — You need `q.use(adminModule)` on the server side, not just `qa.use(adminModule)` on the client.
- **Hardcoding views** — Use the registry pattern instead of hardcoding component references.

## Next Steps

- [Installation](/docs/getting-started/installation) — Prerequisites and package setup
- [Quickstart](/docs/getting-started/quickstart) — Working CMS in 5 minutes
- [Your First CMS](/docs/getting-started/your-first-cms) — Deeper walkthrough with multiple collections
- [Project Structure](/docs/getting-started/project-structure) — Recommended file layout
