---
title: Getting Started
description: Start with the runtime, then add optional interface layers
---

# Getting Started

QUESTPIE starts with a runtime contract. Define schema, behavior, access, and endpoints in `questpie` first. Then add interface layers like `@questpie/admin` only when needed.

## The Mental Model

```text
Runtime (q)
  → fields, collections, globals         — data contract
  → hooks, access, rpc, jobs             — behavior
  → HTTP handler + adapters              — API surface

Optional interface (@questpie/admin)
  → server module                        — admin blueprint methods
  → client module                        — rendering registries
```

Keep this split clear: runtime defines **WHAT** exists, interfaces define **HOW** it renders.

## Fast Path (Runtime Baseline)

### 1. Install baseline packages

```bash
bun add questpie zod drizzle-orm postgres
bun add @questpie/hono hono  # or @questpie/elysia, @questpie/next
```

### 2. Define a collection

```ts
import { q } from "questpie";

// src/questpie/server/collections/posts.ts
export const posts = q.collection("posts").fields((f) => ({
  title: f.text({ required: true }),
  slug: f.text({ required: true, input: "optional" }),
  content: f.richText(),
  published: f.boolean({ default: false, required: true }),
}));
```

### 3. Build runtime + RPC

```ts
// src/questpie/server/cms.ts
import { q, rpc } from "questpie";
import z from "zod";
import { posts } from "./collections/posts";

const r = rpc();

export const healthcheck = r.fn({
  schema: z.object({}),
  handler: async () => ({ ok: true }),
});

export const appRpc = r.router({ healthcheck });

export const cms = q({ name: "my-app" })
  .collections({ posts })
  .build({
    db: { url: process.env.DATABASE_URL! },
    app: { url: process.env.APP_URL || "http://localhost:3000" },
  });

export type AppCMS = typeof cms;
```

### 4. Mount your API handler

```ts
// src/routes/api/cms.ts
import { createFetchHandler } from "questpie";
import { appRpc, cms } from "@/questpie/server/cms";

export const handler = createFetchHandler(cms, {
  basePath: "/api/cms",
  rpc: appRpc,
});
```

## Optional: Add the Admin Interface

Install and register `@questpie/admin` only when you want the generated admin UI:

```bash
bun add @questpie/admin
```

```ts
// src/questpie/server/builder.ts
import { adminModule } from "@questpie/admin/server";
import { q } from "questpie";

export const qb = q.use(adminModule);
```

```ts
// src/questpie/admin/builder.ts
import { adminModule, qa } from "@questpie/admin/client";
import type { AppCMS } from "../server/cms";

export const admin = qa<AppCMS>().use(adminModule);
```

When you need admin-specific view metadata, define those collections with `qb.collection(...)` and add `.admin()`, `.list()`, and `.form()`.

## Common Mistakes

- **Treating admin as required** — It is optional. Start with `questpie` runtime + one adapter.
- **Duplicating schema in the client** — Keep schema in server builders; client code should consume contracts.
- **Registering admin only on one side** — If you adopt admin, use `@questpie/admin/server` on server and `@questpie/admin/client` in UI.

## Next Steps

- [Installation](/docs/getting-started/installation) — Required baseline vs optional modules
- [Quickstart](/docs/getting-started/quickstart) — Runtime-first walkthrough
- [Project Structure](/docs/getting-started/project-structure) — Recommended file layout
- [First Platform Walkthrough](/docs/getting-started/first-platform-walkthrough) — Full admin-enabled walkthrough
