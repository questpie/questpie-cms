---
title: Authentication
description: Setting up and configuring authentication with Better Auth.
---

# Authentication

QUESTPIE CMS uses **Better Auth** for handling user authentication with full type safety and composability.

## Core Auth Setup

The CMS core module comes with sensible auth defaults:

- **Plugins**: `admin()`, `apiKey()`, `bearer()`
- **Collections**: `user`, `session`, `account`, `verification`, `apikey`
- **Email & Password**: Enabled with email verification

```typescript
import { defineQCMS } from "@questpie/cms/server";

export const cms = defineQCMS({ name:'app' }).build({
  app: { url: process.env.APP_URL },
  db: { url: process.env.DATABASE_URL },
});

// TypeScript knows available auth methods:
await cms.auth.api.signIn.email({ email, password }); // ✅
await cms.auth.api.createApiKey({ name: "My API Key" }); // ✅
```

## Adding Plugins

### Type-Safe Plugin Extension

Add plugins with the `.auth()` method. TypeScript will automatically infer available API methods:

```typescript
import { organization } from "better-auth/plugins";

export const cms = defineQCMS({ name:'app' })
  .auth({
    plugins: [organization()],
  })
  .build({
    /* ... */
  });

// TypeScript knows the organization plugin is available now:
await cms.auth.api.createOrganization({ name: "Acme Corp" }); // ✅
```

**Without the plugin**, TypeScript will error:

```typescript
const cmsWithoutOrg = defineQCMS({ name:'app' }).build({
  /* ... */
});

await cmsWithoutOrg.auth.api.createOrganization(); // ❌ Type error!
```

### Composable Modules

Create reusable auth modules for better organization:

```typescript
import { defineQCMS } from "@questpie/cms/server";
import { organization, twoFactor } from "better-auth/plugins";

// Define a reusable organization module
const organizationModule = defineQCMS({ name: "org-module" }).auth({
  plugins: [organization()],
});

// Compose modules together
export const cms =  defineQCMS({ name:'app' })
  .use(organizationModule) // Merge organization module
  .auth({
    plugins: [twoFactor()], // Add more plugins
  })
  .build({
    /* ... */
  });

// All plugin methods are available and type-safe:
await cms.auth.api.createOrganization({ name: "Acme" }); // ✅
await cms.auth.api.sendTwoFactorCode({ userId }); // ✅
```

## Extending Auth Models

### Adding Custom Fields

Use the callback pattern to progressively extend or override auth models with full type safety:

```typescript
export const cms = defineQCMS({ name:'app' })
  .auth((oldAuth) => ({
    user: {
      additionalFields: {
        role: { type: "string", required: true },
        department: { type: "string", required: false },
      },
    },
  }))
  .build({
    /* ... */
  });

// TypeScript knows the new fields exist:
type Session = typeof cms.auth.$Infer.Session;
// Session.user.role is string
// Session.user.department is string | null
```

### Granular Field Overrides

The callback pattern allows you to reference and override previous configurations:

```typescript
export const cms = defineQCMS({ name:'app' })
  .auth((oldAuth) => ({
    // First call: oldAuth is empty, so don't spread it, don't worry typescript will warn you
    user: {
      additionalFields: {
        score: { type: "number", required: true },
      },
    },
  }))
  .auth((oldAuth) => ({
    // Second call: oldAuth has the previous config already, and typescript knows about it
    user: {
      ...oldAuth.user, // ✅ Now you can spread
      additionalFields: {
        ...oldAuth.user.additionalFields,
        score: {
          type: "number",
          // Reference old field properties
          required: oldAuth.user.additionalFields.score.required,
          defaultValue: 0, // Add new properties
        },
        level: { type: "string", required: true }, // Add new field
      },
    },
  }))
  .build({
    /* ... */
  });

type Session = typeof cms.auth.$Infer.Session;
// Session.user.score is number (with defaultValue: 0)
// Session.user.level is string
```

### Syncing with Collections

When adding `additionalFields`, update your collections to match the typescript definitions:

```typescript
import { coreModule } from "@questpie/cms/server";
import { defineCollection } from "@questpie/cms/server";
import { varchar, boolean } from "drizzle-orm/pg-core";

const user = coreModule.collections.user.merge(
  defineCollection("user").fields({
    newField: varchar("new_field").notNull(),
  }).virtual(({table}) => ({ // typescript knows what fields exist on the table
    fullName: sql`${table.firstName} || ' ' || ${table.lastName}`,
  })),
);

export const cms = defineQCMS({ name:'app' })
  .collections({ user }) // Override the user collection
  .auth({
    user: {
      additionalFields: {
        newField: { type: "string", required: true },
        fullName: { type: "string", required: false}
      },
    },
  })
  .build({
    /* ... */
  });
```

## Advanced Configuration

### Custom Social Providers

```typescript
export const cms = defineQCMS({ name:'app' })
  .auth({
    socialProviders: {
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID!,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      },
      github: {
        clientId: process.env.GITHUB_CLIENT_ID!,
        clientSecret: process.env.GITHUB_CLIENT_SECRET!,
      },
    },
  })
  .build({
    /* ... */
  });
```

### Environment Configuration

```typescript

export const cms = createCoreModule()
  .auth({
    baseURL: process.env.BETTER_AUTH_URL,
    secret: process.env.BETTER_AUTH_SECRET,
    advanced: {
      useSecureCookies: process.env.NODE_ENV === "production",
    },
  })
  .build({
    /* ... */
  });
```

## Type Inference

The auth configuration is fully type-safe throughout the builder chain. TypeScript knows:

1. **Available API methods** - Based on enabled plugins
2. **Session/User types** - Including custom `additionalFields`
3. **Database schema** - Synced with Drizzle collections

```typescript
const cms = defineQCMS({ name:'app' })
  .auth({ plugins: [organization()] })
  .auth({
    user: {
      additionalFields: {
        customField: { type: "string", required: true },
      },
    },
  })
  .build({
    /* ... */
  });

// All types are inferred correctly:
type Session = typeof cms.auth.$Infer.Session;
// {
//   user: {
//     id: string;
//     email: string;
//     customField: string; // ✅ Custom field included
//     // ... other Better Auth fields
//   }
//   // ... session fields
// }

// API methods are type-safe:
cms.auth.api.createOrganization; // ✅ Exists (organization plugin)
cms.auth.api.createUser; // ✅ Exists (admin plugin from core)
cms.auth.api.signIn.email; // ✅ Exists (email/password enabled)
```

## Best Practices

### 1. Use the Core Module

Start with `createCoreModule()` for batteries-included auth setup.

### 2. Compose with Modules

Create reusable auth configurations for different features:

```typescript
// modules/auth/organization.ts
export const orgAuthModule = defineQCMS({ name: "org" }).auth({
  plugins: [organization()],
});

// modules/auth/two-factor.ts
export const twoFactorModule = defineQCMS({ name: "2fa" }).auth({
  plugins: [twoFactor()],
});

// app.ts
export const cms = createCoreModule()
  .use(orgAuthModule)
  .use(twoFactorModule)
  .build({
    /* ... */
  });
```

### 3. Progressive Enhancement

Use the callback pattern to build on previous configurations:

```typescript
const cms = createCoreModule()
  .auth((prev) => ({
    user: {
      ...prev.user,
      additionalFields: {
        ...prev.user?.additionalFields,
        newField: { type: "string", required: true },
      },
    },
  }))
  .build({
    /* ... */
  });
```

### 4. Keep Collections in Sync

Always update your Drizzle collections when adding `additionalFields`:

```typescript
const user = coreModule.collections.user.merge(
  defineCollection("user").fields({
    // Match your additionalFields here
  }),
);
```

## Reference

- **Better Auth Docs**: [better-auth.com](https://better-auth.com/)
- **Available Plugins**: [better-auth.com/docs/plugins](https://better-auth.com/docs/plugins)
- **Core Module**: `/packages/cms/src/server/modules/core/core.module.ts`
