---
title: Authentication
description: Setting up and configuring authentication with Better Auth.
---

QUESTPIE uses **Better Auth** for handling user authentication with full type safety and composability.

## Core Auth Setup

To enable authentication, use `adminModule` from `@questpie/admin/server` which provides:

- **Auth collections**: `user`, `session`, `account`, `verification`, `apikey`
- **Core plugins**: `admin()`, `apiKey()`, `bearer()`
- **Email & Password**: Enabled with email verification
- **Assets collection**: Pre-configured with file upload support
- **Saved views collection**: For admin UI filter configurations
- **Setup functions**: `isSetupRequired` and `createFirstAdmin` for bootstrapping

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";

export const app = q({ name: "app" })
  .use(adminModule) // Required for auth collections
  .build({
    app: { url: process.env.APP_URL },
    db: { url: process.env.DATABASE_URL },
  });

// TypeScript knows available auth methods:
await app.auth.api.signIn.email({ email, password }); // ✅
await app.auth.api.createApiKey({ name: "My API Key" }); // ✅
```

> **Note:** Without `adminModule`, you won't have auth database tables (users, sessions, etc.). The `adminModule` is the recommended way to get started with authentication and the admin panel.

## Adding Plugins

### Type-Safe Plugin Extension

Add plugins with the `.auth()` method. TypeScript will automatically infer available API methods:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { organization } from "better-auth/plugins";

export const app = q({ name: "app" })
  .use(adminModule) // Provides auth collections
  .auth({
    plugins: [organization()],
  })
  .build({
    /* ... */
  });

// TypeScript knows the organization plugin is available now:
await app.auth.api.createOrganization({ name: "Acme Corp" }); // ✅
```

**Without the plugin**, TypeScript will error:

```typescript
const cmsWithoutOrg = q({ name: "app" }).use(adminModule).build({
  /* ... */
});

await cmsWithoutOrg.auth.api.createOrganization(); // ❌ Type error!
```

**Without the plugin**, TypeScript will error:

```typescript
const cmsWithoutOrg = q({ name: "app" }).build({
  /* ... */
});

await cmsWithoutOrg.auth.api.createOrganization(); // ❌ Type error!
```

### Composable Modules

Create reusable auth modules for better organization:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { organization, twoFactor } from "better-auth/plugins";

// Define a reusable organization module (auth OPTIONS only)
const organizationModule = q({ name: "org-module" }).auth({
  plugins: [organization()],
});

// Compose modules together
export const app = q({ name: "app" })
  .use(adminModule) // Provides auth collections
  .use(organizationModule) // Merge organization module (adds plugins)
  .auth({
    plugins: [twoFactor()], // Add more plugins
  })
  .build({
    /* ... */
  });

// All plugin methods are available and type-safe:
await app.auth.api.createOrganization({ name: "Acme" }); // ✅
await app.auth.api.sendTwoFactorCode({ userId }); // ✅
```

## Extending Auth Models

### Adding Custom Fields

Use the callback pattern to progressively extend or override auth models with full type safety:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";

export const app = q({ name: "app" })
  .use(adminModule)
  .auth((oldAuth) => ({
    user: {
      additionalFields: {
        profileCompleted: { type: "boolean", required: true },
        department: { type: "string", required: false },
      },
    },
  }))
  .build({
    /* ... */
  });

// TypeScript knows the new fields exist:
type Session = typeof app.auth.$Infer.Session;
// Session.user.profileCompleted is boolean
// Session.user.department is string | null
```

### Granular Field Overrides

The callback pattern allows you to reference and override previous configurations:

```typescript
export const app = q({ name: "app" })
  .auth((oldAuth) => ({
    // First call: oldAuth is empty, so don't spread it, don't worry typescript will warn you
    user: {
      additionalFields: {
        score: { type: "number", required: true },
      },
    },
  }))
  .auth((oldAuth) => ({
    // Second call: oldAuth has the previous config already, and typescript knows about it
    user: {
      ...oldAuth.user, // ✅ Now you can spread
      additionalFields: {
        ...oldAuth.user.additionalFields,
        score: {
          type: "number",
          // Reference old field properties
          required: oldAuth.user.additionalFields.score.required,
          defaultValue: 0, // Add new properties
        },
        level: { type: "string", required: true }, // Add new field
      },
    },
  }))
  .build({
    /* ... */
  });

type Session = typeof app.auth.$Infer.Session;
// Session.user.score is number (with defaultValue: 0)
// Session.user.level is string
```

### Syncing with Collections

When adding `additionalFields`, update your collections to match the typescript definitions:

```typescript
import { coreModule } from "questpie";
import { q } from "questpie";
import { varchar, boolean } from "drizzle-orm/pg-core";

const user = coreModule.collections.user.merge(
  q
    .collection("user")
    .fields({
      newField: varchar("new_field").notNull(),
    })
    .virtual(({ table }) => ({
      // typescript knows what fields exist on the table
      fullName: sql`${table.firstName} || ' ' || ${table.lastName}`,
    })),
);

export const app = q({ name: "app" })
  .collections({ user }) // Override the user collection
  .auth({
    user: {
      additionalFields: {
        newField: { type: "string", required: true },
        fullName: { type: "string", required: false },
      },
    },
  })
  .build({
    /* ... */
  });
```

## Advanced Configuration

### Custom Social Providers

```typescript
export const app = q({ name: "app" })
  .auth({
    socialProviders: {
      google: {
        clientId: process.env.GOOGLE_CLIENT_ID!,
        clientSecret: process.env.GOOGLE_CLIENT_SECRET!,
      },
      github: {
        clientId: process.env.GITHUB_CLIENT_ID!,
        clientSecret: process.env.GITHUB_CLIENT_SECRET!,
      },
    },
  })
  .build({
    /* ... */
  });
```

### Environment Configuration

```typescript
export const app = q({ name: "app" })
  .auth({
    baseURL: process.env.BETTER_AUTH_URL,
    secret: process.env.BETTER_AUTH_SECRET,
    advanced: {
      useSecureCookies: process.env.NODE_ENV === "production",
    },
  })
  .build({
    /* ... */
  });
```

## Type Inference

The auth configuration is fully type-safe throughout the builder chain. TypeScript knows:

1. **Available API methods** - Based on enabled plugins
2. **Session/User types** - Including custom `additionalFields`
3. **Database schema** - Synced with Drizzle collections

```typescript
const app = q({ name: "app" })
  .auth({ plugins: [organization()] })
  .auth({
    user: {
      additionalFields: {
        customField: { type: "string", required: true },
      },
    },
  })
  .build({
    /* ... */
  });

// All types are inferred correctly:
type Session = typeof app.auth.$Infer.Session;
// {
//   user: {
//     id: string;
//     email: string;
//     customField: string; // ✅ Custom field included
//     // ... other Better Auth fields
//   }
//   // ... session fields
// }

// API methods are type-safe:
app.auth.api.createOrganization; // ✅ Exists (organization plugin)
app.auth.api.createUser; // ✅ Exists (admin plugin from core)
app.auth.api.signIn.email; // ✅ Exists (email/password enabled)
```

## Best Practices

### 1. Use the Core Module

1. `q` automatically includes tiny core module with essential auth setup. (emailPassword, admin plugin, basic collections)
2. Avoid re-defining core auth features unless necessary. Or override them progressively.

### 2. Compose with Modules

Create reusable auth configurations for different features:

```typescript
// modules/auth/organization.ts
export const orgAuthModule = q({ name: "org" }).auth({
  plugins: [organization()],
});

// modules/auth/two-factor.ts
export const twoFactorModule = q({ name: "2fa" }).auth({
  plugins: [twoFactor()],
});

// app.ts
export const app = createCoreModule()
  .use(orgAuthModule)
  .use(twoFactorModule)
  .build({
    /* ... */
  });
```

### 3. Progressive Enhancement

Use the callback pattern to build on previous configurations:

```typescript
const app = createCoreModule()
  .auth((prev) => ({
    user: {
      ...prev.user,
      additionalFields: {
        ...prev.user?.additionalFields,
        newField: { type: "string", required: true },
      },
    },
  }))
  .build({
    /* ... */
  });
```

### 4. Keep Collections in Sync

Always update your Drizzle collections when adding `additionalFields`:

```typescript
const user = coreModule.collections.user.merge(
  q.collection("user").fields({
    // Match your additionalFields here
  }),
);
```

## Reference

- **Better Auth Docs**: [better-auth.com](https://better-auth.com/)
- **Available Plugins**: [better-auth.com/docs/plugins](https://better-auth.com/docs/plugins)
- **Core Module**: `/packages/cms/src/server/modules/core/core.module.ts`
