---
title: Modular Architecture
description: Build scalable applications using QUESTPIE's unified Module system.
icon: Package
---

# Modular Architecture

**QUESTPIE** uses a unified concept for extensibility called **Modules**. Whether you are organizing local code or installing a third-party package from NPM, the primitive is identical.

A Module is a typed definition that bundles:
1.  **Collections**: New data structures.
2.  **Extensions**: Enhancements to existing collections.
3.  **Configuration**: Strongly typed settings.

## Defining a Module

Use the `defineModule` utility to create a type-safe module definition.

```typescript title="modules/stripe/index.ts"
import { defineModule, defineCollection } from '@questpie/cms'
import { text, integer } from 'drizzle-orm/pg-core'

// 1. Define Config Type
type StripeConfig = {
  apiKey: string
  webhookSecret: string
}

// 2. Define the Module
export const stripeModule = defineModule({
  name: 'stripe',

  // New collections owned by this module
  collections: {
    payments: defineCollection('payments').fields({
      amount: integer('amount').notNull(),
      currency: text('currency').default('usd'),
    }),
  },

  // Extensions to existing collections
  extensions: {
    users: defineCollection('users').fields({
      stripeCustomerId: text('stripe_customer_id'),
    }),
  },

  // Setup logic
  setup: ({ config }) => {
    console.log('Stripe initialized with key ending in', config.apiKey.slice(-4))
  },
})
```

## Consuming Modules

In your application configuration, you utilize the module by configuring it and merging its artifacts.

### 1. Configure

Use `configureModule` to pass settings. This ensures your configuration matches the module's requirements.

```typescript title="cms.config.ts"
import { createCMS, configureModule, collectModuleCollections } from '@questpie/cms'
import { drizzle } from 'drizzle-orm/postgres-js'
import { baseUsers } from './collections/users'
import { stripeModule } from './modules/stripe'

// Configure the module
const stripe = configureModule(stripeModule, {
  apiKey: process.env.STRIPE_KEY!,
  webhookSecret: process.env.STRIPE_SECRET!,
})
```

### 2. Merge Extensions

Apply the module's extensions to your core collections using the builder pattern. This preserves full type safety by returning a new, strongly-typed collection builder.

```typescript
// Merge the 'users' extension from Stripe into our base users collection
const users = baseUsers
  .merge(stripe.extensions!.users)
```

### 3. Register Collections

Use the `collectModuleCollections` utility to automatically register all collections defined by your modules.

```typescript
export const cms = createCMS({
  collections: [
    users, // Our extended core collection
    ...collectModuleCollections([stripe]), // Add 'payments' from Stripe
  ],

  // Register modules for lifecycle hooks
  modules: [stripe],

  db: drizzle(process.env.DATABASE_URL!),
})
```

## Directory Structure

For local modules, we recommend the following structure:

```
modules/
├── stripe/
│   ├── index.ts              # Exports defineModule(...)
│   ├── collections.ts        # Internal collection definitions
│   └── webhooks.ts           # Module logic
├── auth/
└── ...
```

## Best Practices

- **Explicit Merging**: Always merge extensions explicitly in your config using `.merge()`. This makes the data flow obvious and allows you to control the order of application.
- **Type Safety**: By using `configureModule`, you ensure runtime configuration matches the expected types.
- **Isolation**: Keep module-specific logic (like webhook handlers) inside the module directory.