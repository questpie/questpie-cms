---
title: File Storage & Uploads
description: Configure file storage and handle uploads with Flydrive.
---

QUESTPIE uses [Flydrive](https://flydrive.dev/) for file storage, supporting multiple backends including local filesystem, Amazon S3, Cloudflare R2, Google Cloud Storage, and more.

## How It Works

QUESTPIE supports file uploads through the `.upload()` method on collections. Any collection can be configured to handle file uploads.

1. Configure a collection with `.upload()` to enable file upload support
2. Files are uploaded via `POST /:collection/upload` endpoint
3. The file is stored using the configured Flydrive driver (with streaming support for large files)
4. A record is created with metadata (key, filename, mimeType, size, visibility)
5. The `url` field is computed dynamically based on visibility
6. When a record is deleted, use hooks to clean up the file from storage

## Quick Start with adminModule

The easiest way to get file uploads working is to use `adminModule` from `@questpie/admin/server`, which includes a pre-configured `assets` collection:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";

export const app = q({ name: "my-app" })
  .use(adminModule) // Includes assets collection with .upload()
  .build({
    db: { url: process.env.DATABASE_URL! },
    storage: {
      location: "./uploads", // Local filesystem
    },
  });

// Upload a file
const asset = await app.api.collections.assets.upload(file);
console.log(asset.url); // Typed URL
```

**HTTP Endpoints (with adminModule):**

- `POST /cms/assets/upload` - Upload a file
- `GET /cms/assets/files/:key` - Serve a file

## Configuration

Storage config uses a discriminated union - you either specify `location` (local filesystem) OR `driver` (cloud storage), never both.

### Local Filesystem (Default)

By default, QUESTPIE uses local filesystem storage at `./uploads`:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";

export const app = q({ name: "myapp" })
  .use(adminModule) // Includes assets collection with .upload()
  .collections({
    /* your collections */
  })
  .build({
    app: { url: "http://localhost:3000" },
    db: { url: process.env.DATABASE_URL! },
    secret: process.env.CMS_SECRET!, // Used for signing private file URLs
    // Storage defaults to: { location: "./uploads" }
  });
```

#### Custom Location

```typescript
export const app = q({ name: "myapp" })
  .use(adminModule)
  .collections({
    /* your collections */
  })
  .build({
    app: { url: "http://localhost:3000" },
    db: { url: process.env.DATABASE_URL! },
    secret: process.env.CMS_SECRET!,
    storage: {
      location: "/var/data/cms-uploads", // Absolute or relative path
      defaultVisibility: "public",
      signedUrlExpiration: 3600, // 1 hour for private files
    },
  });
```

When using local storage, CMS automatically:

- Creates an FSDriver pointing to your location
- Serves files at `/:collection/files/:key` for each upload-enabled collection
- Handles signed URLs for private files

### Amazon S3

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { S3Driver } from "flydrive/drivers/s3";

export const app = q({ name: "myapp" })
  .use(adminModule)
  .collections({
    /* your collections */
  })
  .build({
    app: { url: "https://myapp.com" },
    db: { url: process.env.DATABASE_URL! },
    storage: {
      driver: new S3Driver({
        credentials: {
          accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
        },
        region: process.env.AWS_REGION!,
        bucket: process.env.AWS_S3_BUCKET!,
        visibility: "public",
      }),
    },
  });
```

### Cloudflare R2

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { S3Driver } from "flydrive/drivers/s3";

export const app = q({ name: "myapp" })
  .use(adminModule)
  .collections({
    /* your collections */
  })
  .build({
    app: { url: "https://myapp.com" },
    db: { url: process.env.DATABASE_URL! },
    storage: {
      driver: new S3Driver({
        credentials: {
          accessKeyId: process.env.R2_ACCESS_KEY_ID!,
          secretAccessKey: process.env.R2_SECRET_ACCESS_KEY!,
        },
        endpoint: `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com`,
        region: "auto",
        bucket: process.env.R2_BUCKET!,
        visibility: "public",
      }),
    },
  });
```

### Google Cloud Storage

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { GCSDriver } from "flydrive/drivers/gcs";

export const app = q({ name: "myapp" })
  .use(adminModule)
  .collections({
    /* your collections */
  })
  .build({
    app: { url: "https://myapp.com" },
    db: { url: process.env.DATABASE_URL! },
    storage: {
      driver: new GCSDriver({
        credentials: JSON.parse(process.env.GCS_CREDENTIALS!),
        bucket: process.env.GCS_BUCKET!,
        visibility: "public",
      }),
    },
  });
```

## Uploading Files

### Via API Endpoint

Upload files using multipart/form-data to the collection's upload endpoint:

```bash
# Upload to assets collection (from adminModule)
curl -X POST http://localhost:3000/cms/assets/upload \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@/path/to/image.jpg"

# Upload to custom media collection
curl -X POST http://localhost:3000/cms/media/upload \
  -H "Authorization: Bearer $TOKEN" \
  -F "file=@/path/to/document.pdf"
```

**Response:**

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "key": "a1b2c3d4-image.jpg",
  "url": "http://localhost:3000/cms/assets/files/a1b2c3d4-image.jpg",
  "filename": "image.jpg",
  "mimeType": "image/jpeg",
  "size": 102400,
  "visibility": "public",
  "createdAt": "2025-01-06T12:00:00.000Z",
  "updatedAt": "2025-01-06T12:00:00.000Z"
}
```

### Via JavaScript/TypeScript

```typescript
async function uploadFile(file: File, collection: string, token: string) {
  const formData = new FormData();
  formData.append("file", file);

  const response = await fetch(`/cms/${collection}/upload`, {
    method: "POST",
    headers: {
      Authorization: `Bearer ${token}`,
    },
    body: formData,
  });

  return response.json();
}

// Usage
const fileInput = document.querySelector('input[type="file"]');
const file = fileInput.files[0];
const asset = await uploadFile(file, "assets", authToken);
console.log("Uploaded:", asset.url);
```

### Via Server-Side API

```typescript
import { getAppFromContext } from "questpie";

// In a hook, job, or function handler
const app = getAppFromContext();

// Upload to assets collection
const asset = await app.api.collections.assets.upload(file, context);

// Upload to custom media collection
const media = await app.api.collections.media.upload(file, context, {
  folder: "documents",
});
```

## Using Storage in Code

### Direct Storage Access

Access the Flydrive driver directly:

```typescript
import { getAppFromContext } from "questpie";

// In a hook or function
const app = getAppFromContext();

// Upload file
await app.storage.use().put("my-file.txt", "Hello World");

// Get URL
const url = await app.storage.use().getUrl("my-file.txt");

// Check if exists
const exists = await app.storage.use().exists("my-file.txt");

// Delete file
await app.storage.use().delete("my-file.txt");

// Get file contents
const contents = await app.storage.use().get("my-file.txt");
```

### In Collection Hooks

Handle file uploads in hooks:

```typescript
import { q, getAppFromContext } from "questpie";
import { varchar, uuid } from "drizzle-orm/pg-core";

export const products = q
  .collection("products")
  .fields({
    name: varchar("name", { length: 255 }).notNull(),
    imageId: uuid("image_id"), // Reference to assets collection
  })
  .relations(({ table, one }) => ({
    image: one("assets", {
      fields: [table.imageId],
      references: ["id"],
    }),
  }))
  .hooks({
    beforeDelete: async ({ data }) => {
      // Optionally clean up associated image
      if (data.imageId) {
        const app = getAppFromContext();
        await app.api.collections.assets.deleteById({ id: data.imageId });
        // The assets hook will delete the file from storage
      }
    },
  });
```

## Custom Upload Collections

You can add file upload support to any collection using the `.upload()` method:

```typescript
import { q } from "questpie";
import { varchar, text } from "drizzle-orm/pg-core";

// Custom media collection with upload support
export const media = q
  .collection("media")
  .fields({
    // Your custom fields
    alt: varchar("alt", { length: 500 }),
    caption: text("caption"),
    folder: varchar("folder", { length: 255 }),
  })
  // Enable file uploads
  .upload({
    visibility: "public", // Default: "public"
    maxSize: 10_000_000, // Optional: 10MB limit
    allowedTypes: ["image/*", "application/pdf"], // Optional: MIME type whitelist
  });
```

When you call `.upload()`, the collection automatically:

- Adds fields: `key`, `filename`, `mimeType`, `size`, `visibility`
- Adds `$outputType<{ url: string }>()` for typed URL access
- Adds `afterRead` hook for URL generation based on visibility
- Enables `upload()` and `uploadMany()` CRUD methods
- Registers HTTP routes: `POST /:collection/upload`, `GET /:collection/files/:key`

### Upload Options

| Option         | Type                    | Default     | Description                                              |
| -------------- | ----------------------- | ----------- | -------------------------------------------------------- |
| `visibility`   | `"public" \| "private"` | `"public"`  | Default visibility for uploaded files                    |
| `maxSize`      | `number`                | `undefined` | Maximum file size in bytes                               |
| `allowedTypes` | `string[]`              | `undefined` | Allowed MIME types (supports wildcards like `"image/*"`) |

### Using Upload Methods

```typescript
// Upload single file (streaming for large files)
const record = await app.api.collections.media.upload(file, context);
console.log(record.url); // Typed!

// Upload multiple files
const records = await app.api.collections.media.uploadMany(files, context);

// Upload with additional data
const record = await app.api.collections.media.upload(file, context, {
  folder: "avatars",
  alt: "User avatar",
});
```

## The Assets Collection (via adminModule)

The `adminModule` includes a pre-configured `assets` collection:

```typescript
// Built-in assets collection schema (from adminModule)
{
  id: uuid,            // Primary key
  key: varchar,        // Storage key (e.g. "uuid-filename.jpg")
  filename: varchar,   // Original filename
  mimeType: varchar,   // MIME type (e.g. "image/jpeg")
  size: integer,       // File size in bytes
  visibility: varchar, // "public" or "private"
  width: integer,      // Image width (optional)
  height: integer,     // Image height (optional)
  alt: varchar,        // Alt text (optional)
  caption: text,       // Caption (optional)
  createdAt: timestamp,
  updatedAt: timestamp,

  // Computed field (not stored in DB)
  url: string,         // Generated based on visibility
}
```

### Querying Assets

```typescript
// Get all images
const images = await app.api.collections.assets.find({
  where: {
    mimeType: { startsWith: "image/" },
  },
});

// Get specific asset
const asset = await app.api.collections.assets.findOne({
  where: { id: assetId },
});
```

### Linking Assets to Collections

Reference assets in your collections:

```typescript
const posts = q
  .collection("posts")
  .fields({
    title: varchar("title", { length: 255 }).notNull(),
    featuredImageId: uuid("featured_image_id"),
    galleryIds: jsonb("gallery_ids").$type<string[]>().default([]),
  })
  .relations(({ table, one }) => ({
    featuredImage: one("assets", {
      fields: [table.featuredImageId],
      references: ["id"],
    }),
  }));

// Query with image
const post = await app.api.collections.posts.findOne({
  where: { id: postId },
  with: { featuredImage: true },
});

console.log(post.featuredImage?.url);
```

## Image Processing

For image processing (resize, crop, optimize), consider using a CDN or image processing service:

### Cloudflare Images

```typescript
// When using R2 + Cloudflare Images
const imageUrl = `https://imagedelivery.net/${accountId}/${asset.key}/public`;
const thumbnail = `https://imagedelivery.net/${accountId}/${asset.key}/thumbnail`;
```

### imgproxy

```typescript
// Self-hosted image processing
const processedUrl = `https://imgproxy.example.com/resize:fit:300:200/${asset.url}`;
```

### Sharp (Server-side)

```typescript
import sharp from "sharp";

async function createThumbnail(assetKey: string) {
  const app = getAppFromContext();

  // Get original file
  const original = await app.storage.use().getBytes(assetKey);

  // Process with Sharp
  const thumbnail = await sharp(original)
    .resize(300, 200, { fit: "cover" })
    .jpeg({ quality: 80 })
    .toBuffer();

  // Save thumbnail
  const thumbKey = `thumb-${assetKey}`;
  await app.storage.use().put(thumbKey, thumbnail);

  return app.storage.use().getUrl(thumbKey);
}
```

## Environment-based Configuration

Switch storage based on environment:

```typescript
import { q } from "questpie";
import { adminModule } from "@questpie/admin/server";
import { S3Driver } from "flydrive/drivers/s3";

const getStorageConfig = () => {
  if (process.env.NODE_ENV === "production") {
    // Cloud storage in production
    return {
      driver: new S3Driver({
        credentials: {
          accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
          secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!,
        },
        region: process.env.AWS_REGION!,
        bucket: process.env.AWS_S3_BUCKET!,
        visibility: "public",
      }),
    };
  }

  // Local filesystem for development (uses built-in CMS file serving)
  return {
    location: "./uploads",
  };
};

export const app = q({ name: "myapp" })
  .use(adminModule)
  .collections({
    /* your collections */
  })
  .build({
    app: { url: process.env.APP_URL! },
    db: { url: process.env.DATABASE_URL! },
    secret: process.env.CMS_SECRET!,
    storage: getStorageConfig(),
  });
```

## Serving Local Files

QUESTPIE has **built-in file serving** for local filesystem storage. Files are served at `/:collection/files/:key` for each collection with `.upload()` configured.

### How It Works

When you upload a file, the CMS:

1. Validates file size and MIME type (if configured)
2. Stores the file using streaming (efficient for large files)
3. Creates a record with metadata (key, filename, size, mimeType, visibility)
4. The `url` field is computed dynamically based on visibility

**Public files** are served directly:

```
GET /cms/assets/files/a1b2c3d4-image.jpg
GET /cms/media/files/b2c3d4e5-document.pdf
```

**Private files** require a signed URL with a time-limited token:

```
GET /cms/assets/files/a1b2c3d4-secret.pdf?token=eyJ...
```

### Configuration

```typescript
export const app = q({ name: "myapp" })
  .collections({
    /* ... */
  })
  .build({
    app: { url: "http://localhost:3000" },
    db: { url: process.env.DATABASE_URL! },
    storage: {
      // Default visibility for new uploads
      defaultVisibility: "public", // or "private"
      // Token expiration for signed URLs (in seconds)
      signedUrlExpiration: 3600, // 1 hour (default)
    },
    // Secret key for signing private file tokens
    secret: process.env.CMS_SECRET!,
  });
```

### File Visibility

Each asset has a `visibility` field that determines access control:

- **`public`**: Anyone can access the file directly
- **`private`**: Requires a valid signed URL token

```typescript
// Upload a private file
const asset = await app.api.collections.assets.create({
  key: "secret-document.pdf",
  filename: "document.pdf",
  mimeType: "application/pdf",
  size: 12345,
  visibility: "private",
});

// The URL will automatically include a signed token
console.log(asset.url);
// â†’ http://localhost:3000/cms/storage/files/secret-document.pdf?token=eyJ...
```

### CDN Integration

For production, consider putting a CDN in front of your CMS for better performance:

#### Cloudflare

```typescript
// Configure Cloudflare to cache public assets
// In your Cloudflare dashboard:
// 1. Create a Cache Rule for /cms/storage/files/*
// 2. Set Edge TTL based on Cache-Control headers
// 3. Enable "Cache Everything" for static assets

// The CMS sets appropriate Cache-Control headers:
// - Public files: "public, max-age=31536000, immutable"
// - Private files: "private, no-cache"
```

#### Nginx Reverse Proxy

```nginx
location /cms/storage/files/ {
    proxy_pass http://localhost:3000;
    proxy_cache_valid 200 1y;
    proxy_cache_use_stale error timeout updating;
    add_header X-Cache-Status $upstream_cache_status;
}
```

### Using Cloud Storage (S3, R2, GCS)

When using cloud storage drivers, files are served directly from the cloud provider. The built-in file serving endpoint is not used.

```typescript
import { S3Driver } from "flydrive/drivers/s3";

export const app = q({ name: "myapp" }).build({
  // ...
  storage: {
    driver: new S3Driver({
      // S3 configuration...
      visibility: "public",
    }),
  },
});
```

For cloud storage, the `url` field will contain the direct cloud URL (e.g., `https://bucket.s3.amazonaws.com/key`).

## Related

- [Collections](/docs/core-concepts/collections) - Reference assets in collections
- [Hooks](/docs/backend/hooks) - Handle uploads in lifecycle hooks
- [Flydrive Documentation](https://flydrive.dev/) - Full driver reference
