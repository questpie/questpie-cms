---
title: Scoped Helpers with Builder Pattern
description: Type-safe field access with the proxy pattern
---

# Scoped Helpers with Builder Pattern

The `qa<AppCMS>().use(module)` pattern creates a scoped builder that has access to registered fields, views, and widgets from a module. This enables the powerful proxy pattern for type-safe autocomplete.

## The Problem

When defining collection fields, you need access to field type definitions. Without proper typing, you lose autocomplete:

```typescript
// Without scoped helpers - no autocomplete
const posts = qa.collection("posts")
  .fields(() => ({
    title: ???,  // What goes here?
  }));
```

## The Solution

Use `qa<AppCMS>().use(adminModule)` to create a scoped builder:

```typescript
import { qa, adminModule } from "@questpie/admin/client";
import type { AppCMS } from "./server/cms";

// Create scoped builder with module's registries
const builder = qa<AppCMS>().use(adminModule);

// Now .fields() provides autocomplete!
const posts = builder
  .collection("posts")
  .fields(({ r }) => ({
    title: r.text(),       // Autocomplete for all field types!
    body: r.richText(),    // r.email, r.select, r.relation, etc.
  }));
```

## How the Proxy Works

When you call `.fields(({ r }) => {...})`, the `r` parameter is a **FieldRegistryProxy**:

```typescript
.fields(({ r }) => ({
  // r has methods for all registered field types
  title: r.text({ maxLength: 200 }),
  email: r.email(),
  status: r.select({
    options: [
      { label: "Draft", value: "draft" },
      { label: "Published", value: "published" },
    ],
  }),
  author: r.relation({
    targetCollection: "users",  // Autocomplete for backend collections!
  }),
}))
```

The proxy provides:
1. **Autocomplete** for all registered field types (`text`, `email`, `select`, etc.)
2. **Type-safe options** for each field type
3. **Backend collection autocomplete** for relations

## View and Field Proxies

The `.list()` and `.form()` methods provide additional proxies:

```typescript
.list(({ v, f }) => v.table({
  // v = ViewRegistryProxy (autocomplete for views)
  // f = FieldProxy (autocomplete for defined fields)
  columns: [f.title, f.author],  // f.title, f.author, etc.
}))

.form(({ v, f }) => v.form({
  sections: [
    {
      title: "Content",
      fields: [f.title, f.content],  // Autocomplete!
    },
  ],
}))
```

## Nested Field Proxies

For complex field types like `object` and `array`, you get nested proxies:

```typescript
.fields(({ r }) => ({
  workingHours: r.object({
    label: "Working Hours",
    // Nested registry proxy!
    fields: ({ r }) => ({
      monday: r.object({
        fields: ({ r }) => ({
          isOpen: r.switch({ label: "Open" }),
          start: r.time({ label: "Start" }),
          end: r.time({ label: "End" }),
        }),
      }),
      tuesday: r.object({...}),
      // ...
    }),
  }),

  socialLinks: r.array({
    label: "Social Links",
    // Item definition with proxy
    item: ({ r }) => ({
      platform: r.select({
        options: [
          { label: "Instagram", value: "instagram" },
          { label: "Twitter", value: "twitter" },
        ],
      }),
      url: r.text({ label: "URL" }),
    }),
  }),
}))
```

## Complete Example

Here's a full collection configuration using scoped helpers:

```typescript
// admin/builder.ts
import { qa, adminModule } from "@questpie/admin/client";
import type { AppCMS } from "@/questpie/server/cms";

export const builder = qa<AppCMS>().use(adminModule);
```

```typescript
// admin/collections/barbers.ts
import { UsersIcon } from "@phosphor-icons/react";
import { builder } from "../builder";

export const barbersAdmin = builder
  .collection("barbers")
  .meta({
    label: { en: "Barbers", sk: "Holici" },
    icon: UsersIcon,
  })
  .fields(({ r }) => ({
    name: r.text({
      label: { en: "Full Name", sk: "Cele meno" },
      maxLength: 255,
    }),
    email: r.email({
      label: { en: "Email", sk: "Email" },
    }),
    bio: r.richText({
      label: { en: "Biography", sk: "Zivotopis" },
    }),
    avatar: r.upload({
      label: { en: "Photo", sk: "Fotka" },
      accept: ["image/*"],
    }),
    isActive: r.switch({
      label: { en: "Active", sk: "Aktivny" },
    }),
    services: r.relation({
      label: { en: "Services", sk: "Sluzby" },
      targetCollection: "services",
      type: "multiple",
    }),
  }))
  .list(({ v }) => v.table({}))
  .form(({ v, f }) => v.form({
    sidebar: {
      position: "right",
      fields: [f.isActive, f.avatar],
    },
    sections: [
      {
        title: { en: "Contact", sk: "Kontakt" },
        layout: "grid",
        columns: 2,
        fields: [f.name, f.email],
      },
      {
        title: { en: "Profile", sk: "Profil" },
        fields: [f.bio, f.services],
      },
    ],
  }));
```

## Benefits

Using the builder pattern and proxies provides:

1. **Full autocomplete** - Never guess field type names
2. **Type safety** - Compiler catches typos and invalid options
3. **Refactoring support** - Rename a field in one place
4. **Documentation in IDE** - Hover for field options
5. **Backend integration** - Relations autocomplete collection names

## Alternative: toNamespace()

For frequently reused builders, you can create a namespace:

```typescript
// Creates qa.collection, qa.global, qa.sidebar, etc.
export const qab = qa<AppCMS>().use(adminModule).toNamespace();

// Use anywhere
const posts = qab.collection("posts").fields(...)
```

<Callout type="info">
`toNamespace()` is equivalent to assigning the builder to a variable - it's just a convenience method for creating a reusable namespace.
</Callout>

## Related

- [Field Types](/docs/admin/fields) - All 22+ field types and their options
- [Views](/docs/admin/views) - List and form views
