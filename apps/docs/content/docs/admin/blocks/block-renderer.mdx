---
title: Block Renderer
description: Rendering blocks on your frontend
---

# Block Renderer

The `BlockRenderer` component renders block content from the CMS on your frontend.

## Basic Usage

```tsx
import { BlockRenderer } from "@questpie/admin/client";
import { blocks } from "@/questpie/admin/blocks";

export default function Page({ page }) {
  return (
    <main>
      <BlockRenderer
        blocks={page.content}
        registry={blocks}
      />
    </main>
  );
}
```

## Props

| Prop | Type | Description |
|------|------|-------------|
| `blocks` | `BlockContent[]` | Array of block data from CMS |
| `registry` | `BlockRegistry` | Registered block definitions |
| `locale` | `string` | Current locale for localized content |
| `className` | `string` | CSS class for wrapper |
| `onError` | `fn` | Error handler for rendering failures |

## With Localization

```tsx
import { useLocale } from "@/hooks/use-locale";

export default function Page({ page }) {
  const locale = useLocale();

  return (
    <BlockRenderer
      blocks={page.content}
      registry={blocks}
      locale={locale}
    />
  );
}
```

## Error Handling

Handle rendering errors gracefully:

```tsx
<BlockRenderer
  blocks={page.content}
  registry={blocks}
  onError={(error, block) => {
    console.error(`Error rendering block ${block.type}:`, error);
    return (
      <div className="block-error">
        Failed to render {block.type} block
      </div>
    );
  }}
/>
```

## Prefetching Data

For server-side rendering, prefetch block data:

```tsx
// pages/[slug].tsx (Next.js example)
import { prefetchBlocks } from "@questpie/admin/client";
import { blocks } from "@/questpie/admin/blocks";

export async function getServerSideProps({ params }) {
  const page = await cms.collections.pages.findOne({
    where: { slug: params.slug },
  });

  // Prefetch data for all blocks
  const prefetchedData = await prefetchBlocks(
    page.content,
    blocks,
  );

  return {
    props: {
      page,
      prefetchedData,
    },
  };
}

export default function Page({ page, prefetchedData }) {
  return (
    <BlockRenderer
      blocks={page.content}
      registry={blocks}
      prefetchedData={prefetchedData}
    />
  );
}
```

## TanStack Start Example

```tsx
// routes/pages/$slug.tsx
import { createFileRoute } from "@tanstack/react-router";
import { prefetchBlocks, BlockRenderer } from "@questpie/admin/client";
import { blocks } from "@/questpie/admin/blocks";
import { cmsClient } from "@/lib/cms-client";

export const Route = createFileRoute("/pages/$slug")({
  loader: async ({ params }) => {
    const page = await cmsClient.collections.pages.findOne({
      where: { slug: params.slug, status: "published" },
    });

    if (!page) {
      throw new Error("Page not found");
    }

    // Prefetch all block data
    const blockData = await prefetchBlocks(page.content, blocks);

    return { page, blockData };
  },
  component: PageComponent,
});

function PageComponent() {
  const { page, blockData } = Route.useLoaderData();

  return (
    <main>
      <BlockRenderer
        blocks={page.content}
        registry={blocks}
        prefetchedData={blockData}
      />
    </main>
  );
}
```

## Custom Block Wrapper

Wrap each block with custom styling or behavior:

```tsx
<BlockRenderer
  blocks={page.content}
  registry={blocks}
  blockWrapper={({ block, children }) => (
    <section
      key={block.id}
      id={`block-${block.id}`}
      data-block-type={block.type}
      className="page-block"
    >
      {children}
    </section>
  )}
/>
```

## Block Data Structure

Each block in the array has this structure:

```typescript
interface BlockContent {
  id: string;           // Unique block ID
  type: string;         // Block type (matches registry key)
  values: {             // Field values
    title?: string;
    content?: string;
    // ... other fields
  };
  children?: BlockContent[];  // Nested blocks (for layout blocks)
}
```

## Rendering Individual Blocks

Render a single block manually:

```tsx
import { renderBlock } from "@questpie/admin/client";
import { blocks } from "@/questpie/admin/blocks";

function SingleBlock({ blockData }) {
  return renderBlock(blockData, blocks, {
    locale: "en",
    prefetchedData: blockData.prefetched,
  });
}
```

## Block Context

Access block context in nested components:

```tsx
import { useBlockContext } from "@questpie/admin/client";

function NestedComponent() {
  const { block, locale, prefetchedData } = useBlockContext();

  return (
    <div>
      Block type: {block.type}
      Current locale: {locale}
    </div>
  );
}
```

## Styling Blocks

### CSS Classes

Each block receives a class based on its type:

```css
/* Style all hero blocks */
.block-hero {
  min-height: 80vh;
}

/* Style all text blocks */
.block-text {
  max-width: 800px;
  margin: 0 auto;
}
```

### Block-Specific Styles

Define styles in your block renderer:

```tsx
function HeroRenderer({ values }) {
  const heightClass = {
    small: "min-h-[50vh]",
    medium: "min-h-[70vh]",
    large: "min-h-[90vh]",
  }[values.height || "medium"];

  return (
    <section className={cn("hero", heightClass)}>
      ...
    </section>
  );
}
```

## Preview Mode Integration

For live preview in the admin:

```tsx
// The BlockRenderer automatically handles preview mode
// when rendered inside the admin preview panel

import { BlockRenderer, usePreviewMode } from "@questpie/admin/client";

function PreviewAwarePage({ page }) {
  const isPreview = usePreviewMode();

  return (
    <div className={isPreview ? "preview-mode" : ""}>
      <BlockRenderer
        blocks={page.content}
        registry={blocks}
      />
    </div>
  );
}
```

## Performance Tips

1. **Prefetch on server** - Always prefetch block data during SSR
2. **Lazy load heavy blocks** - Use dynamic imports for complex blocks
3. **Optimize images** - Use responsive images with srcset
4. **Memoize renderers** - Wrap expensive renderers with React.memo
5. **Virtualize long pages** - For pages with many blocks, consider virtualization

```tsx
// Lazy load a heavy block
const HeavyChartBlock = lazy(() => import("./blocks/heavy-chart"));

const blocks = {
  // ...
  "heavy-chart": {
    ...heavyChartBlock,
    renderer: HeavyChartBlock,
  },
};
```

## Related

- [Examples](/docs/admin/blocks/block-examples) - Real-world block implementations
- [Preview System](/docs/admin/preview) - Live preview integration
