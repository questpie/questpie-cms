---
title: Creating Custom Blocks
description: Step-by-step guide to creating page builder blocks
---

# Creating Custom Blocks

This guide walks you through creating custom blocks for the QUESTPIE page builder.

## Block Anatomy

A block consists of:

1. **Definition** - Block metadata, fields, and configuration
2. **Renderer** - React component for frontend display
3. **Prefetch** (optional) - Server-side data loading

## Step 1: Define the Block

```typescript
// admin/blocks/testimonial.tsx
import { builder } from "../builder";

export const testimonialBlock = builder
  .block("testimonial")
  .label({ en: "Testimonial", sk: "Referencie" })
  .description({ en: "Customer testimonial with photo", sk: "Referencie zakaznika s foto" })
  .icon("Quote")
  .category("content")
  .fields(({ r }) => ({
    quote: r.textarea({
      label: { en: "Quote", sk: "Citat" },
      localized: true,
      required: true,
      rows: 4,
    }),
    authorName: r.text({
      label: { en: "Author Name", sk: "Meno autora" },
      localized: true,
      required: true,
    }),
    authorTitle: r.text({
      label: { en: "Author Title", sk: "Pozicia autora" },
      localized: true,
    }),
    authorPhoto: r.upload({
      label: { en: "Author Photo", sk: "Foto autora" },
      accept: ["image/*"],
    }),
    rating: r.number({
      label: { en: "Rating", sk: "Hodnotenie" },
      min: 1,
      max: 5,
      integer: true,
    }),
  }))
  .prefetch(async ({ values }) => {
    if (!values.authorPhoto) return {};

    const asset = await client.collections.assets.findOne({
      where: { id: values.authorPhoto },
    });

    return {
      authorPhotoUrl: asset?.url || null,
    };
  })
  .renderer(TestimonialRenderer)
  .build();
```

## Step 2: Create the Renderer

```tsx
// Same file or separate

import type { BlockRendererProps } from "@questpie/admin/client";

type TestimonialValues = {
  quote: string;
  authorName: string;
  authorTitle?: string;
  authorPhoto?: string;
  rating?: number;
};

type TestimonialData = {
  authorPhotoUrl?: string | null;
};

function TestimonialRenderer({
  values,
  data,
  children,
}: BlockRendererProps<TestimonialValues, TestimonialData>) {
  return (
    <blockquote className="testimonial">
      {/* Rating stars */}
      {values.rating && (
        <div className="rating">
          {Array.from({ length: values.rating }).map((_, i) => (
            <Star key={i} className="star filled" />
          ))}
          {Array.from({ length: 5 - values.rating }).map((_, i) => (
            <Star key={i} className="star" />
          ))}
        </div>
      )}

      {/* Quote */}
      <p className="quote">{values.quote}</p>

      {/* Author */}
      <footer className="author">
        {data.authorPhotoUrl && (
          <img
            src={data.authorPhotoUrl}
            alt={values.authorName}
            className="author-photo"
          />
        )}
        <div>
          <cite className="name">{values.authorName}</cite>
          {values.authorTitle && (
            <span className="title">{values.authorTitle}</span>
          )}
        </div>
      </footer>

      {/* Nested blocks (if any) */}
      {children}
    </blockquote>
  );
}
```

## Step 3: Register the Block

```typescript
// admin/blocks/index.ts
import { testimonialBlock } from "./testimonial";

export const blocks = {
  // ... other blocks
  testimonial: testimonialBlock,
} as const;

export default blocks;
```

## Block Builder API

### `.block(name)`

Create a new block with unique identifier:

```typescript
builder.block("hero")
```

### `.label(text)`

Display name in block picker:

```typescript
.label({ en: "Hero Banner", sk: "Hero Banner" })
```

### `.description(text)`

Help text in block picker:

```typescript
.description({ en: "Full-width banner with background image" })
```

### `.icon(name)`

Icon for block picker (Phosphor icon name):

```typescript
.icon("Image")
.icon("TextT")
.icon("Columns")
```

### `.category(name)`

Category for organization:

```typescript
.category("sections")   // Full-width sections
.category("content")    // Content blocks
.category("layout")     // Layout/structure
.category("dynamic")    // Data-driven blocks
```

### `.fields(callback)`

Define block fields using the registry proxy:

```typescript
.fields(({ r }) => ({
  title: r.text({ label: "Title", localized: true }),
  content: r.richText({ label: "Content" }),
  image: r.upload({ label: "Image" }),
}))
```

### `.prefetch(handler)`

Server-side data loading:

```typescript
.prefetch(async ({ values, locale }) => {
  // Fetch any data needed for rendering
  const data = await fetchData(values.someId);
  return { fetchedData: data };
})
```

### `.renderer(component)`

React component for rendering:

```typescript
.renderer(MyBlockRenderer)
```

### `.build()`

Finalize the block definition:

```typescript
.build()
```

## Field Options for Blocks

All standard field types are available:

```typescript
.fields(({ r }) => ({
  // Text
  title: r.text({ label: "Title", localized: true }),
  subtitle: r.textarea({ label: "Subtitle" }),

  // Selection
  alignment: r.select({
    label: "Alignment",
    options: [
      { label: "Left", value: "left" },
      { label: "Center", value: "center" },
      { label: "Right", value: "right" },
    ],
    defaultValue: "center",
  }),

  // Numbers
  padding: r.number({ label: "Padding", min: 0, max: 200 }),

  // Media
  backgroundImage: r.upload({ label: "Background", accept: ["image/*"] }),

  // Rich content
  content: r.richText({ label: "Content" }),

  // Nested structures
  buttons: r.array({
    label: "Buttons",
    item: ({ r }) => ({
      text: r.text({ label: "Button Text" }),
      link: r.text({ label: "Link" }),
      variant: r.select({
        label: "Style",
        options: [
          { label: "Primary", value: "primary" },
          { label: "Secondary", value: "secondary" },
        ],
      }),
    }),
    maxItems: 3,
  }),
}))
```

## Localized Content

Enable per-locale content with `localized: true`:

```typescript
.fields(({ r }) => ({
  title: r.text({
    label: "Title",
    localized: true,  // Different value per locale
  }),
  content: r.richText({
    label: "Content",
    localized: true,
  }),
  // Non-localized fields (same across locales)
  backgroundColor: r.text({ label: "Background Color" }),
}))
```

## Nested Blocks (Columns)

Create layout blocks that contain other blocks:

```typescript
export const columnsBlock = builder
  .block("columns")
  .label("Columns")
  .icon("Columns")
  .category("layout")
  .fields(({ r }) => ({
    columns: r.number({
      label: "Columns",
      min: 2,
      max: 4,
      defaultValue: 2,
    }),
    gap: r.select({
      label: "Gap",
      options: [
        { label: "Small", value: "sm" },
        { label: "Medium", value: "md" },
        { label: "Large", value: "lg" },
      ],
      defaultValue: "md",
    }),
  }))
  .renderer(ColumnsRenderer)
  .allowChildren()  // Enable nested blocks
  .build();

function ColumnsRenderer({ values, children }) {
  return (
    <div
      className="columns"
      style={{
        display: "grid",
        gridTemplateColumns: `repeat(${values.columns}, 1fr)`,
        gap: gapSizes[values.gap],
      }}
    >
      {children}
    </div>
  );
}
```

## Best Practices

1. **Keep blocks focused** - Each block should do one thing well
2. **Use localized fields** - For any user-facing text
3. **Provide defaults** - Sensible default values improve UX
4. **Add descriptions** - Help users understand field purpose
5. **Prefetch efficiently** - Only load data that's needed
6. **Type your props** - Use TypeScript for safety
7. **Handle missing data** - Gracefully handle undefined values

## Next Steps

<Cards>
  <Card href="/docs/admin/blocks/block-renderer" title="Block Renderer" description="Render blocks on your frontend" />
  <Card href="/docs/admin/blocks/block-examples" title="Examples" description="Real-world block implementations" />
</Cards>
