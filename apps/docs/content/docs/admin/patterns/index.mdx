---
title: Patterns & Best Practices
description: Recommended patterns for QUESTPIE Admin development
---

# Patterns & Best Practices

This section covers recommended patterns and best practices for building with QUESTPIE Admin.

## Key Patterns

### No .build() Method

Unlike the backend CMS, admin configuration doesn't use `.build()`. The state IS the config.

```typescript
// ❌ Wrong - admin has no .build()
const admin = qa().collections({...}).build();

// ✅ Correct - state IS config
const admin = qa().collections({...});
admin.state.collections; // Access directly
```

[Learn more about this pattern →](/docs/admin/patterns/no-build-method)

### Icons as Components

Icons must be React components, not strings:

```typescript
import { Newspaper } from "lucide-react";

// ✅ Correct
.meta({ icon: Newspaper })

// ❌ Wrong
.meta({ icon: "Newspaper" })
```

[Learn more about icons →](/docs/admin/patterns/icons-as-components)

### Proxy Pattern for Type Safety

Use destructuring to get autocomplete:

```typescript
// Fields proxy
.fields(({ r }) => ({
  title: r.text(),      // r provides autocomplete
  body: r.richText(),
}))

// Views proxy
.list(({ v, f }) => v.table({
  columns: [f.title],   // f provides field autocomplete
}))
```

### Scoped Helpers with Builder Pattern

Create scoped builders for type-safe access:

```typescript
import { qa, adminModule } from "@questpie/admin/client";
import type { AppCMS } from "./server/cms";

const builder = qa<AppCMS>().use(adminModule);

// builder has access to adminModule's fields/views
const posts = builder.collection("posts")
  .fields(({ r }) => ({
    title: r.text(),  // Available from adminModule
  }));
```

## Common Patterns

### Collection with Full Configuration

```typescript
const builder = qa<AppCMS>().use(adminModule);

export const postsAdmin = builder.collection("posts")
  .meta({
    label: "Posts",
    labelPlural: "Posts",
    icon: Newspaper,
    description: "Blog posts and articles",
  })
  .fields(({ r }) => ({
    title: r.text({ label: "Title" }),
    slug: r.text({ label: "Slug" }),
    content: r.richText({ label: "Content" }),
    status: r.select({
      label: "Status",
      options: [
        { label: "Draft", value: "draft" },
        { label: "Published", value: "published" },
      ],
    }),
    author: r.relation({
      label: "Author",
      targetCollection: "users",
    }),
    publishedAt: r.datetime({ label: "Publish Date" }),
  }))
  .list(({ v, f }) => v.table({
    columns: [f.title, f.status, f.author, f.publishedAt],
    defaultSort: { field: "publishedAt", direction: "desc" },
    searchable: ["title"],
    filters: [f.status, f.author],
  }))
  .form(({ v, f }) => v.form({
    layout: [
      v.section({
        title: "Content",
        fields: [f.title, f.slug, f.content],
      }),
      v.section({
        title: "Publishing",
        fields: [f.status, f.author, f.publishedAt],
      }),
    ],
  }));
```

### Reusable Field Groups

```typescript
// Define reusable field configurations
const seoFields = ({ r }) => ({
  metaTitle: r.text({ label: "Meta Title", maxLength: 60 }),
  metaDescription: r.textarea({ label: "Meta Description", maxLength: 160 }),
  ogImage: r.upload({ label: "OG Image" }),
});

const timestampFields = ({ r }) => ({
  createdAt: r.datetime({ label: "Created", readOnly: true }),
  updatedAt: r.datetime({ label: "Updated", readOnly: true }),
});

// Use in collections
export const pagesAdmin = qab.collection("pages")
  .fields(({ r }) => ({
    title: r.text({ label: "Title" }),
    content: r.richText({ label: "Content" }),
    ...seoFields({ r }),
    ...timestampFields({ r }),
  }));
```

### Conditional Field Display

```typescript
.fields(({ r }) => ({
  type: r.select({
    label: "Type",
    options: [
      { label: "Internal", value: "internal" },
      { label: "External", value: "external" },
    ],
  }),
  page: r.relation({
    label: "Page",
    targetCollection: "pages",
    condition: { field: "type", equals: "internal" },
  }),
  externalUrl: r.text({
    label: "External URL",
    condition: { field: "type", equals: "external" },
  }),
}))
```

### Multi-Column Layouts

```typescript
.form(({ v, f }) => v.form({
  layout: [
    v.columns({
      columns: [
        { width: 2, fields: [f.title, f.content] },
        { width: 1, fields: [f.status, f.author, f.publishedAt] },
      ],
    }),
  ],
}))
```

## Anti-Patterns to Avoid

### ❌ Using .build() on Admin

```typescript
// Wrong - admin has no .build()
const admin = qa().collections({...}).build();
```

### ❌ String Icons

```typescript
// Wrong - icons must be components
.meta({ icon: "Newspaper" })
```

### ❌ Importing Internal Paths

```typescript
// Wrong - use public exports
import { something } from "@questpie/admin/src/internal/path";

// Correct
import { something } from "@questpie/admin/client";
```

### ❌ Mixing Backend and Admin

```typescript
// Wrong - backend and admin are separate
import { q } from "questpie";
const admin = q().collections({...}); // q is backend!

// Correct
import { qa } from "@questpie/admin/client";
const admin = qa().collections({...});
```

### ❌ Missing Scoped Helpers

```typescript
// Less ideal - no type safety for fields
const admin = qa().collections({
  posts: qa.collection("posts").fields(({ r }) => ({
    title: r.text(), // r might not have all fields
  })),
});

// Better - use builder pattern for type safety
const builder = qa<AppCMS>().use(adminModule);
const posts = builder.collection("posts").fields(({ r }) => ({
  title: r.text(), // r has all fields from adminModule
}));
```

## Next Steps

<Cards>
  <Card href="/docs/admin/patterns/no-build-method" title="No .build() Method" description="Why admin doesn't use .build()" />
  <Card href="/docs/admin/patterns/icons-as-components" title="Icons as Components" description="Proper icon usage" />
  <Card href="/docs/admin/patterns/best-practices" title="Best Practices" description="Production recommendations" />
</Cards>
