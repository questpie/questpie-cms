---
title: Best Practices
description: Production recommendations for QUESTPIE Admin
---

# Best Practices

Recommended patterns and practices for building production-ready admin interfaces with QUESTPIE Admin.

## Project Structure

### Recommended Layout

```
src/questpie/
├── server/                    # Backend CMS (q builder)
│   ├── cms.ts                 # Main CMS instance
│   ├── collections/           # Collection definitions
│   │   ├── posts.ts
│   │   ├── users.ts
│   │   └── index.ts
│   ├── globals/               # Global definitions
│   │   └── settings.ts
│   └── jobs/                  # Background jobs
│       └── send-email.ts
│
└── admin/                     # Admin UI (qa builder)
    ├── admin.ts               # Main admin config
    ├── collections/           # Collection UI configs
    │   ├── posts.ts
    │   ├── users.ts
    │   └── index.ts
    ├── globals/               # Global UI configs
    │   └── settings.ts
    ├── sidebar.ts             # Sidebar configuration
    ├── dashboard.ts           # Dashboard widgets
    └── blocks/                # Custom blocks
        ├── hero.tsx
        └── index.ts
```

### Why This Structure?

- **Clear separation**: Backend and admin are distinct concerns
- **Parallel files**: `posts.ts` in both folders for easy navigation
- **Scalable**: Add collections without touching core files
- **Maintainable**: Each file has a single responsibility

## Configuration Patterns

### Use Scoped Helpers

Always use `qa<AppCMS>().use(adminModule)` for type-safe field access:

```typescript
import { qa, adminModule } from "@questpie/admin/client";
import type { AppCMS } from "./server/cms";

// ✅ Recommended - create a shared builder
const builder = qa<AppCMS>().use(adminModule);

const postsAdmin = builder.collection("posts")
  .fields(({ r }) => ({
    title: r.text(),  // Full autocomplete
  }));

// ❌ Avoid - using qa.collection() without module
const postsAdmin = qa.collection("posts")
  .fields(({ r }) => ({
    title: r.text(),  // May not have all fields
  }));
```

### Export Collections Individually

Export each collection config for better tree-shaking:

```typescript
// collections/posts.ts
export const postsAdmin = builder.collection("posts")...;

// collections/index.ts
export { postsAdmin } from "./posts";
export { usersAdmin } from "./users";

// admin.ts
import { postsAdmin, usersAdmin } from "./collections";

const admin = qa()
  .use(adminModule)
  .collections({ posts: postsAdmin, users: usersAdmin });
```

### Centralize Sidebar Config

Keep sidebar in a dedicated file:

```typescript
// sidebar.ts
import {
  LayoutDashboard,
  FileText,
  Users,
  Settings
} from "lucide-react";

export const sidebarConfig = ({ s }) => [
  s.link({ label: "Dashboard", icon: LayoutDashboard, href: "/admin" }),
  s.section({
    label: "Content",
    items: [
      s.collection({ collection: "posts", icon: FileText }),
      s.collection({ collection: "users", icon: Users }),
    ],
  }),
  s.global({ global: "settings", icon: Settings }),
];

// admin.ts
import { sidebarConfig } from "./sidebar";

const admin = qa()
  .use(adminModule)
  .sidebar(sidebarConfig);
```

## Field Configuration

### Always Provide Labels

Make forms accessible with clear labels:

```typescript
// ✅ Good
.fields(({ r }) => ({
  title: r.text({ label: "Post Title" }),
  publishedAt: r.datetime({ label: "Publish Date" }),
}))

// ❌ Avoid - users see field names as labels
.fields(({ r }) => ({
  title: r.text(),
  publishedAt: r.datetime(),
}))
```

### Use Descriptions for Complex Fields

```typescript
.fields(({ r }) => ({
  slug: r.text({
    label: "URL Slug",
    description: "Used in the post URL. Auto-generated from title if empty.",
  }),
  metaDescription: r.textarea({
    label: "Meta Description",
    description: "Appears in search results. Keep under 160 characters.",
    maxLength: 160,
  }),
}))
```

### Group Related Fields

```typescript
.form(({ v, f }) => v.form({
  layout: [
    v.section({
      title: "Content",
      description: "Main post content",
      fields: [f.title, f.slug, f.content],
    }),
    v.section({
      title: "SEO",
      description: "Search engine optimization",
      collapsible: true,
      fields: [f.metaTitle, f.metaDescription, f.ogImage],
    }),
    v.section({
      title: "Publishing",
      fields: [f.status, f.publishedAt, f.author],
    }),
  ],
}))
```

## List View Configuration

### Limit Visible Columns

Show only essential information:

```typescript
// ✅ Good - focused columns
.list(({ v, f }) => v.table({
  columns: [f.title, f.status, f.author, f.publishedAt],
}))

// ❌ Avoid - too many columns
.list(({ v, f }) => v.table({
  columns: [
    f.title, f.slug, f.content, f.status,
    f.author, f.createdAt, f.updatedAt, f.publishedAt,
    f.metaTitle, f.metaDescription,
  ],
}))
```

### Enable Search and Filters

Make lists navigable:

```typescript
.list(({ v, f }) => v.table({
  columns: [f.title, f.status, f.author],
  searchable: ["title", "content"],  // Enable text search
  filters: [f.status, f.author],     // Enable filtering
  defaultSort: { field: "createdAt", direction: "desc" },
}))
```

### Configure Sensible Defaults

```typescript
.list(({ v, f }) => v.table({
  columns: [f.title, f.status],
  pageSize: 25,          // Reasonable page size
  pageSizeOptions: [10, 25, 50, 100],
  defaultSort: { field: "createdAt", direction: "desc" },
}))
```

## Performance

### Lazy Load Heavy Components

For blocks with heavy dependencies:

```typescript
// blocks/code-editor.tsx
import { lazy } from "react";

const CodeMirror = lazy(() => import("@codemirror/react"));

export function CodeEditorBlock({ content }) {
  return (
    <Suspense fallback={<div>Loading editor...</div>}>
      <CodeMirror value={content} />
    </Suspense>
  );
}
```

### Optimize Relation Fields

Limit relation queries:

```typescript
.fields(({ r }) => ({
  author: r.relation({
    label: "Author",
    targetCollection: "users",
    limit: 50,  // Limit dropdown items
    searchable: true,  // Enable search for large collections
  }),
}))
```

### Use Pagination

Always paginate large collections:

```typescript
const { data, fetchNextPage, hasNextPage } = useCollectionList("posts", {
  limit: 25,  // Don't fetch everything at once
});
```

## Security

### Validate on Backend

Admin UI validation is for UX; always validate on the backend:

```typescript
// Backend (server/collections/posts.ts)
q.collection("posts")
  .fields({ title: text("title") })
  .validation(({ z }) => ({
    title: z.string().min(1).max(200),  // ← Real validation
  }));

// Admin (admin/collections/posts.ts)
qab.collection("posts")
  .fields(({ r }) => ({
    title: r.text({
      maxLength: 200,  // ← Just for UI hints
    }),
  }));
```

### Use Access Control

Implement role-based access:

```typescript
// Backend
q.collection("posts")
  .access({
    read: () => true,
    create: ({ user }) => user?.role === "admin" || user?.role === "editor",
    update: ({ user, doc }) =>
      user?.role === "admin" || doc.authorId === user?.id,
    delete: ({ user }) => user?.role === "admin",
  });
```

### Don't Trust Client Data

Always verify permissions server-side:

```typescript
// Hook with backend validation
const update = useCollectionUpdate("posts");
await update.mutateAsync({
  id,
  data,
  // Backend will verify user can update this post
});
```

## Error Handling

### Provide User Feedback

Use toast notifications for operations:

```typescript
import { toast } from "sonner";

async function handleSave(data) {
  try {
    await updatePost.mutateAsync(data);
    toast.success("Post saved successfully");
  } catch (error) {
    toast.error("Failed to save post", {
      description: error.message,
    });
  }
}
```

### Handle Loading States

Show appropriate loading indicators:

```typescript
function PostForm() {
  const { data, isLoading, error } = useCollectionItem("posts", id);

  if (isLoading) return <FormSkeleton />;
  if (error) return <ErrorMessage error={error} />;

  return <Form data={data} />;
}
```

## Testing

### Test Configuration Separately

```typescript
// __tests__/admin/collections/posts.test.ts
import { postsAdmin } from "../collections/posts";

describe("postsAdmin config", () => {
  it("has required fields", () => {
    expect(postsAdmin.fields.title).toBeDefined();
    expect(postsAdmin.fields.content).toBeDefined();
  });

  it("has list view configured", () => {
    expect(postsAdmin.list.columns).toContain("title");
  });
});
```

### Use Mock Data for Components

```typescript
// __tests__/components/PostForm.test.tsx
const mockPost = {
  id: "1",
  title: "Test Post",
  content: "Content",
  status: "draft",
};

test("renders post form", () => {
  render(<PostForm data={mockPost} />);
  expect(screen.getByLabelText("Title")).toHaveValue("Test Post");
});
```

## Summary Checklist

- [ ] Use `qa<AppCMS>().use(adminModule)` for scoped helpers
- [ ] Separate backend and admin configs
- [ ] Provide labels and descriptions for fields
- [ ] Group related fields in sections
- [ ] Limit list view columns
- [ ] Enable search and filters
- [ ] Use icons as components (not strings)
- [ ] Validate on backend, not just admin
- [ ] Handle loading and error states
- [ ] Use toast for user feedback

## Next Steps

<Cards>
  <Card href="/docs/admin/patterns/no-build-method" title="No .build() Method" description="Understanding admin config" />
  <Card href="/docs/guides/authentication" title="Authentication" description="Set up user authentication" />
</Cards>
