---
title: Type Inference
description: How TypeScript types flow through QUESTPIE Admin
---

# Type Inference

QUESTPIE Admin leverages TypeScript's type inference to provide excellent autocomplete and type safety.

## How Types Flow

```typescript
const admin = qa()
  .use(adminModule)
  .collections({
    posts: postsAdmin,
    users: usersAdmin,
  });

// TypeScript infers:
// - Available collection names
// - Field names for each collection
// - Widget types for dashboard
// - View types for lists and forms
```

## Collection Names

Collection names are inferred from your configuration:

```typescript
type Names = CollectionNames<typeof admin>;
// "posts" | "users"
```

This enables type-safe navigation:

```typescript
const { navigate } = useAdminRoutes();

navigate.collection("posts");   // ✅ Valid
navigate.collection("invalid"); // ❌ Type error
```

## Field Names

Field names are inferred per collection:

```typescript
const postsAdmin = qab.collection("posts")
  .fields(({ r }) => ({
    title: r.text(),
    content: r.richText(),
    status: r.select({ options: [...] }),
  }));

type PostFields = FieldNames<typeof postsAdmin>;
// "title" | "content" | "status"
```

## The Proxy Pattern

The `({ r })`, `({ v, f })` pattern enables type inference:

### Field Registry Proxy

```typescript
.fields(({ r }) => ({
  // r is typed as: FieldRegistryProxy<FieldRegistry>
  // It knows all registered field types

  title: r.text({ label: "Title" }),
  //       ^--- Autocomplete shows: text, select, relation, etc.
  //            Config is typed: TextFieldConfig
}))
```

### View and Field Proxy

```typescript
.list(({ v, f }) => v.table({
  // v is typed as: ViewRegistryProxy<ViewRegistry>
  // f is typed as: FieldProxy<YourFields>

  columns: [f.title, f.status],
  //         ^--- Autocomplete shows your defined fields
}))
```

## Type Helper Functions

### createAdminHelpers

Create typed helper functions:

```typescript
import { createAdminHelpers } from "@questpie/admin";

const h = createAdminHelpers(admin);

// Typed navigation
h.navigate.collection("posts");     // ✅
h.navigate.collection("invalid");   // ❌ Error

// Typed hooks
const { data } = h.hooks.useCollectionList("posts");
// data is typed as Post[]
```

### CollectionNames Type

Extract collection name union:

```typescript
import type { CollectionNames } from "@questpie/admin";

type Names = CollectionNames<typeof admin>;
// "posts" | "users"

function goToCollection(name: Names) {
  // Only accepts valid collection names
}
```

### GlobalNames Type

Extract global name union:

```typescript
import type { GlobalNames } from "@questpie/admin";

type Names = GlobalNames<typeof admin>;
// "settings" | "navigation"
```

## Module Type Augmentation

For advanced use cases, augment module types:

```typescript
// types/admin.d.ts
declare module "@questpie/admin" {
  interface AdminCollectionRegistry {
    posts: typeof postsAdmin;
    users: typeof usersAdmin;
  }
}
```

## Inferred Config Types

Field configurations are fully typed:

```typescript
// TextFieldConfig is inferred
r.text({
  label: "Title",     // ✅ Valid property
  maxLength: 200,     // ✅ Valid property
  invalid: true,      // ❌ Type error - unknown property
});

// SelectFieldConfig is inferred
r.select({
  options: [
    { label: "Draft", value: "draft" },
    { label: "Published", value: "published" },
  ],
  // Type error if options is missing!
});
```

## Relation Type Safety

Relations get autocomplete for target collections:

```typescript
r.relation({
  label: "Author",
  targetCollection: "users",  // ✅ Autocomplete from backend
  // targetCollection: "invalid"  // ❌ Error if invalid
});
```

<Callout type="info">
  Relation autocomplete requires the backend CMS type to be connected. See the setup guide for TypeScript configuration.
</Callout>

## Generic Collection Builder

Create type-safe generic functions:

```typescript
function createSearchableCollection<T extends string>(
  name: T,
  searchFields: string[]
) {
  return qab.collection(name)
    .list(({ v, f }) => v.table({
      searchable: searchFields,
    }));
}

const postsAdmin = createSearchableCollection("posts", ["title", "content"]);
```

## Conditional Types

Use conditional types for advanced patterns:

```typescript
type HasBlocks<T> = T extends { blocks: any } ? true : false;

function configureCollection<T extends CollectionConfig>(config: T) {
  // Type-safe based on config shape
  if ("blocks" in config) {
    // config.blocks is typed
  }
}
```

## Best Practices

### Let TypeScript Infer

Don't over-annotate; let inference work:

```typescript
// ❌ Over-annotated
const postsAdmin: CollectionConfig<"posts", PostFields> = qab.collection("posts")...

// ✅ Let inference handle it
const postsAdmin = qab.collection("posts")...
```

### Use Type Helpers

Leverage built-in type helpers:

```typescript
import type {
  CollectionNames,
  GlobalNames,
  FieldNames,
  InferCollectionData,
} from "@questpie/admin";

// Instead of manually typing
type PostData = InferCollectionData<typeof postsAdmin>;
```

### Export Types Alongside Config

```typescript
// collections/posts.ts
export const postsAdmin = qab.collection("posts")...

// Export inferred types
export type PostFields = FieldNames<typeof postsAdmin>;
export type PostData = InferCollectionData<typeof postsAdmin>;
```

## Troubleshooting

### Types Not Updating

If autocomplete doesn't update after changes:

1. Restart TypeScript server in your IDE
2. Check for circular imports
3. Ensure you're using `.use(adminModule)` on your builder

### Generic Inference Fails

If generics aren't inferring:

```typescript
// ❌ Inference fails with explicit generic
const admin = qa<MyType>()...

// ✅ Let inference work
const admin = qa()...
```

### Missing Field Types

If a field type isn't available:

```typescript
// Ensure module is included with .use()
const builder = qa<AppCMS>().use(adminModule);  // ← adminModule has the fields
```

## Related

- [Scoped Helpers](/docs/admin/qa-from) - Type-safe field access
- [Extensibility](/docs/admin/extensibility) - Create custom extensions
